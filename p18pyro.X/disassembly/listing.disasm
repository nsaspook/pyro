Disassembly Listing for p18pyro
Generated From:
/sdd/work/mx320/pyro/p18pyro.X/dist/default/production/p18pyro.X.production.cof
May 19, 2016 4:15:05 PM

---  /sdd/work/mx320/pyro/p18pyro.X/xlcd/writdata.c  ----------------------------------------------------
1:             #include <p18cxxx.h>
2:             #include "xlcd.h"
3:             
4:             void S_WriteDataXLCD(char data)
3708  CFD9     MOVFF FSR2, POSTINC1
370A  FFE6     NOP
370C  CFE1     MOVFF FSR1, FSR2
370E  FFD9     NOP
3710  E982     SUBFSR 2, 0x2
5:             {
6:             	while (ringBufS_full(L.tx1b)) DLED_7 = ON; // normally there is plenty of space
3712  C435     MOVFF 0x435, POSTINC1
3714  FFE6     NOP
3716  C436     MOVFF 0x436, POSTINC1
3718  FFE6     NOP
371A  EC2E     CALL 0x2C5C, 0
371C  F016     NOP
371E  E942     SUBFSR 1, 0x2
3720  0900     IORLW 0x0
3722  E002     BZ 0x3728
3724  9E91     BCF LATJ, 7, ACCESS
3726  D7F5     BRA 0x3712
7:             	ringBufS_put(L.tx1b, data);
3728  EB00     MOVSF 0x0, 0x1F1
372A  F1F1     NOP
372C  0101     MOVLB 0x1
372E  6BF2     CLRF 0xF2, BANKED
3730  BFF1     BTFSC spi_buf, 7, BANKED
3732  69F2     SETF 0xF2, BANKED
3734  C1F1     MOVFF __tmp_0, POSTINC1
3736  FFE6     NOP
3738  C1F2     MOVFF 0x1F2, POSTINC1
373A  FFE6     NOP
373C  C435     MOVFF 0x435, POSTINC1
373E  FFE6     NOP
3740  C436     MOVFF 0x436, POSTINC1
3742  FFE6     NOP
3744  EC6B     CALL 0x2CD6, 0
3746  F016     NOP
3748  E944     SUBFSR 1, 0x4
8:             	return;
9:             }
374A  E941     SUBFSR 1, 0x1
374C  CFE7     MOVFF INDF1, FSR2
374E  FFD9     NOP
3750  0012     RETURN 0
10:            
11:            /********************************************************************
12:             *       Function Name:  WriteDataXLCD                               *
13:             *       Return Value:   void                                        *
14:             *       Parameters:     data: data byte to be written to LCD        *
15:             *       Description:    This routine writes a data byte to the      *
16:             *                       Hitachi HD44780 LCD controller. The user    *
17:             *                       must check to see if the LCD controller is  *
18:             *                       busy before calling this routine. The data  *
19:             *                       is written to the character generator RAM or*
20:             *                       the display data RAM depending on what the  *
21:             *                       previous SetxxRamAddr routine was called.   *
22:             ********************************************************************/
23:            void WriteDataXLCD(char data)
3752  CFD9     MOVFF FSR2, POSTINC1
3754  FFE6     NOP
3756  CFE1     MOVFF FSR1, FSR2
3758  FFD9     NOP
375A  E982     SUBFSR 2, 0x2
24:            {
25:            #ifdef BIT8                             // 8-bit interface
26:            	TRIS_DATA_PORT = 0; // Make port output
27:            	DATA_PORT = data; // Write data to port
28:            	RS_PIN = 1; // Set control bits
29:            	RW_PIN = 0;
30:            	DelayFor18TCY();
31:            	E_PIN = 1; // Clock data into LCD
32:            	DelayFor18TCY();
33:            	E_PIN = 0;
34:            	RS_PIN = 0; // Reset control bits
35:            	TRIS_DATA_PORT = 0xff; // Make port input
36:            #else                                   // 4-bit interface
37:            #ifdef UPPER                            // Upper nibble interface
38:            	TRIS_DATA_PORT &= 0x0f;
375C  0E0F     MOVLW 0xF
375E  1699     ANDWF TRISH, F, ACCESS
39:            	DATA_PORT &= 0x0f;
3760  1687     ANDWF PORTH, F, ACCESS
40:            	DATA_PORT |= data & 0xf0;
3762  0EF0     MOVLW 0xF0
3764  1400     ANDWF [0x0], W, ACCESS
3766  1287     IORWF PORTH, F, ACCESS
41:            #else                                   // Lower nibble interface
42:            	TRIS_DATA_PORT &= 0xf0;
43:            	DATA_PORT &= 0xf0;
44:            	DATA_PORT |= ((data >> 4)&0x0f);
45:            #endif
46:            	RS_PIN = 1; // Set control bits
3768  8290     BSF LATH, 1, ACCESS
47:            	RW_PIN = 0;
376A  9490     BCF LATH, 2, ACCESS
48:            	DelayFor18TCY();
376C  D80D     RCALL __pa_0
3788  EC3A     CALL 0x74, 0
378A  F000     NOP
49:            	E_PIN = 1; // Clock nibble into LCD
378C  8690     BSF LATH, 3, ACCESS
50:            	DelayFor18TCY();
378E  EC3A     CALL 0x74, 0
3790  F000     NOP
51:            	E_PIN = 0;
3792  9690     BCF LATH, 3, ACCESS
3794  0012     RETURN 0
52:            #ifdef UPPER                            // Upper nibble interface
53:            	DATA_PORT &= 0x0f;
376E  0E0F     MOVLW 0xF
3770  1687     ANDWF PORTH, F, ACCESS
54:            	DATA_PORT |= ((data << 4)&0xf0);
3772  3800     SWAPF [0x0], W, ACCESS
3774  0BF0     ANDLW 0xF0
3776  0BF0     ANDLW 0xF0
3778  1287     IORWF PORTH, F, ACCESS
55:            #else                                   // Lower nibble interface
56:            	DATA_PORT &= 0xf0;
57:            	DATA_PORT |= (data & 0x0f);
58:            #endif
59:            	DelayFor18TCY();
377A  D806     RCALL __pa_0
60:            	E_PIN = 1; // Clock nibble into LCD
61:            	DelayFor18TCY();
62:            	E_PIN = 0;
63:            #ifdef UPPER                            // Upper nibble interface
64:            	TRIS_DATA_PORT |= 0xf0;
377C  0EF0     MOVLW 0xF0
377E  1299     IORWF TRISH, F, ACCESS
65:            #else                                   // Lower nibble interface
66:            	TRIS_DATA_PORT |= 0x0f;
67:            #endif
68:            #endif
69:            	return;
70:            }
3780  E941     SUBFSR 1, 0x1
3782  CFE7     MOVFF INDF1, FSR2
3784  FFD9     NOP
3786  0012     RETURN 0
71:            
---  /sdd/work/mx320/pyro/p18pyro.X/xlcd/wcmdxlcd.c  ----------------------------------------------------
1:             #include <p18cxxx.h>
2:             #include "xlcd.h"
3:             
4:             void S_WriteCmdXLCD(unsigned char cmd)
3796  CFD9     MOVFF FSR2, POSTINC1
3798  FFE6     NOP
379A  CFE1     MOVFF FSR1, FSR2
379C  FFD9     NOP
379E  E982     SUBFSR 2, 0x2
37A0  E842     ADDFSR 1, 0x2
5:             {
6:             	union lcd_buf_type lcd_buf;
7:             
8:             	while (ringBufS_full(L.tx1b)) DLED_7 = ON;
37A2  C435     MOVFF 0x435, POSTINC1
37A4  FFE6     NOP
37A6  C436     MOVFF 0x436, POSTINC1
37A8  FFE6     NOP
37AA  EC2E     CALL 0x2C5C, 0
37AC  F016     NOP
37AE  E942     SUBFSR 1, 0x2
37B0  0900     IORLW 0x0
37B2  E002     BZ 0x37B8
37B4  9E91     BCF LATJ, 7, ACCESS
37B6  D7F5     BRA 0x37A2
9:             	lcd_buf.buf = cmd;
37B8  5000     MOVF [0x0], W, ACCESS
37BA  6E02     MOVWF [0x2], ACCESS
37BC  6A03     CLRF [0x3], ACCESS
10:            	lcd_buf.map.cmd = 1;
37BE  8203     BSF [0x3], 1, ACCESS
11:            	lcd_buf.map.slow = 0;
37C0  9003     BCF [0x3], 0, ACCESS
12:            	ringBufS_put(L.tx1b, lcd_buf.buf);
37C2  EB02     MOVSF 0x2, 0xFE6
37C4  FFE6     NOP
37C6  EB03     MOVSF 0x3, 0xFE6
37C8  FFE6     NOP
37CA  C435     MOVFF 0x435, POSTINC1
37CC  FFE6     NOP
37CE  C436     MOVFF 0x436, POSTINC1
37D0  FFE6     NOP
37D2  EC6B     CALL 0x2CD6, 0
37D4  F016     NOP
37D6  E944     SUBFSR 1, 0x4
13:            	return;
14:            }
37D8  E943     SUBFSR 1, 0x3
37DA  CFE7     MOVFF INDF1, FSR2
37DC  FFD9     NOP
37DE  0012     RETURN 0
15:            
16:            /********************************************************************
17:             *       Function Name:  WriteCmdXLCD                                *
18:             *       Return Value:   void                                        *
19:             *       Parameters:     cmd: command to send to LCD                 *
20:             *       Description:    This routine writes a command to the Hitachi*
21:             *                       HD44780 LCD controller. The user must check *
22:             *                       to see if the LCD controller is busy before *
23:             *                       calling this routine.                       *
24:             ********************************************************************/
25:            void WriteCmdXLCD(unsigned char cmd)
37E0  CFD9     MOVFF FSR2, POSTINC1
37E2  FFE6     NOP
37E4  CFE1     MOVFF FSR1, FSR2
37E6  FFD9     NOP
37E8  E982     SUBFSR 2, 0x2
26:            {
27:            #ifdef BIT8                             // 8-bit interface
28:            	TRIS_DATA_PORT = 0; // Data port output
29:            	DATA_PORT = cmd; // Write command to data port
30:            	RW_PIN = 0; // Set the control signals
31:            	RS_PIN = 0; // for sending a command
32:            	DelayFor18TCY();
33:            	E_PIN = 1; // Clock the command in
34:            	DelayFor18TCY();
35:            	E_PIN = 0;
36:            	DelayFor18TCY();
37:            	TRIS_DATA_PORT = 0xff; // Data port input
38:            #else                                   // 4-bit interface
39:            #ifdef UPPER                            // Upper nibble interface
40:            	TRIS_DATA_PORT &= 0x0f;
37EA  0E0F     MOVLW 0xF
37EC  1699     ANDWF TRISH, F, ACCESS
41:            	DATA_PORT &= 0x0f;
37EE  1687     ANDWF PORTH, F, ACCESS
42:            	DATA_PORT |= cmd & 0xf0;
37F0  0EF0     MOVLW 0xF0
37F2  1400     ANDWF [0x0], W, ACCESS
37F4  1287     IORWF PORTH, F, ACCESS
43:            #else                                   // Lower nibble interface
44:            	TRIS_DATA_PORT &= 0xf0;
45:            	DATA_PORT &= 0xf0;
46:            	DATA_PORT |= (cmd >> 4)&0x0f;
47:            #endif
48:            	RW_PIN = 0; // Set control signals for command
37F6  9490     BCF LATH, 2, ACCESS
49:            	RS_PIN = 0;
37F8  9290     BCF LATH, 1, ACCESS
50:            	DelayFor18TCY();
37FA  D80D     RCALL __pa_0
3816  EC3A     CALL 0x74, 0
3818  F000     NOP
51:            	E_PIN = 1; // Clock command in
381A  8690     BSF LATH, 3, ACCESS
52:            	DelayFor18TCY();
381C  EC3A     CALL 0x74, 0
381E  F000     NOP
53:            	E_PIN = 0;
3820  9690     BCF LATH, 3, ACCESS
3822  0012     RETURN 0
54:            #ifdef UPPER                            // Upper nibble interface
55:            	DATA_PORT &= 0x0f;
37FC  0E0F     MOVLW 0xF
37FE  1687     ANDWF PORTH, F, ACCESS
56:            	DATA_PORT |= (cmd << 4)&0xf0;
3800  3800     SWAPF [0x0], W, ACCESS
3802  0BF0     ANDLW 0xF0
3804  0BF0     ANDLW 0xF0
3806  1287     IORWF PORTH, F, ACCESS
57:            #else                                   // Lower nibble interface
58:            	DATA_PORT &= 0xf0;
59:            	DATA_PORT |= cmd & 0x0f;
60:            #endif
61:            	DelayFor18TCY();
3808  D806     RCALL __pa_0
62:            	E_PIN = 1; // Clock command in
63:            	DelayFor18TCY();
64:            	E_PIN = 0;
65:            #ifdef UPPER                            // Make data nibble input
66:            	TRIS_DATA_PORT |= 0xf0;
380A  0EF0     MOVLW 0xF0
380C  1299     IORWF TRISH, F, ACCESS
67:            #else
68:            	TRIS_DATA_PORT |= 0x0f;
69:            #endif
70:            #endif
71:            	return;
72:            }
380E  E941     SUBFSR 1, 0x1
3810  CFE7     MOVFF INDF1, FSR2
3812  FFD9     NOP
3814  0012     RETURN 0
73:            
---  /sdd/work/mx320/pyro/p18pyro.X/xlcd/setddram.c  ----------------------------------------------------
1:             #include <p18cxxx.h>
2:             #include "xlcd.h"
3:             
4:             /********************************************************************
5:              *       Function Name:  SetDDRamAddr                                *
6:              *       Return Value:   void                                        *
7:              *       Parameters:     CGaddr: display data address                *
8:              *       Description:    This routine sets the display data address  *
9:              *                       of the Hitachi HD44780 LCD controller. The  *
10:             *                       user must check to see if the LCD controller*
11:             *                       is busy before calling this routine.        *
12:             ********************************************************************/
13:            void SetDDRamAddr(unsigned char DDaddr)
3B7A  CFD9     MOVFF FSR2, POSTINC1
3B7C  FFE6     NOP
3B7E  CFE1     MOVFF FSR1, FSR2
3B80  FFD9     NOP
3B82  E982     SUBFSR 2, 0x2
14:            {
15:            #ifdef BIT8                                     // 8-bit interface
16:            	TRIS_DATA_PORT = 0; // Make port output
17:            	DATA_PORT = DDaddr | 0b10000000; // Write cmd and address to port
18:            	RW_PIN = 0; // Set the control bits
19:            	RS_PIN = 0;
20:            	DelayFor18TCY();
21:            	E_PIN = 1; // Clock the cmd and address in
22:            	DelayFor18TCY();
23:            	E_PIN = 0;
24:            	DelayFor18TCY();
25:            	TRIS_DATA_PORT = 0xff; // Make port input
26:            #else                                           // 4-bit interface
27:            #ifdef UPPER                                    // Upper nibble  interface
28:            	TRIS_DATA_PORT &= 0x0f; // Make port output
3B84  0E0F     MOVLW 0xF
3B86  1699     ANDWF TRISH, F, ACCESS
29:            	DATA_PORT &= 0x0f; // and write upper nibble
3B88  1687     ANDWF PORTH, F, ACCESS
30:            	DATA_PORT |= ((DDaddr | 0b10000000) & 0xf0);
3B8A  0E80     MOVLW 0x80
3B8C  1000     IORWF [0x0], W, ACCESS
3B8E  0BF0     ANDLW 0xF0
3B90  1287     IORWF PORTH, F, ACCESS
31:            #else                                           // Lower nibble interface
32:            	TRIS_DATA_PORT &= 0xf0; // Make port output
33:            	DATA_PORT &= 0xf0; // and write upper nibble
34:            	DATA_PORT |= (((DDaddr | 0b10000000) >> 4) & 0x0f);
35:            #endif
36:            	RW_PIN = 0; // Set control bits
3B92  9490     BCF LATH, 2, ACCESS
37:            	RS_PIN = 0;
3B94  9290     BCF LATH, 1, ACCESS
38:            	DelayFor18TCY();
3B96  D80D     RCALL __pa_0
3BB2  EC3A     CALL 0x74, 0
3BB4  F000     NOP
39:            	E_PIN = 1; // Clock the cmd and address in
3BB6  8690     BSF LATH, 3, ACCESS
40:            	DelayFor18TCY();
3BB8  EC3A     CALL 0x74, 0
3BBA  F000     NOP
41:            	E_PIN = 0;
3BBC  9690     BCF LATH, 3, ACCESS
3BBE  0012     RETURN 0
42:            #ifdef UPPER                                    // Upper nibble interface
43:            	DATA_PORT &= 0x0f; // Write lower nibble
3B98  0E0F     MOVLW 0xF
3B9A  1687     ANDWF PORTH, F, ACCESS
44:            	DATA_PORT |= ((DDaddr << 4)&0xf0);
3B9C  3800     SWAPF [0x0], W, ACCESS
3B9E  0BF0     ANDLW 0xF0
3BA0  0BF0     ANDLW 0xF0
3BA2  1287     IORWF PORTH, F, ACCESS
45:            #else                                           // Lower nibble interface
46:            	DATA_PORT &= 0xf0; // Write lower nibble
47:            	DATA_PORT |= (DDaddr & 0x0f);
48:            #endif
49:            	DelayFor18TCY();
3BA4  D806     RCALL __pa_0
50:            	E_PIN = 1; // Clock the cmd and address in
51:            	DelayFor18TCY();
52:            	E_PIN = 0;
53:            #ifdef UPPER                                    // Upper nibble interface
54:            	TRIS_DATA_PORT |= 0xf0; // Make port input
3BA6  0EF0     MOVLW 0xF0
3BA8  1299     IORWF TRISH, F, ACCESS
55:            #else                                           // Lower nibble interface
56:            	TRIS_DATA_PORT |= 0x0f; // Make port input
57:            #endif
58:            #endif
59:            	return;
60:            }
3BAA  E941     SUBFSR 1, 0x1
3BAC  CFE7     MOVFF INDF1, FSR2
3BAE  FFD9     NOP
3BB0  0012     RETURN 0
61:            
---  /sdd/work/mx320/pyro/p18pyro.X/xlcd/setcgram.c  ----------------------------------------------------
1:             #include <p18cxxx.h>
2:             #include "xlcd.h"
3:             
4:             /********************************************************************
5:              *       Function Name:  SetCGRamAddr                                *
6:              *       Return Value:   void                                        *
7:              *       Parameters:     CGaddr: character generator ram address     *
8:              *       Description:    This routine sets the character generator   *
9:              *                       address of the Hitachi HD44780 LCD          *
10:             *                       controller. The user must check to see if   *
11:             *                       the LCD controller is busy before calling   *
12:             *                       this routine.                               *
13:             ********************************************************************/
14:            void SetCGRamAddr(unsigned char CGaddr)
3BC0  CFD9     MOVFF FSR2, POSTINC1
3BC2  FFE6     NOP
3BC4  CFE1     MOVFF FSR1, FSR2
3BC6  FFD9     NOP
3BC8  E982     SUBFSR 2, 0x2
15:            {
16:            #ifdef BIT8                                     // 8-bit interface
17:            	TRIS_DATA_PORT = 0; // Make data port ouput
18:            	DATA_PORT = CGaddr | 0b01000000; // Write cmd and address to port
19:            	RW_PIN = 0; // Set control signals
20:            	RS_PIN = 0;
21:            	DelayFor18TCY();
22:            	E_PIN = 1; // Clock cmd and address in
23:            	DelayFor18TCY();
24:            	E_PIN = 0;
25:            	DelayFor18TCY();
26:            	TRIS_DATA_PORT = 0xff; // Make data port inputs
27:            #else                                           // 4-bit interface
28:            #ifdef UPPER                                    // Upper nibble interface
29:            	TRIS_DATA_PORT &= 0x0f; // Make nibble input
3BCA  0E0F     MOVLW 0xF
3BCC  1699     ANDWF TRISH, F, ACCESS
30:            	DATA_PORT &= 0x0f; // and write upper nibble
3BCE  1687     ANDWF PORTH, F, ACCESS
31:            	DATA_PORT |= ((CGaddr | 0b01000000) & 0xf0);
3BD0  0E40     MOVLW 0x40
3BD2  1000     IORWF [0x0], W, ACCESS
3BD4  0BF0     ANDLW 0xF0
3BD6  1287     IORWF PORTH, F, ACCESS
32:            #else                                           // Lower nibble interface
33:            	TRIS_DATA_PORT &= 0xf0; // Make nibble input
34:            	DATA_PORT &= 0xf0; // and write upper nibble
35:            	DATA_PORT |= (((CGaddr | 0b01000000) >> 4) & 0x0f);
36:            #endif
37:            	RW_PIN = 0; // Set control signals
3BD8  9490     BCF LATH, 2, ACCESS
38:            	RS_PIN = 0;
3BDA  9290     BCF LATH, 1, ACCESS
39:            	DelayFor18TCY();
3BDC  D80D     RCALL __pa_0
3BF8  EC3A     CALL 0x74, 0
3BFA  F000     NOP
40:            	E_PIN = 1; // Clock cmd and address in
3BFC  8690     BSF LATH, 3, ACCESS
41:            	DelayFor18TCY();
3BFE  EC3A     CALL 0x74, 0
3C00  F000     NOP
42:            	E_PIN = 0;
3C02  9690     BCF LATH, 3, ACCESS
3C04  0012     RETURN 0
43:            #ifdef UPPER                                    // Upper nibble interface
44:            	DATA_PORT &= 0x0f; // Write lower nibble
3BDE  0E0F     MOVLW 0xF
3BE0  1687     ANDWF PORTH, F, ACCESS
45:            	DATA_PORT |= ((CGaddr << 4)&0xf0);
3BE2  3800     SWAPF [0x0], W, ACCESS
3BE4  0BF0     ANDLW 0xF0
3BE6  0BF0     ANDLW 0xF0
3BE8  1287     IORWF PORTH, F, ACCESS
46:            #else                                           // Lower nibble interface
47:            	DATA_PORT &= 0xf0; // Write lower nibble
48:            	DATA_PORT |= (CGaddr & 0x0f);
49:            #endif
50:            	DelayFor18TCY();
3BEA  D806     RCALL __pa_0
51:            	E_PIN = 1; // Clock cmd and address in
52:            	DelayFor18TCY();
53:            	E_PIN = 0;
54:            #ifdef UPPER                                    // Upper nibble interface
55:            	TRIS_DATA_PORT |= 0xf0; // Make inputs
3BEC  0EF0     MOVLW 0xF0
3BEE  1299     IORWF TRISH, F, ACCESS
56:            #else                                           // Lower nibble interface
57:            	TRIS_DATA_PORT |= 0x0f; // Make inputs
58:            #endif
59:            #endif
60:            	return;
61:            }
3BF0  E941     SUBFSR 1, 0x1
3BF2  CFE7     MOVFF INDF1, FSR2
3BF4  FFD9     NOP
3BF6  0012     RETURN 0
62:            
---  /sdd/work/mx320/pyro/p18pyro.X/xlcd/readdata.c  ----------------------------------------------------
1:             #include <p18cxxx.h>
2:             #include "xlcd.h"
3:             
4:             /********************************************************************
5:              *       Function Name:  ReadDataXLCD                                *
6:              *       Return Value:   char: data byte from LCD controller         *
7:              *       Parameters:     void                                        *
8:              *       Description:    This routine reads a data byte from the     *
9:              *                       Hitachi HD44780 LCD controller. The user    *
10:             *                       must check to see if the LCD controller is  *
11:             *                       busy before calling this routine. The data  *
12:             *                       is read from the character generator RAM or *
13:             *                       the display data RAM depending on what the  *
14:             *                       previous SetxxRamAddr routine was called.   *
15:             ********************************************************************/
16:            char ReadDataXLCD(void)
3C4C  CFD9     MOVFF FSR2, POSTINC1
3C4E  FFE6     NOP
3C50  CFE1     MOVFF FSR1, FSR2
3C52  FFD9     NOP
3C54  E981     SUBFSR 2, 0x1
3C56  E841     ADDFSR 1, 0x1
17:            {
18:            	char data;
19:            
20:            #ifdef BIT8                             // 8-bit interface
21:            	RS_PIN = 1; // Set the control bits
22:            	RW_PIN = 1;
23:            	DelayFor18TCY();
24:            	E_PIN = 1; // Clock the data out of the LCD
25:            	DelayFor18TCY();
26:            	data = DATA_PORT; // Read the data
27:            	E_PIN = 0;
28:            	RS_PIN = 0; // Reset the control bits
29:            	RW_PIN = 0;
30:            #else                                   // 4-bit interface
31:            	RW_PIN = 1;
3C58  8490     BSF LATH, 2, ACCESS
32:            	RS_PIN = 1;
3C5A  8290     BSF LATH, 1, ACCESS
33:            	DelayFor18TCY();
3C5C  EC3A     CALL 0x74, 0
3C5E  F000     NOP
34:            	E_PIN = 1; // Clock the data out of the LCD
3C60  8690     BSF LATH, 3, ACCESS
35:            	DelayFor18TCY();
3C62  EC3A     CALL 0x74, 0
3C64  F000     NOP
36:            #ifdef UPPER                            // Upper nibble interface
37:            	data = DATA_PORT & 0xf0; // Read the upper nibble of data
3C66  0EF0     MOVLW 0xF0
3C68  1487     ANDWF PORTH, W, ACCESS
3C6A  6E01     MOVWF [0x1], ACCESS
38:            #else                                   // Lower nibble interface
39:            	data = (DATA_PORT << 4)&0xf0; // read the upper nibble of data
40:            #endif
41:            	E_PIN = 0; // Reset the clock line
3C6C  9690     BCF LATH, 3, ACCESS
42:            	DelayFor18TCY();
3C6E  EC3A     CALL 0x74, 0
3C70  F000     NOP
43:            	E_PIN = 1; // Clock the next nibble out of the LCD
3C72  8690     BSF LATH, 3, ACCESS
44:            	DelayFor18TCY();
3C74  EC3A     CALL 0x74, 0
3C76  F000     NOP
45:            #ifdef UPPER                            // Upper nibble interface
46:            	data |= (DATA_PORT >> 4)&0x0f; // Read the lower nibble of data
3C78  3887     SWAPF PORTH, W, ACCESS
3C7A  0B0F     ANDLW 0xF
3C7C  0B0F     ANDLW 0xF
3C7E  1201     IORWF [0x1], F, ACCESS
47:            #else                                   // Lower nibble interface
48:            	data |= DATA_PORT & 0x0f; // Read the lower nibble of data
49:            #endif
50:            	E_PIN = 0;
3C80  9690     BCF LATH, 3, ACCESS
51:            	RS_PIN = 0; // Reset the control bits
3C82  9290     BCF LATH, 1, ACCESS
52:            	RW_PIN = 0;
3C84  9490     BCF LATH, 2, ACCESS
53:            #endif
54:            	return(data); // Return the data byte
3C86  5001     MOVF [0x1], W, ACCESS
55:            }
3C88  E942     SUBFSR 1, 0x2
3C8A  CFE7     MOVFF INDF1, FSR2
3C8C  FFD9     NOP
3C8E  0012     RETURN 0
56:            
---  /sdd/work/mx320/pyro/p18pyro.X/xlcd/readaddr.c  ----------------------------------------------------
1:             #include <p18cxxx.h>
2:             #include "xlcd.h"
3:             
4:             /*********************************************************************
5:              *       Function Name:  ReadAddrXLCD                                 *
6:              *       Return Value:   char: address from LCD controller            *
7:              *       Parameters:     void                                         *
8:              *       Description:    This routine reads an address byte from the  *
9:              *                       Hitachi HD44780 LCD controller. The user     *
10:             *                       must check to see if the LCD controller is   *
11:             *                       busy before calling this routine. The address*
12:             *                       is read from the character generator RAM or  *
13:             *                       the display data RAM depending on what the   *
14:             *                       previous SetxxRamAddr routine was called.    *
15:             *********************************************************************/
16:            unsigned char ReadAddrXLCD(void)
3C90  CFD9     MOVFF FSR2, POSTINC1
3C92  FFE6     NOP
3C94  CFE1     MOVFF FSR1, FSR2
3C96  FFD9     NOP
3C98  E981     SUBFSR 2, 0x1
3C9A  E841     ADDFSR 1, 0x1
17:            {
18:            	char data; // Holds the data retrieved from the LCD
19:            
20:            #ifdef BIT8                             // 8-bit interface
21:            	RW_PIN = 1; // Set control bits for the read
22:            	RS_PIN = 0;
23:            	DelayFor18TCY();
24:            	E_PIN = 1; // Clock data out of the LCD controller
25:            	DelayFor18TCY();
26:            	data = DATA_PORT; // Save the data in the register
27:            	E_PIN = 0;
28:            	RW_PIN = 0; // Reset the control bits
29:            #else                                   // 4-bit interface
30:            	RW_PIN = 1; // Set control bits for the read
3C9C  8490     BSF LATH, 2, ACCESS
31:            	RS_PIN = 0;
3C9E  9290     BCF LATH, 1, ACCESS
32:            	DelayFor18TCY();
3CA0  EC3A     CALL 0x74, 0
3CA2  F000     NOP
33:            	E_PIN = 1; // Clock data out of the LCD controller
3CA4  8690     BSF LATH, 3, ACCESS
34:            	DelayFor18TCY();
3CA6  EC3A     CALL 0x74, 0
3CA8  F000     NOP
35:            #ifdef UPPER                            // Upper nibble interface
36:            	data = DATA_PORT & 0xf0; // Read the nibble into the upper nibble of data
3CAA  0EF0     MOVLW 0xF0
3CAC  1487     ANDWF PORTH, W, ACCESS
3CAE  6E01     MOVWF [0x1], ACCESS
37:            #else                                   // Lower nibble interface
38:            	data = (DATA_PORT << 4)&0xf0; // Read the nibble into the upper nibble of data
39:            #endif
40:            	E_PIN = 0; // Reset the clock
3CB0  9690     BCF LATH, 3, ACCESS
41:            	DelayFor18TCY();
3CB2  EC3A     CALL 0x74, 0
3CB4  F000     NOP
42:            	E_PIN = 1; // Clock out the lower nibble
3CB6  8690     BSF LATH, 3, ACCESS
43:            	DelayFor18TCY();
3CB8  EC3A     CALL 0x74, 0
3CBA  F000     NOP
44:            #ifdef UPPER                            // Upper nibble interface
45:            	data |= (DATA_PORT >> 4)&0x0f; // Read the nibble into the lower nibble of data
3CBC  3887     SWAPF PORTH, W, ACCESS
3CBE  0B0F     ANDLW 0xF
3CC0  0B0F     ANDLW 0xF
3CC2  1201     IORWF [0x1], F, ACCESS
46:            #else                                   // Lower nibble interface
47:            	data |= DATA_PORT & 0x0f; // Read the nibble into the lower nibble of data
48:            #endif
49:            	E_PIN = 0;
3CC4  9690     BCF LATH, 3, ACCESS
50:            	RW_PIN = 0; // Reset the control lines
3CC6  9490     BCF LATH, 2, ACCESS
51:            #endif
52:            	return(data & 0x7f); // Return the address, Mask off the busy bit
3CC8  0E7F     MOVLW 0x7F
3CCA  1401     ANDWF [0x1], W, ACCESS
53:            }
3CCC  E942     SUBFSR 1, 0x2
3CCE  CFE7     MOVFF INDF1, FSR2
3CD0  FFD9     NOP
3CD2  0012     RETURN 0
54:            
---  /sdd/work/mx320/pyro/p18pyro.X/xlcd/putsxlcd.c  ----------------------------------------------------
1:             #include <p18cxxx.h>
2:             #include "xlcd.h"
3:             
4:             /********************************************************************
5:              *       Function Name:  putsXLCD
6:              *       Return Value:   void
7:              *       Parameters:     buffer: pointer to string
8:              *       Description:    This routine writes a string of bytes to the
9:              *                       Hitachi HD44780 LCD controller. The user
10:             *                       must check to see if the LCD controller is
11:             *                       busy before calling this routine. The data
12:             *                       is written to the character generator RAM or
13:             *                       the display data RAM depending on what the
14:             *                       previous SetxxRamAddr routine was called.
15:             ********************************************************************/
16:            void putsXLCD(char *buffer)
3E0E  CFD9     MOVFF FSR2, POSTINC1
3E10  FFE6     NOP
3E12  CFE1     MOVFF FSR1, FSR2
3E14  FFD9     NOP
3E16  E983     SUBFSR 2, 0x3
17:            {
18:            	while (*buffer) // Write data to LCD up to null
3E18  EB00     MOVSF 0x0, 0xFE9
3E1A  FFE9     NOP
3E1C  EB01     MOVSF 0x1, 0xFEA
3E1E  FFEA     NOP
3E20  50EF     MOVF INDF0, W, ACCESS
3E22  E00D     BZ 0x3E3E
3E3C  D7ED     BRA 0x3E18
19:            	{
20:            		S_WriteDataXLCD(*buffer); // Write character to LCD buffer
3E24  EB00     MOVSF 0x0, 0xFE9
3E26  FFE9     NOP
3E28  EB01     MOVSF 0x1, 0xFEA
3E2A  FFEA     NOP
3E2C  CFEF     MOVFF INDF0, POSTINC1
3E2E  FFE6     NOP
3E30  EC84     CALL 0x3708, 0
3E32  F01B     NOP
3E34  E941     SUBFSR 1, 0x1
21:            		buffer++; // Increment buffer
3E36  2A00     INCF [0x0], F, ACCESS
3E38  0E00     MOVLW 0x0
3E3A  2201     ADDWFC [0x1], F, ACCESS
22:            	}
23:            	return;
24:            }
3E3E  E941     SUBFSR 1, 0x1
3E40  CFE7     MOVFF INDF1, FSR2
3E42  FFD9     NOP
3E44  0012     RETURN 0
25:            
---  /sdd/work/mx320/pyro/p18pyro.X/xlcd/putrxlcd.c  ----------------------------------------------------
1:             #include <p18cxxx.h>
2:             #include "xlcd.h"
3:             
4:             /********************************************************************
5:              *       Function Name:  putrsXLCD
6:              *       Return Value:   void
7:              *       Parameters:     buffer: pointer to string
8:              *       Description:    This routine writes a string of bytes to the
9:              *                       Hitachi HD44780 LCD controller. The user
10:             *                       must check to see if the LCD controller is
11:             *                       busy before calling this routine. The data
12:             *                       is written to the character generator RAM or
13:             *                       the display data RAM depending on what the
14:             *                       previous SetxxRamAddr routine was called.
15:             ********************************************************************/
16:            void putrsXLCD(const rom char *buffer)
3C06  CFD9     MOVFF FSR2, POSTINC1
3C08  FFE6     NOP
3C0A  CFE1     MOVFF FSR1, FSR2
3C0C  FFD9     NOP
3C0E  E984     SUBFSR 2, 0x4
17:            {
18:            	while (*buffer) // Write data to LCD up to null
3C10  D815     RCALL __pa_0
3C12  50F5     MOVF TABLAT, W, ACCESS
3C14  E00F     BZ 0x3C34
3C32  D7EE     BRA 0x3C10
3C3C  EB00     MOVSF 0x0, 0xFF6
3C3E  FFF6     NOP
3C40  EB01     MOVSF 0x1, 0xFF7
3C42  FFF7     NOP
3C44  EB02     MOVSF 0x2, 0xFF8
3C46  FFF8     NOP
3C48  0008     TBLRD*
3C4A  0012     RETURN 0
19:            	{
20:            		S_WriteDataXLCD(*buffer); // Write character to LCD buffer
3C16  D812     RCALL __pa_0
3C18  CFF5     MOVFF TABLAT, POSTINC1
3C1A  FFE6     NOP
3C1C  EC84     CALL 0x3708, 0
3C1E  F01B     NOP
3C20  E941     SUBFSR 1, 0x1
21:            		buffer++; // Increment buffer
3C22  CFD9     MOVFF FSR2, FSR0
3C24  FFE9     NOP
3C26  CFDA     MOVFF FSR2H, FSR0H
3C28  FFEA     NOP
3C2A  2AEE     INCF POSTINC0, F, ACCESS
3C2C  0E00     MOVLW 0x0
3C2E  22EE     ADDWFC POSTINC0, F, ACCESS
3C30  22EE     ADDWFC POSTINC0, F, ACCESS
22:            	}
23:            	return;
24:            }
3C34  E941     SUBFSR 1, 0x1
3C36  CFE7     MOVFF INDF1, FSR2
3C38  FFD9     NOP
3C3A  0012     RETURN 0
25:            
---  /sdd/work/mx320/pyro/p18pyro.X/xlcd/openxlcd.c  ----------------------------------------------------
1:             #include <p18cxxx.h>
2:             #include "delays.h"
3:             #include "xlcd.h"
4:             
5:             /********************************************************************
6:              *       Function Name:  OpenXLCD                                    *
7:              *       Return Value:   void                                        *
8:              *       Parameters:     lcdtype: sets the type of LCD (lines)       *
9:              *       Description:    This routine configures the LCD. Based on   *
10:             *                       the Hitachi HD44780 LCD controller. The     *
11:             *                       routine will configure the I/O pins of the  *
12:             *                       microcontroller, setup the LCD for 4- or    *
13:             *                       8-bit mode and clear the display. The user  *
14:             *                       must provide three delay routines:          *
15:             *                       DelayFor18TCY() provides a 18 Tcy delay     *
16:             *                       DelayPORXLCD() provides at least 15ms delay *
17:             *                       DelayXLCD() provides at least 5ms delay     *
18:             ********************************************************************/
19:            void OpenXLCD(unsigned char lcdtype)
366E  CFD9     MOVFF FSR2, POSTINC1
3670  FFE6     NOP
3672  CFE1     MOVFF FSR1, FSR2
3674  FFD9     NOP
3676  E982     SUBFSR 2, 0x2
20:            {
21:            	// The data bits must be either a 8-bit port or the upper or
22:            	// lower 4-bits of a port. These pins are made into inputs
23:            #ifdef BIT8                             // 8-bit mode, use whole port
24:            	DATA_PORT = 0;
25:            	TRIS_DATA_PORT = 0x00;
26:            #else                                   // 4-bit mode
27:            #ifdef UPPER                            // Upper 4-bits of the port
28:            	DATA_PORT &= 0x0f;
3678  0E0F     MOVLW 0xF
367A  1687     ANDWF PORTH, F, ACCESS
29:            	TRIS_DATA_PORT &= 0x0F;
367C  1699     ANDWF TRISH, F, ACCESS
30:            #else                                   // Lower 4-bits of the port
31:            	DATA_PORT &= 0xf0;
32:            	TRIS_DATA_PORT &= 0xF0;
33:            #endif
34:            #endif
35:            	TRIS_RW = 0; // All control signals made outputs
367E  9499     BCF TRISH, 2, ACCESS
36:            	TRIS_RS = 0;
3680  9299     BCF TRISH, 1, ACCESS
37:            	TRIS_E = 0;
3682  9699     BCF TRISH, 3, ACCESS
38:            	RW_PIN = 0; // R/W pin made low
3684  9490     BCF LATH, 2, ACCESS
39:            	RS_PIN = 0; // Register select pin made low
3686  9290     BCF LATH, 1, ACCESS
40:            	E_PIN = 0; // Clock pin made low
3688  9690     BCF LATH, 3, ACCESS
41:            
42:            	// Delay for 15ms to allow for LCD Power on reset
43:            	DelayPORXLCD();
368A  EC47     CALL 0x8E, 0
368C  F000     NOP
44:            	//-------------------reset procedure through software----------------------
45:            	WriteCmdXLCD(0x30);
368E  0E30     MOVLW 0x30
3690  D832     RCALL __pa_0
46:            	Delay10KTCYx(0x05);
3692  0E05     MOVLW 0x5
3694  6EE6     MOVWF POSTINC1, ACCESS
3696  EC23     CALL 0x3E46, 0
3698  F01F     NOP
369A  E941     SUBFSR 1, 0x1
47:            
48:            	WriteCmdXLCD(0x30);
369C  0E30     MOVLW 0x30
369E  D82B     RCALL __pa_0
49:            	Delay10KTCYx(0x01);
36A0  0E01     MOVLW 0x1
36A2  6EE6     MOVWF POSTINC1, ACCESS
36A4  EC23     CALL 0x3E46, 0
36A6  F01F     NOP
36A8  E941     SUBFSR 1, 0x1
50:            
51:            
52:            	WriteCmdXLCD(0x32);
36AA  0E32     MOVLW 0x32
36AC  D824     RCALL __pa_0
53:            	while (BusyXLCD());
36AE  D828     RCALL __pa_1
36B0  E1FE     BNZ 0x36AE
54:            	//------------------------------------------------------------------------------------------
55:            
56:            
57:            	// Set data interface width, # lines, font
58:            	while (BusyXLCD()); // Wait if LCD busy
36B2  D826     RCALL __pa_1
36B4  E1FE     BNZ 0x36B2
59:            	WriteCmdXLCD(lcdtype); // Function set cmd
36B6  EB00     MOVSF 0x0, 0xFE6
36B8  FFE6     NOP
36BA  ECF0     CALL 0x37E0, 0
36BC  F01B     NOP
36BE  E941     SUBFSR 1, 0x1
60:            
61:            	// Turn the display on then off
62:            	while (BusyXLCD()); // Wait if LCD busy
36C0  D81F     RCALL __pa_1
36C2  E1FE     BNZ 0x36C0
63:            	WriteCmdXLCD(DOFF & CURSOR_OFF & BLINK_OFF); // Display OFF/Blink OFF
36C4  0E08     MOVLW 0x8
36C6  D817     RCALL __pa_0
64:            	while (BusyXLCD()); // Wait if LCD busy
36C8  D81B     RCALL __pa_1
36CA  E1FE     BNZ 0x36C8
65:            	WriteCmdXLCD(DON & CURSOR_ON & BLINK_ON); // Display ON/Blink ON
36CC  0E0F     MOVLW 0xF
36CE  D813     RCALL __pa_0
66:            
67:            	// Clear display
68:            	while (BusyXLCD()); // Wait if LCD busy
36D0  D817     RCALL __pa_1
36D2  E1FE     BNZ 0x36D0
69:            	WriteCmdXLCD(0x01); // Clear display
36D4  0E01     MOVLW 0x1
36D6  D80F     RCALL __pa_0
70:            
71:            	// Set entry mode inc, no shift
72:            	while (BusyXLCD()); // Wait if LCD busy
36D8  D813     RCALL __pa_1
36DA  E1FE     BNZ 0x36D8
73:            	WriteCmdXLCD(SHIFT_CUR_LEFT); // Entry Mode
36DC  0E13     MOVLW 0x13
36DE  D80B     RCALL __pa_0
36F6  6EE6     MOVWF POSTINC1, ACCESS
36F8  ECF0     CALL 0x37E0, 0
36FA  F01B     NOP
36FC  E941     SUBFSR 1, 0x1
36FE  0012     RETURN 0
74:            
75:            	// Set DD Ram address to 0
76:            	while (BusyXLCD()); // Wait if LCD busy
36E0  D80F     RCALL __pa_1
36E2  E1FE     BNZ 0x36E0
3700  ECD2     CALL 0x3FA4, 0
3702  F01F     NOP
3704  0900     IORLW 0x0
3706  0012     RETURN 0
77:            	SetDDRamAddr(0x80); // Set Display data ram address to 0
36E4  0E80     MOVLW 0x80
36E6  6EE6     MOVWF POSTINC1, ACCESS
36E8  ECBD     CALL 0x3B7A, 0
36EA  F01D     NOP
36EC  E941     SUBFSR 1, 0x1
78:            
79:            	return;
80:            }
36EE  E941     SUBFSR 1, 0x1
36F0  CFE7     MOVFF INDF1, FSR2
36F2  FFD9     NOP
36F4  0012     RETURN 0
81:            
---  /sdd/work/mx320/pyro/p18pyro.X/xlcd/busyxlcd.c  ----------------------------------------------------
1:             #include <p18cxxx.h>
2:             #include "xlcd.h"
3:             
4:             /********************************************************************
5:              *       Function Name:  BusyXLCD                                    *
6:              *       Return Value:   char: busy status of LCD controller         *
7:              *       Parameters:     void                                        *
8:              *       Description:    This routine reads the busy status of the   *
9:              *                       Hitachi HD44780 LCD controller.             *
10:             ********************************************************************/
11:            unsigned char BusyXLCD(void)
12:            {
13:            	RW_PIN = 1; // Set the control bits for read
3FA4  8490     BSF LATH, 2, ACCESS
14:            	RS_PIN = 0;
3FA6  9290     BCF LATH, 1, ACCESS
15:            	DelayFor18TCY();
3FA8  EC3A     CALL 0x74, 0
3FAA  F000     NOP
16:            	E_PIN = 1; // Clock in the command
3FAC  8690     BSF LATH, 3, ACCESS
17:            	DelayFor18TCY();
3FAE  EC3A     CALL 0x74, 0
3FB0  F000     NOP
18:            #ifdef BIT8                             // 8-bit interface
19:            	if (DATA_PORT & 0x80) // Read bit 7 (busy bit)
20:            	{ // If high
21:            		E_PIN = 0; // Reset clock line
22:            		RW_PIN = 0; // Reset control line
23:            		return 1; // Return TRUE
24:            	} else // Bit 7 low
25:            	{
26:            		E_PIN = 0; // Reset clock line
27:            		RW_PIN = 0; // Reset control line
28:            		return 0; // Return FALSE
29:            	}
30:            #else                                   // 4-bit interface
31:            #ifdef UPPER                            // Upper nibble interface
32:            	if (DATA_PORT & 0x80)
3FB2  AE87     BTFSS PORTH, 7, ACCESS
3FB4  D002     BRA 0x3FBA
33:            #else                                   // Lower nibble interface
34:            	if (DATA_PORT & 0x08)
35:            #endif
36:            	{
37:            		E_PIN = 0; // Reset clock line
3FB6  D803     RCALL __pa_0
3FBE  9690     BCF LATH, 3, ACCESS
38:            		DelayFor18TCY();
3FC0  EC3A     CALL 0x74, 0
3FC2  F000     NOP
39:            		E_PIN = 1; // Clock out other nibble
3FC4  8690     BSF LATH, 3, ACCESS
40:            		DelayFor18TCY();
3FC6  EC3A     CALL 0x74, 0
3FC8  F000     NOP
41:            		E_PIN = 0;
3FCA  9690     BCF LATH, 3, ACCESS
42:            		RW_PIN = 0; // Reset control line
3FCC  9490     BCF LATH, 2, ACCESS
3FCE  0012     RETURN 0
43:            		return 1; // Return TRUE
3FB8  0C01     RETLW 0x1
44:            	} else // Busy bit is low
45:            	{
46:            		E_PIN = 0; // Reset clock line
3FBA  D801     RCALL __pa_0
47:            		DelayFor18TCY();
48:            		E_PIN = 1; // Clock out other nibble
49:            		DelayFor18TCY();
50:            		E_PIN = 0;
51:            		RW_PIN = 0; // Reset control line
52:            		return 0; // Return FALSE
53:            	}
54:            #endif
55:            }
3FBC  0C00     RETLW 0x0
56:            
---  /sdd/work/mx320/pyro/p18pyro.X/valve.c  ------------------------------------------------------------
1:             #include "valve.h"
2:             
3:             struct valvetype valves;
4:             
5:             void valve_config(void)
6:             {
7:             	valves.buf.ld = 0;
345A  0102     MOVLB 0x2
345C  6BE7     CLRF 0xE7, BANKED
345E  6BE8     CLRF curr_entry, BANKED
8:             	valve_set(&valves);
3460  EF8D     GOTO 0x351A
3462  F01A     NOP
351A  0EE7     MOVLW 0xE7
351C  6EE6     MOVWF POSTINC1, ACCESS
351E  0E02     MOVLW 0x2
3520  6EE6     MOVWF POSTINC1, ACCESS
3522  DFA1     RCALL valve_set
3524  E942     SUBFSR 1, 0x2
3526  0012     RETURN 0
9:             }
10:            
11:            int8_t valve_interlock(void)
12:            {
13:            	return 0;
14:            }
3464  0C00     RETLW 0x0
15:            
16:            int8_t valve_set(struct valvetype * valves)
3466  CFD9     MOVFF FSR2, POSTINC1
3468  FFE6     NOP
346A  CFE1     MOVFF FSR1, FSR2
346C  FFD9     NOP
346E  E983     SUBFSR 2, 0x3
17:            {
18:            	if (SPI_Daq_Update(valves->buf.bd[0], SHIFT_565_0_7, 0))
3470  6AE6     CLRF POSTINC1, ACCESS
3472  0E02     MOVLW 0x2
3474  6EE6     MOVWF POSTINC1, ACCESS
3476  EB00     MOVSF 0x0, 0xFE9
3478  FFE9     NOP
347A  EB01     MOVSF 0x1, 0xFEA
347C  FFEA     NOP
347E  D854     RCALL __pa_1
3480  0900     IORLW 0x0
3482  E002     BZ 0x3488
3528  50EF     MOVF INDF0, W, ACCESS
352A  6EE6     MOVWF POSTINC1, ACCESS
352C  6AE6     CLRF POSTINC1, ACCESS
352E  EC40     CALL 0x3080, 0
3530  F018     NOP
3532  E944     SUBFSR 1, 0x4
3534  0012     RETURN 0
19:            		return -1;
3484  0EFF     MOVLW 0xFF
3486  D00B     BRA 0x349E
20:            	return SPI_Daq_Update(valves->buf.bd[1], SHIFT_565_8_15, 0);
3488  6AE6     CLRF POSTINC1, ACCESS
348A  0E03     MOVLW 0x3
348C  6EE6     MOVWF POSTINC1, ACCESS
348E  EB00     MOVSF 0x0, 0xFE9
3490  FFE9     NOP
3492  EB01     MOVSF 0x1, 0xFEA
3494  FFEA     NOP
3496  2AE9     INCF FSR0, F, ACCESS
3498  0E00     MOVLW 0x0
349A  22EA     ADDWFC FSR0H, F, ACCESS
349C  D845     RCALL __pa_1
21:            }
349E  E941     SUBFSR 1, 0x1
34A0  CFE7     MOVFF INDF1, FSR2
34A2  FFD9     NOP
34A4  0012     RETURN 0
22:            
23:            int8_t valve_switch(enum valve_t valve, uint8_t state)
34A6  CFD9     MOVFF FSR2, POSTINC1
34A8  FFE6     NOP
34AA  CFE1     MOVFF FSR1, FSR2
34AC  FFD9     NOP
34AE  E983     SUBFSR 2, 0x3
24:            {
25:            	if (state)
34B0  5000     MOVF [0x0], W, ACCESS
34B2  E017     BZ 0x34E2
26:            		valves.buf.ld |= 0x0001 << valve;
34B4  0E01     MOVLW 0x1
34B6  EB01     MOVSF 0x1, 0xFF3
34B8  FFF3     NOP
34BA  5201     MOVF [0x1], F, ACCESS
34BC  E004     BZ 0x34C6
34BE  90D8     BCF STATUS, 0, ACCESS
34C0  36E8     RLCF WREG, F, ACCESS
34C2  06F3     DECF PROD, F, ACCESS
34C4  E1FC     BNZ 0x34BE
34C6  0101     MOVLB 0x1
34C8  6FF1     MOVWF spi_buf, BANKED
34CA  6BF2     CLRF 0xF2, BANKED
34CC  0B80     ANDLW 0x80
34CE  E001     BZ 0x34D2
34D0  69F2     SETF 0xF2, BANKED
34D2  51F1     MOVF spi_buf, W, BANKED
34D4  0102     MOVLB 0x2
34D6  13E7     IORWF 0xE7, F, BANKED
34D8  0101     MOVLB 0x1
34DA  51F2     MOVF 0xF2, W, BANKED
34DC  0102     MOVLB 0x2
34DE  13E8     IORWF curr_entry, F, BANKED
27:            	else
34E0  D017     BRA 0x3510
28:            		valves.buf.ld &= ~(0x0001 << valve);
34E2  0E01     MOVLW 0x1
34E4  EB01     MOVSF 0x1, 0xFF3
34E6  FFF3     NOP
34E8  5201     MOVF [0x1], F, ACCESS
34EA  E004     BZ 0x34F4
34EC  90D8     BCF STATUS, 0, ACCESS
34EE  36E8     RLCF WREG, F, ACCESS
34F0  06F3     DECF PROD, F, ACCESS
34F2  E1FC     BNZ 0x34EC
34F4  1CE8     COMF WREG, W, ACCESS
34F6  0101     MOVLB 0x1
34F8  6FF1     MOVWF spi_buf, BANKED
34FA  6BF2     CLRF 0xF2, BANKED
34FC  0B80     ANDLW 0x80
34FE  E001     BZ 0x3502
3500  69F2     SETF 0xF2, BANKED
3502  51F1     MOVF spi_buf, W, BANKED
3504  0102     MOVLB 0x2
3506  17E7     ANDWF 0xE7, F, BANKED
3508  0101     MOVLB 0x1
350A  51F2     MOVF 0xF2, W, BANKED
350C  0102     MOVLB 0x2
350E  17E8     ANDWF curr_entry, F, BANKED
29:            	
30:            	return valve_set(&valves);
3510  D804     RCALL __pa_0
31:            }
3512  E941     SUBFSR 1, 0x1
3514  CFE7     MOVFF INDF1, FSR2
3516  FFD9     NOP
3518  0012     RETURN 0
---  /sdd/work/mx320/pyro/p18pyro.X/ringbufs.c  ---------------------------------------------------------
1:             #include  <string.h>
2:             #include  "ringbufs.h"
3:             
4:             /*
5:              * general ring buffer fuctions from the internet
6:              */
7:             uint8_t modulo_inc(const uint8_t value, const uint8_t modulus)
2BFE  D8AC     RCALL __pa_1
2C00  E841     ADDFSR 1, 0x1
8:             {
9:             	uint8_t my_value = value + 1;
2C02  2801     INCF [0x1], W, ACCESS
2C04  6E03     MOVWF [0x3], ACCESS
10:            	if (my_value >= modulus) {
2C06  5000     MOVF [0x0], W, ACCESS
2C08  5C03     SUBWF [0x3], W, ACCESS
2C0A  E301     BNC 0x2C0E
11:            		my_value = 0;
2C0C  6A03     CLRF [0x3], ACCESS
12:            	}
13:            	return my_value;
2C0E  5003     MOVF [0x3], W, ACCESS
14:            }
2C10  E942     SUBFSR 1, 0x2
2C12  CFE7     MOVFF INDF1, FSR2
2C14  FFD9     NOP
2C16  0012     RETURN 0
15:            
16:            uint8_t modulo_dec(const uint8_t value, const uint8_t modulus)
2C18  D89F     RCALL __pa_1
2C1A  E841     ADDFSR 1, 0x1
2D58  D83A     RCALL __pa_13
2D5A  E983     SUBFSR 2, 0x3
2D5C  0012     RETURN 0
2DCE  CFD9     MOVFF FSR2, POSTINC1
2DD0  FFE6     NOP
2DD2  CFE1     MOVFF FSR1, FSR2
2DD4  FFD9     NOP
2DD6  0012     RETURN 0
17:            {
18:            	uint8_t my_value = (0 == value) ? (modulus - 1) : (value - 1);
2C1C  5001     MOVF [0x1], W, ACCESS
2C1E  E102     BNZ 0x2C24
2C20  0400     DECF [0x0], W, ACCESS
2C22  D001     BRA 0x2C26
2C24  0401     DECF [0x1], W, ACCESS
2C26  6E03     MOVWF [0x3], ACCESS
19:            	return my_value;
2C28  5003     MOVF [0x3], W, ACCESS
20:            }
2C2A  E942     SUBFSR 1, 0x2
2C2C  CFE7     MOVFF INDF1, FSR2
2C2E  FFD9     NOP
2C30  0012     RETURN 0
21:            
22:            void ringBufS_init(ringBufS_t *_this)
2C32  D892     RCALL __pa_1
23:            {
24:            	/*****
25:            	  The following clears:
26:            	    -> buf
27:            	    -> head
28:            	    -> tail
29:            	    -> count
30:            	  and sets head = tail
31:            	 ***/
32:            	memset(_this, 0, sizeof(*_this));
2C34  0E83     MOVLW 0x83
2C36  6EE6     MOVWF POSTINC1, ACCESS
2C38  6AE6     CLRF POSTINC1, ACCESS
2C3A  6AE6     CLRF POSTINC1, ACCESS
2C3C  EB00     MOVSF 0x0, 0xFE6
2C3E  FFE6     NOP
2C40  EB01     MOVSF 0x1, 0xFE6
2C42  FFE6     NOP
2C44  ECEA     CALL 0x35D4, 0
2C46  F01A     NOP
2C48  E945     SUBFSR 1, 0x5
33:            }
2C4A  D08F     BRA __pa_4
34:            
35:            int8_t ringBufS_empty(ringBufS_t *_this)
2C4C  D885     RCALL __pa_1
36:            {
37:            	return(0 == _this->count);
2C4E  D881     RCALL __pa_0
2C50  50EF     MOVF INDF0, W, ACCESS
2C52  E002     BZ 0x2C58
2C54  0E00     MOVLW 0x0
2C56  D001     BRA 0x2C5A
2C58  0E01     MOVLW 0x1
38:            }
2C5A  D087     BRA __pa_4
39:            
40:            int8_t ringBufS_full(ringBufS_t *_this)
2C5C  D87D     RCALL __pa_1
41:            {
42:            	return(_this->count >= RBUF_SIZE);
2C5E  D879     RCALL __pa_0
2C60  D89B     RCALL __pa_8
2C62  E702     BNN 0x2C68
2C64  34E7     RLCF INDF1, W, ACCESS
2C66  D002     BRA 0x2C6C
2C68  50E7     MOVF INDF1, W, ACCESS
2C6A  5DF1     SUBWF spi_buf, W, BANKED
2C6C  E202     BC 0x2C72
2C6E  0E00     MOVLW 0x0
2C70  D001     BRA 0x2C74
2C72  0E01     MOVLW 0x1
2D98  CFEF     MOVFF INDF0, __tmp_0
2D9A  F1F1     NOP
2D9C  0E40     MOVLW 0x40
2D9E  0101     MOVLB 0x1
2DA0  6EE7     MOVWF INDF1, ACCESS
2DA2  19F1     XORWF spi_buf, W, BANKED
2DA4  0012     RETURN 0
43:            }
2C74  D07A     BRA __pa_4
44:            
45:            uint16_t ringBufS_get(ringBufS_t *_this)
2C76  D870     RCALL __pa_1
2C78  E842     ADDFSR 1, 0x2
46:            {
47:            	uint16_t c;
48:            	if (_this->count > 0) {
2C7A  D86B     RCALL __pa_0
2C7C  CFEF     MOVFF INDF0, __tmp_0
2C7E  F1F1     NOP
2C80  0101     MOVLB 0x1
2C82  6EE7     MOVWF INDF1, ACCESS
2C84  19F1     XORWF spi_buf, W, BANKED
2C86  E702     BNN 0x2C8C
2C88  35F1     RLCF spi_buf, W, BANKED
2C8A  D002     BRA 0x2C90
2C8C  51F1     MOVF spi_buf, W, BANKED
2C8E  5CE7     SUBWF INDF1, W, ACCESS
2C90  E218     BC 0x2CC2
49:            		c = _this->buf[_this->tail];
2C92  D898     RCALL __pa_12
2C94  D88E     RCALL __pa_10
2C96  D863     RCALL __pa_2
2C98  CFEF     MOVFF INDF0, 0x1F3
2C9A  F1F3     NOP
2C9C  6BF4     CLRF spi_buf, BANKED
2C9E  BFF3     BTFSC data, 7, BANKED
2CA0  69F4     SETF spi_buf, BANKED
2CA2  D867     RCALL __pa_5
2CA4  50EE     MOVF POSTINC0, W, ACCESS
2CA6  6E03     MOVWF [0x3], ACCESS
2CA8  50ED     MOVF POSTDEC0, W, ACCESS
2CAA  6E04     MOVWF [0x4], ACCESS
2D72  90D8     BCF STATUS, 0, ACCESS
2D74  37F3     RLCF data, F, BANKED
2D76  37F4     RLCF spi_buf, F, BANKED
2D78  51F1     MOVF spi_buf, W, BANKED
2D7A  25F3     ADDWF data, W, BANKED
2D7C  6EE9     MOVWF FSR0, ACCESS
2D7E  51F2     MOVF 0xF2, W, BANKED
2D80  21F4     ADDWFC spi_buf, W, BANKED
2D82  6EEA     MOVWF FSR0H, ACCESS
2D84  0012     RETURN 0
50:            		_this->tail = modulo_inc(_this->tail, RBUF_SIZE);
2CAC  0E40     MOVLW 0x40
2CAE  6EE6     MOVWF POSTINC1, ACCESS
2CB0  D856     RCALL __pa_2
2CB2  D879     RCALL __pa_9
2CB4  D854     RCALL __pa_2
2CB6  52E5     MOVF POSTDEC1, F, ACCESS
2CB8  50E7     MOVF INDF1, W, ACCESS
2CBA  6EEF     MOVWF INDF0, ACCESS
2D5E  D832     RCALL __pa_12
2D60  0E81     MOVLW 0x81
2D62  D02C     BRA __pa_11
2DA6  CFEF     MOVFF INDF0, POSTINC1
2DA8  FFE6     NOP
2DAA  DF29     RCALL modulo_inc
2DAC  E942     SUBFSR 1, 0x2
2DAE  6EE6     MOVWF POSTINC1, ACCESS
2DB0  0012     RETURN 0
2DC4  EB00     MOVSF 0x0, 0xFE9
2DC6  FFE9     NOP
2DC8  EB01     MOVSF 0x1, 0xFEA
2DCA  FFEA     NOP
2DCC  0012     RETURN 0
51:            		--_this->count;
2CBC  D84A     RCALL __pa_0
2CBE  06EF     DECF INDF0, F, ACCESS
2D52  D838     RCALL __pa_12
2D54  0E82     MOVLW 0x82
2D56  D032     BRA __pa_11
52:            	} else {
2CC0  D002     BRA 0x2CC6
53:            		c = 0; // return null with empty buffer
2CC2  6A03     CLRF [0x3], ACCESS
2CC4  6A04     CLRF [0x4], ACCESS
54:            	}
55:            	return(c);
2CC6  EB03     MOVSF 0x3, 0xFF3
2CC8  FFF3     NOP
2CCA  EB04     MOVSF 0x4, 0xFF4
2CCC  FFF4     NOP
56:            }
2CCE  E943     SUBFSR 1, 0x3
2CD0  CFE7     MOVFF INDF1, FSR2
2CD2  FFD9     NOP
2CD4  0012     RETURN 0
57:            
58:            void ringBufS_put(ringBufS_t *_this, const uint16_t c)
2CD6  D87B     RCALL __pa_13
2CD8  E985     SUBFSR 2, 0x5
59:            {
60:            	if (_this->count < RBUF_SIZE) {
2CDA  D855     RCALL __pa_6
2CDC  D85D     RCALL __pa_8
2CDE  E702     BNN 0x2CE4
2CE0  34E7     RLCF INDF1, W, ACCESS
2CE2  D002     BRA 0x2CE8
2CE4  50E7     MOVF INDF1, W, ACCESS
2CE6  5DF1     SUBWF spi_buf, W, BANKED
2CE8  E217     BC 0x2D18
2D86  D828     RCALL __pa_14
2D88  0E82     MOVLW 0x82
2D8A  D018     BRA __pa_11
2DBC  26E9     ADDWF FSR0, F, ACCESS
2DBE  0E00     MOVLW 0x0
2DC0  22EA     ADDWFC FSR0H, F, ACCESS
2DC2  0012     RETURN 0
2DD8  EB02     MOVSF 0x2, 0xFE9
2DDA  FFE9     NOP
2DDC  EB03     MOVSF 0x3, 0xFEA
2DDE  FFEA     NOP
2DE0  0012     RETURN 0
61:            		_this->buf[_this->head] = c;
2CEA  D876     RCALL __pa_14
2CEC  D862     RCALL __pa_10
2CEE  D83A     RCALL __pa_3
2CF0  CFEF     MOVFF INDF0, 0x1F3
2CF2  F1F3     NOP
2CF4  6BF4     CLRF spi_buf, BANKED
2CF6  BFF3     BTFSC data, 7, BANKED
2CF8  69F4     SETF spi_buf, BANKED
2CFA  D83B     RCALL __pa_5
2CFC  EB00     MOVSF 0x0, 0xFEE
2CFE  FFEE     NOP
2D00  EB01     MOVSF 0x1, 0xFED
2D02  FFED     NOP
62:            		_this->head = modulo_inc(_this->head, RBUF_SIZE);
2D04  0E40     MOVLW 0x40
2D06  6EE6     MOVWF POSTINC1, ACCESS
2D08  D82D     RCALL __pa_3
2D0A  D84D     RCALL __pa_9
2D0C  D82B     RCALL __pa_3
2D0E  52E5     MOVF POSTDEC1, F, ACCESS
2D10  50E7     MOVF INDF1, W, ACCESS
2D12  6EEF     MOVWF INDF0, ACCESS
2D64  D839     RCALL __pa_14
2D66  0E80     MOVLW 0x80
2D68  D029     BRA __pa_11
63:            		++_this->count;
2D14  D838     RCALL __pa_6
2D16  2AEF     INCF INDF0, F, ACCESS
64:            	}
65:            }
2D18  D028     BRA __pa_4
66:            
67:            void ringBufS_flush(ringBufS_t *_this, const int8_t clearBuffer)
2D1A  D859     RCALL __pa_13
2D1C  E984     SUBFSR 2, 0x4
68:            {
69:            	_this->count = 0;
2D1E  D861     RCALL __pa_15
2D20  0E82     MOVLW 0x82
2D22  D834     RCALL __pa_7
2D8C  26E9     ADDWF FSR0, F, ACCESS
2D8E  0E00     MOVLW 0x0
2D90  22EA     ADDWFC FSR0H, F, ACCESS
2D92  6AEF     CLRF INDF0, ACCESS
70:            	_this->head = 0;
2D24  0E80     MOVLW 0x80
2D26  D832     RCALL __pa_7
2D94  EFF1     GOTO 0x2DE2
2D96  F016     NOP
2DE2  EB01     MOVSF 0x1, 0xFE9
2DE4  FFE9     NOP
2DE6  EB02     MOVSF 0x2, 0xFEA
2DE8  FFEA     NOP
2DEA  0012     RETURN 0
71:            	_this->tail = 0;
2D28  0E81     MOVLW 0x81
2D2A  26E9     ADDWF FSR0, F, ACCESS
2D2C  0E00     MOVLW 0x0
2D2E  22EA     ADDWFC FSR0H, F, ACCESS
2D30  6AEF     CLRF INDF0, ACCESS
72:            	if (clearBuffer) {
2D32  5000     MOVF [0x0], W, ACCESS
2D34  E00D     BZ 0x2D50
73:            		memset(_this->buf, 0, sizeof(_this->buf));
2D36  0E80     MOVLW 0x80
2D38  6EE6     MOVWF POSTINC1, ACCESS
2D3A  6AE6     CLRF POSTINC1, ACCESS
2D3C  6AE6     CLRF POSTINC1, ACCESS
2D3E  D851     RCALL __pa_15
2D40  D838     RCALL __pa_10
2D42  CFE9     MOVFF FSR0, POSTINC1
2D44  FFE6     NOP
2D46  CFEA     MOVFF FSR0H, POSTINC1
2D48  FFE6     NOP
2D4A  ECEA     CALL 0x35D4, 0
2D4C  F01A     NOP
2D4E  E945     SUBFSR 1, 0x5
2DB2  CFE9     MOVFF FSR0, __tmp_0
2DB4  F1F1     NOP
2DB6  CFEA     MOVFF FSR0H, 0x1F2
2DB8  F1F2     NOP
2DBA  0012     RETURN 0
74:            	}
75:            }
2D50  D00C     BRA __pa_4
2D6A  E941     SUBFSR 1, 0x1
2D6C  CFE7     MOVFF INDF1, FSR2
2D6E  FFD9     NOP
2D70  0012     RETURN 0
76:            
---  /sdd/work/mx320/pyro/p18pyro.X/pyro_vector.c  ------------------------------------------------------
1:             /* High and Low ISR codes, some glue routines */
2:             #include "pyro_vector.h"
3:             #include "mfc.h"
4:             
5:             #pragma interrupt tick_handler
6:             
7:             void tick_handler(void) // This is the high priority ISR routine
1150  CFDA     MOVFF FSR2H, PREINC1
1152  FFE4     NOP
1154  CFE2     MOVFF FSR1H, FSR2H
1156  FFDA     NOP
1158  CFE9     MOVFF FSR0, PREINC1
115A  FFE4     NOP
115C  CFEA     MOVFF FSR0H, PREINC1
115E  FFE4     NOP
1160  C0FA     MOVFF 0xFA, PREINC1
1162  FFE4     NOP
1164  C0FB     MOVFF 0xFB, PREINC1
1166  FFE4     NOP
1168  C0FC     MOVFF 0xFC, PREINC1
116A  FFE4     NOP
116C  C0FD     MOVFF 0xFD, PREINC1
116E  FFE4     NOP
1170  CFF6     MOVFF TBLPTR, PREINC1
1172  FFE4     NOP
1174  CFF7     MOVFF TBLPTRH, PREINC1
1176  FFE4     NOP
1178  CFF8     MOVFF TBLPTRU, PREINC1
117A  FFE4     NOP
117C  CFF5     MOVFF TABLAT, PREINC1
117E  FFE4     NOP
1180  CFF3     MOVFF PROD, PREINC1
1182  FFE4     NOP
1184  CFF4     MOVFF PRODH, PREINC1
1186  FFE4     NOP
1188  CFFA     MOVFF PCLATH, PREINC1
118A  FFE4     NOP
118C  CFFB     MOVFF PCLATU, PREINC1
118E  FFE4     NOP
1190  EE01     LFSR 0, 0x1F1
1192  F0F1     NOP
1194  0E0F     MOVLW 0xF
1196  04E8     DECF WREG, W, ACCESS
1198  E303     BNC 0x11A0
119A  CFEE     MOVFF POSTINC0, PREINC1
119C  FFE4     NOP
119E  D7FB     BRA 0x1196
11A0  52E6     MOVF POSTINC1, F, ACCESS
11A2  CFD9     MOVFF FSR2, POSTINC1
11A4  FFE6     NOP
11A6  CFE1     MOVFF FSR1, FSR2
11A8  FFD9     NOP
11AA  E981     SUBFSR 2, 0x1
11AC  E842     ADDFSR 1, 0x2
8:             {
9:             	static uint8_t adc_trigger = FALSE, HID_IDLE_FLAG = TRUE, b_read = 0;
10:            	union Timers timer;
11:            	static union adc_buf_type adc_buf;
12:            	static union lcd_buf_type lcd_buf;
13:            	static union spi_buf_type spi_buf;
14:            	static int8_t data, slow = 0;
15:            
16:            	DLED_0 = HIGH;
11AE  8091     BSF LATJ, 0, ACCESS
17:            	V.highint_count++; // high int counter
11B0  0105     MOVLB 0x5
11B2  2B2A     INCF 0x2A, F, BANKED
11B4  0E00     MOVLW 0x0
11B6  232B     ADDWFC 0x2B, F, BANKED
11B8  232C     ADDWFC 0x2C, F, BANKED
11BA  232D     ADDWFC 0x2D, F, BANKED
18:            
19:            	if (PIE1bits.ADIE && PIR1bits.ADIF) { // ADC conversion complete flag
11BC  509D     MOVF PIE1, W, ACCESS
11BE  0B40     ANDLW 0x40
11C0  E035     BZ 0x122C
11C2  509E     MOVF PIR1, W, ACCESS
11C4  0B40     ANDLW 0x40
11C6  E032     BZ 0x122C
20:            		DLED_5 = LOW;
11C8  9A91     BCF LATJ, 5, ACCESS
21:            		V.adc_count++; // just keep count
11CA  0105     MOVLB 0x5
11CC  2B5E     INCF 0x5E, F, BANKED
11CE  0E00     MOVLW 0x0
11D0  235F     ADDWFC 0x5F, F, BANKED
11D2  2360     ADDWFC ring_buf1, F, BANKED
11D4  2361     ADDWFC 0x61, F, BANKED
22:            		PIR1bits.ADIF = LOW;
11D6  9C9E     BCF PIR1, 6, ACCESS
23:            		adc_buf.buf = ADRES;
11D8  CFC3     MOVFF ADRES, adc_buf
11DA  F0ED     NOP
11DC  CFC4     MOVFF ADRESH, 0xEE
11DE  F0EE     NOP
24:            		adc_buf.map.index = L.adc_chan; // add channel data to the 16 bit variable
11E0  0104     MOVLB 0x4
11E2  5101     MOVF adc_val, W, BANKED
11E4  0100     MOVLB 0x0
11E6  0B07     ANDLW 0x7
11E8  6EF3     MOVWF PROD, ACCESS
11EA  46F3     RLNCF PROD, F, ACCESS
11EC  46F3     RLNCF PROD, F, ACCESS
11EE  46F3     RLNCF PROD, F, ACCESS
11F0  46F3     RLNCF PROD, F, ACCESS
11F2  46F3     RLNCF PROD, F, ACCESS
11F4  0E1F     MOVLW 0x1F
11F6  15EE     ANDWF 0xEE, W, BANKED
11F8  10F3     IORWF PROD, W, ACCESS
11FA  6FEE     MOVWF 0xEE, BANKED
25:            		ringBufS_put(L.rx1b, adc_buf.buf);
11FC  C0ED     MOVFF adc_buf, POSTINC1
11FE  FFE6     NOP
1200  C0EE     MOVFF 0xEE, POSTINC1
1202  FFE6     NOP
1204  C433     MOVFF 0x433, POSTINC1
1206  FFE6     NOP
1208  C434     MOVFF 0x434, POSTINC1
120A  FFE6     NOP
120C  EC6B     CALL 0x2CD6, 0
120E  F016     NOP
1210  E944     SUBFSR 1, 0x4
26:            		if (!(L.adc_chan & ADC_CHAN_MASK)) {
1212  0104     MOVLB 0x4
1214  5101     MOVF adc_val, W, BANKED
1216  0B07     ANDLW 0x7
1218  E102     BNZ 0x121E
27:            			DLED_3 = HIGH; // pulse high on ADC channel zero
121A  8691     BSF LATJ, 3, ACCESS
28:            		} else {
121C  D001     BRA 0x1220
29:            			DLED_3 = LOW;
121E  9691     BCF LATJ, 3, ACCESS
30:            		}
31:            		L.adc_chan++; // next ADC channel
1220  0104     MOVLB 0x4
1222  2B01     INCF adc_val, F, BANKED
1224  0E00     MOVLW 0x0
1226  2302     ADDWFC addr, F, BANKED
32:            		adc_trigger = FALSE; // reset the skip flag
1228  0102     MOVLB 0x2
122A  6BE3     CLRF prom, BANKED
33:            	}
34:            
35:            	/*
36:            	 * several khz state machine sequencer timer
37:            	 */
38:            	if (PIE3bits.TMR4IE && PIR3bits.TMR4IF) {
122C  50A3     MOVF PIE3, W, ACCESS
122E  0B08     ANDLW 0x8
1230  E101     BNZ 0x1234
1232  D169     BRA 0x1506
1234  50A4     MOVF PIR3, W, ACCESS
1236  0B08     ANDLW 0x8
1238  E101     BNZ 0x123C
123A  D165     BRA 0x1506
39:            
40:            		PIR3bits.TMR4IF = LOW;
123C  96A4     BCF PIR3, 3, ACCESS
41:            		PR4 = TIMER4_NORM;
123E  0E07     MOVLW 0x7
1240  6E77     MOVWF PR4, ACCESS
42:            		V.pwm4int_count++;
1242  0105     MOVLB 0x5
1244  2B3A     INCF 0x3A, F, BANKED
1246  0E00     MOVLW 0x0
1248  233B     ADDWFC 0x3B, F, BANKED
124A  233C     ADDWFC 0x3C, F, BANKED
124C  233D     ADDWFC 0x3D, F, BANKED
43:            
44:            		/*
45:            		 *  scan ADC channels
46:            		 */
47:            		if (!ADCON0bits.GO) {
124E  B2C2     BTFSC ADCON0, 1, ACCESS
1250  D012     BRA 0x1276
48:            			ADCON0bits.CHS = L.adc_chan & ADC_CHAN_MASK; // set the current channel
1252  0E07     MOVLW 0x7
1254  0104     MOVLB 0x4
1256  1501     ANDWF adc_val, W, BANKED
1258  0B0F     ANDLW 0xF
125A  6EF3     MOVWF PROD, ACCESS
125C  46F3     RLNCF PROD, F, ACCESS
125E  46F3     RLNCF PROD, F, ACCESS
1260  0EC3     MOVLW 0xC3
1262  14C2     ANDWF ADCON0, W, ACCESS
1264  10F3     IORWF PROD, W, ACCESS
1266  6EC2     MOVWF ADCON0, ACCESS
49:            			if (adc_trigger++) { // trigger the conversion on the next timer int so the channel mux can settle
1268  0102     MOVLB 0x2
126A  51E3     MOVF prom, W, BANKED
126C  2BE3     INCF prom, F, BANKED
126E  0900     IORLW 0x0
1270  E002     BZ 0x1276
50:            				ADCON0bits.GO = HIGH; // and begin A/D conv, will set adc int flag when done.
1272  82C2     BSF ADCON0, 1, ACCESS
51:            				DLED_5 = HIGH;
1274  8A91     BSF LATJ, 5, ACCESS
52:            			}
53:            		}
54:            
55:            		/*
56:            		 * send SPI data
57:            		 */
58:            		if (!ringBufS_empty(spi_link.tx1b)) { // SPI send 
1276  C503     MOVFF 0x503, POSTINC1
1278  FFE6     NOP
127A  C504     MOVFF 0x504, POSTINC1
127C  FFE6     NOP
127E  EC26     CALL 0x2C4C, 0
1280  F016     NOP
1282  E942     SUBFSR 1, 0x2
1284  0900     IORLW 0x0
1286  E160     BNZ 0x1348
59:            			SSP1CON1bits.SSPM = 0;
1288  0EF0     MOVLW 0xF0
128A  14C6     ANDWF SSP1CON1, W, ACCESS
128C  0900     IORLW 0x0
128E  6EC6     MOVWF SSP1CON1, ACCESS
60:            			spi_buf.buf = ringBufS_get(spi_link.tx1b);
1290  C503     MOVFF 0x503, POSTINC1
1292  FFE6     NOP
1294  C504     MOVFF 0x504, POSTINC1
1296  FFE6     NOP
1298  EC3B     CALL 0x2C76, 0
129A  F016     NOP
129C  E942     SUBFSR 1, 0x2
129E  CFF3     MOVFF PROD, spi_buf
12A0  F0F1     NOP
12A2  CFF4     MOVFF PRODH, 0xF2
12A4  F0F2     NOP
61:            			SPI_LOAD = spi_buf.map.load;
12A6  0100     MOVLB 0x0
12A8  0100     MOVLB 0x0
12AA  51F2     MOVF 0xF2, W, BANKED
12AC  0B02     ANDLW 0x2
12AE  E002     BZ 0x12B4
12B0  8E8B     BSF LATC, 7, ACCESS
12B2  D001     BRA 0x12B6
12B4  9E8B     BCF LATC, 7, ACCESS
62:            			switch (spi_buf.map.select) { // set device select options
12B6  0100     MOVLB 0x0
12B8  51F2     MOVF 0xF2, W, BANKED
12BA  0B0C     ANDLW 0xC
12BC  42E8     RRNCF WREG, F, ACCESS
12BE  42E8     RRNCF WREG, F, ACCESS
12C0  0A03     XORLW 0x3
12C2  E016     BZ 0x12F0
12C4  0A01     XORLW 0x1
12C6  E00F     BZ 0x12E6
12C8  0A03     XORLW 0x3
12CA  E008     BZ 0x12DC
12CC  0A01     XORLW 0x1
12CE  E001     BZ 0x12D2
12D0  D014     BRA 0x12FA
63:            			case 0:
64:            				DAC_0_CS = LOW;
12D2  908B     BCF LATC, 0, ACCESS
65:            				DAC_1_CS = HIGH;
12D4  828B     BSF LATC, 1, ACCESS
66:            				SHF_2_CS = HIGH;
12D6  848B     BSF LATC, 2, ACCESS
67:            				SHF_3_CS = HIGH;
12D8  8C8B     BSF LATC, 6, ACCESS
68:            				break;
12DA  D014     BRA 0x1304
69:            			case 1:
70:            				DAC_0_CS = HIGH;
12DC  808B     BSF LATC, 0, ACCESS
71:            				DAC_1_CS = LOW;
12DE  928B     BCF LATC, 1, ACCESS
72:            				SHF_2_CS = HIGH;
12E0  848B     BSF LATC, 2, ACCESS
73:            				SHF_3_CS = HIGH;
12E2  8C8B     BSF LATC, 6, ACCESS
74:            				break;
12E4  D00F     BRA 0x1304
75:            			case 2:
76:            				DAC_0_CS = HIGH;
12E6  808B     BSF LATC, 0, ACCESS
77:            				DAC_1_CS = HIGH;
12E8  828B     BSF LATC, 1, ACCESS
78:            				SHF_2_CS = LOW;
12EA  948B     BCF LATC, 2, ACCESS
79:            				SHF_3_CS = HIGH;
12EC  8C8B     BSF LATC, 6, ACCESS
80:            				break;
12EE  D00A     BRA 0x1304
81:            			case 3:
82:            				DAC_0_CS = HIGH;
12F0  808B     BSF LATC, 0, ACCESS
83:            				DAC_1_CS = HIGH;
12F2  828B     BSF LATC, 1, ACCESS
84:            				SHF_2_CS = HIGH;
12F4  848B     BSF LATC, 2, ACCESS
85:            				SHF_3_CS = LOW;
12F6  9C8B     BCF LATC, 6, ACCESS
86:            				break;
12F8  D005     BRA 0x1304
87:            			default:
88:            				DAC_0_CS = HIGH;
12FA  808B     BSF LATC, 0, ACCESS
89:            				DAC_1_CS = HIGH;
12FC  828B     BSF LATC, 1, ACCESS
90:            				SHF_2_CS = HIGH;
12FE  848B     BSF LATC, 2, ACCESS
91:            				SHF_3_CS = HIGH;
1300  8C8B     BSF LATC, 6, ACCESS
92:            				break;
1302  D000     BRA 0x1304
93:            			}
94:            			Nop();
1304  0000     NOP
95:            			SSP1BUF = spi_buf.map.buf; // transfer the 8 bit data buffer
1306  C0F1     MOVFF spi_buf, SSP1BUF
1308  FFC9     NOP
96:            			if (spi_buf.map.cs) { // dselect device after current transfer ?
130A  0100     MOVLB 0x0
130C  A1F2     BTFSS 0xF2, 0, BANKED
130E  D01C     BRA 0x1348
97:            				Nop(); // a bit of extra delay
1310  0000     NOP
98:            				switch (spi_buf.map.select) { // set device deselect options
1312  0100     MOVLB 0x0
1314  51F2     MOVF 0xF2, W, BANKED
1316  0B0C     ANDLW 0xC
1318  42E8     RRNCF WREG, F, ACCESS
131A  42E8     RRNCF WREG, F, ACCESS
131C  0A03     XORLW 0x3
131E  E00D     BZ 0x133A
1320  0A01     XORLW 0x1
1322  E009     BZ 0x1336
1324  0A03     XORLW 0x3
1326  E005     BZ 0x1332
1328  0A01     XORLW 0x1
132A  E001     BZ 0x132E
132C  D008     BRA 0x133E
99:            				case 0:
100:           					DAC_0_CS = HIGH;
132E  808B     BSF LATC, 0, ACCESS
101:           					break;
1330  D00B     BRA 0x1348
102:           				case 1:
103:           					DAC_1_CS = HIGH;
1332  828B     BSF LATC, 1, ACCESS
104:           					break;
1334  D009     BRA 0x1348
105:           				case 2:
106:           					SHF_2_CS = HIGH;
1336  848B     BSF LATC, 2, ACCESS
107:           					break;
1338  D007     BRA 0x1348
108:           				case 3:
109:           					SHF_3_CS = HIGH;
133A  8C8B     BSF LATC, 6, ACCESS
110:           					break;
133C  D005     BRA 0x1348
111:           				default:
112:           					DAC_0_CS = HIGH;
133E  808B     BSF LATC, 0, ACCESS
113:           					DAC_1_CS = HIGH;
1340  828B     BSF LATC, 1, ACCESS
114:           					SHF_2_CS = HIGH;
1342  848B     BSF LATC, 2, ACCESS
115:           					SHF_3_CS = HIGH;
1344  8C8B     BSF LATC, 6, ACCESS
116:           					break;
1346  D000     BRA 0x1348
117:           				}
118:           			}
119:           		}
120:           
121:           		/*
122:           		 * LCD data handler
123:           		 */
124:           		if (!ringBufS_empty(L.tx1b) || lcd_buf.map.state) { // LCD send, 4bit , upper nibble
1348  C435     MOVFF 0x435, POSTINC1
134A  FFE6     NOP
134C  C436     MOVFF 0x436, POSTINC1
134E  FFE6     NOP
1350  EC26     CALL 0x2C4C, 0
1352  F016     NOP
1354  E942     SUBFSR 1, 0x2
1356  0900     IORLW 0x0
1358  E008     BZ 0x136A
135A  0100     MOVLB 0x0
135C  51F0     MOVF 0xF0, W, BANKED
135E  0B1C     ANDLW 0x1C
1360  42E8     RRNCF WREG, F, ACCESS
1362  42E8     RRNCF WREG, F, ACCESS
1364  0900     IORLW 0x0
1366  E101     BNZ 0x136A
1368  D0CA     BRA 0x14FE
125:           			switch (lcd_buf.map.state) {
136A  0100     MOVLB 0x0
136C  51F0     MOVF 0xF0, W, BANKED
136E  0B1C     ANDLW 0x1C
1370  42E8     RRNCF WREG, F, ACCESS
1372  42E8     RRNCF WREG, F, ACCESS
1374  0A04     XORLW 0x4
1376  E101     BNZ 0x137A
1378  D092     BRA 0x149E
137A  0A07     XORLW 0x7
137C  E101     BNZ 0x1380
137E  D077     BRA 0x146E
1380  0A01     XORLW 0x1
1382  E056     BZ 0x1430
1384  0A03     XORLW 0x3
1386  E03C     BZ 0x1400
1388  0A01     XORLW 0x1
138A  E001     BZ 0x138E
138C  D094     BRA 0x14B6
126:           			case 0:
127:           				lcd_buf.buf = ringBufS_get(L.tx1b);
138E  C435     MOVFF 0x435, POSTINC1
1390  FFE6     NOP
1392  C436     MOVFF 0x436, POSTINC1
1394  FFE6     NOP
1396  EC3B     CALL 0x2C76, 0
1398  F016     NOP
139A  E942     SUBFSR 1, 0x2
139C  CFF3     MOVFF PROD, lcd_buf
139E  F0EF     NOP
13A0  CFF4     MOVFF PRODH, 0xF0
13A2  F0F0     NOP
128:           				data = lcd_buf.buf;
13A4  C0EF     MOVFF lcd_buf, data
13A6  F0F3     NOP
129:           				lcd_buf.map.state = 0;
13A8  0100     MOVLB 0x0
13AA  95F0     BCF 0xF0, 2, BANKED
13AC  97F0     BCF 0xF0, 3, BANKED
13AE  99F0     BCF 0xF0, 4, BANKED
130:           				lcd_buf.map.skip = 0;
13B0  0100     MOVLB 0x0
13B2  9BF0     BCF 0xF0, 5, BANKED
131:           				TRIS_DATA_PORT &= 0x0f;
13B4  0E0F     MOVLW 0xF
13B6  1699     ANDWF TRISH, F, ACCESS
132:           				DATA_PORT &= 0x0f;
13B8  0E0F     MOVLW 0xF
13BA  1687     ANDWF PORTH, F, ACCESS
133:           				DATA_PORT |= data & 0xf0;
13BC  0EF0     MOVLW 0xF0
13BE  0100     MOVLB 0x0
13C0  15F3     ANDWF data, W, BANKED
13C2  1287     IORWF PORTH, F, ACCESS
134:           				if (lcd_buf.map.cmd) {
13C4  0100     MOVLB 0x0
13C6  A3F0     BTFSS 0xF0, 1, BANKED
13C8  D002     BRA 0x13CE
135:           					RS_PIN = 0; // Set control signals for command
13CA  9290     BCF LATH, 1, ACCESS
136:           				} else {
13CC  D001     BRA 0x13D0
137:           					RS_PIN = 1; // Set control bits for data
13CE  8290     BSF LATH, 1, ACCESS
138:           				}
139:           				RW_PIN = 0;
13D0  9490     BCF LATH, 2, ACCESS
140:           				lcd_buf.map.state++;
13D2  0EEF     MOVLW 0xEF
13D4  6EE9     MOVWF FSR0, ACCESS
13D6  0E00     MOVLW 0x0
13D8  6EEA     MOVWF FSR0H, ACCESS
13DA  52EE     MOVF POSTINC0, F, ACCESS
13DC  50EF     MOVF INDF0, W, ACCESS
13DE  0B1C     ANDLW 0x1C
13E0  42E8     RRNCF WREG, F, ACCESS
13E2  42E8     RRNCF WREG, F, ACCESS
13E4  2AE8     INCF WREG, F, ACCESS
13E6  6EF3     MOVWF PROD, ACCESS
13E8  50F3     MOVF PROD, W, ACCESS
13EA  0B07     ANDLW 0x7
13EC  6EF3     MOVWF PROD, ACCESS
13EE  6EF4     MOVWF PRODH, ACCESS
13F0  46F3     RLNCF PROD, F, ACCESS
13F2  46F3     RLNCF PROD, F, ACCESS
13F4  0EE3     MOVLW 0xE3
13F6  14EF     ANDWF INDF0, W, ACCESS
13F8  10F3     IORWF PROD, W, ACCESS
13FA  6EEF     MOVWF INDF0, ACCESS
13FC  50F4     MOVF PRODH, W, ACCESS
141:           				break;
13FE  D079     BRA 0x14F2
142:           			case 1:
143:           				E_PIN = 1; // Clock nibble into LCD
1400  8690     BSF LATH, 3, ACCESS
144:           				lcd_buf.map.state++;
1402  0EEF     MOVLW 0xEF
1404  6EE9     MOVWF FSR0, ACCESS
1406  0E00     MOVLW 0x0
1408  6EEA     MOVWF FSR0H, ACCESS
140A  52EE     MOVF POSTINC0, F, ACCESS
140C  50EF     MOVF INDF0, W, ACCESS
140E  0B1C     ANDLW 0x1C
1410  42E8     RRNCF WREG, F, ACCESS
1412  42E8     RRNCF WREG, F, ACCESS
1414  2AE8     INCF WREG, F, ACCESS
1416  6EF3     MOVWF PROD, ACCESS
1418  50F3     MOVF PROD, W, ACCESS
141A  0B07     ANDLW 0x7
141C  6EF3     MOVWF PROD, ACCESS
141E  6EF4     MOVWF PRODH, ACCESS
1420  46F3     RLNCF PROD, F, ACCESS
1422  46F3     RLNCF PROD, F, ACCESS
1424  0EE3     MOVLW 0xE3
1426  14EF     ANDWF INDF0, W, ACCESS
1428  10F3     IORWF PROD, W, ACCESS
142A  6EEF     MOVWF INDF0, ACCESS
142C  50F4     MOVF PRODH, W, ACCESS
145:           				break;
142E  D061     BRA 0x14F2
146:           			case 2:
147:           				E_PIN = 0;
1430  9690     BCF LATH, 3, ACCESS
148:           				DATA_PORT &= 0x0f;
1432  0E0F     MOVLW 0xF
1434  1687     ANDWF PORTH, F, ACCESS
149:           				DATA_PORT |= ((data << 4)&0xf0);
1436  0100     MOVLB 0x0
1438  39F3     SWAPF data, W, BANKED
143A  0BF0     ANDLW 0xF0
143C  0BF0     ANDLW 0xF0
143E  1287     IORWF PORTH, F, ACCESS
150:           				lcd_buf.map.state++;
1440  0EEF     MOVLW 0xEF
1442  6EE9     MOVWF FSR0, ACCESS
1444  0E00     MOVLW 0x0
1446  6EEA     MOVWF FSR0H, ACCESS
1448  52EE     MOVF POSTINC0, F, ACCESS
144A  50EF     MOVF INDF0, W, ACCESS
144C  0B1C     ANDLW 0x1C
144E  42E8     RRNCF WREG, F, ACCESS
1450  42E8     RRNCF WREG, F, ACCESS
1452  2AE8     INCF WREG, F, ACCESS
1454  6EF3     MOVWF PROD, ACCESS
1456  50F3     MOVF PROD, W, ACCESS
1458  0B07     ANDLW 0x7
145A  6EF3     MOVWF PROD, ACCESS
145C  6EF4     MOVWF PRODH, ACCESS
145E  46F3     RLNCF PROD, F, ACCESS
1460  46F3     RLNCF PROD, F, ACCESS
1462  0EE3     MOVLW 0xE3
1464  14EF     ANDWF INDF0, W, ACCESS
1466  10F3     IORWF PROD, W, ACCESS
1468  6EEF     MOVWF INDF0, ACCESS
146A  50F4     MOVF PRODH, W, ACCESS
151:           				break;
146C  D042     BRA 0x14F2
152:           			case 3:
153:           				E_PIN = 1; // Clock nibble into LCD
146E  8690     BSF LATH, 3, ACCESS
154:           				lcd_buf.map.state++;
1470  0EEF     MOVLW 0xEF
1472  6EE9     MOVWF FSR0, ACCESS
1474  0E00     MOVLW 0x0
1476  6EEA     MOVWF FSR0H, ACCESS
1478  52EE     MOVF POSTINC0, F, ACCESS
147A  50EF     MOVF INDF0, W, ACCESS
147C  0B1C     ANDLW 0x1C
147E  42E8     RRNCF WREG, F, ACCESS
1480  42E8     RRNCF WREG, F, ACCESS
1482  2AE8     INCF WREG, F, ACCESS
1484  6EF3     MOVWF PROD, ACCESS
1486  50F3     MOVF PROD, W, ACCESS
1488  0B07     ANDLW 0x7
148A  6EF3     MOVWF PROD, ACCESS
148C  6EF4     MOVWF PRODH, ACCESS
148E  46F3     RLNCF PROD, F, ACCESS
1490  46F3     RLNCF PROD, F, ACCESS
1492  0EE3     MOVLW 0xE3
1494  14EF     ANDWF INDF0, W, ACCESS
1496  10F3     IORWF PROD, W, ACCESS
1498  6EEF     MOVWF INDF0, ACCESS
149A  50F4     MOVF PRODH, W, ACCESS
155:           				break;
149C  D02A     BRA 0x14F2
156:           			case 4:
157:           				if (!lcd_buf.map.skip) { // don't repeat if we're in slow time
149E  0100     MOVLB 0x0
14A0  BBF0     BTFSC 0xF0, 5, BANKED
14A2  D009     BRA 0x14B6
158:           					E_PIN = 0;
14A4  9690     BCF LATH, 3, ACCESS
159:           					TRIS_DATA_PORT |= 0xf0;
14A6  0EF0     MOVLW 0xF0
14A8  1299     IORWF TRISH, F, ACCESS
160:           					V.lcd_count++;
14AA  0105     MOVLB 0x5
14AC  2B72     INCF 0x72, F, BANKED
14AE  0E00     MOVLW 0x0
14B0  2373     ADDWFC 0x73, F, BANKED
14B2  2374     ADDWFC 0x74, F, BANKED
14B4  2375     ADDWFC 0x75, F, BANKED
161:           				}
162:           				/* fall-through to default people */
163:           			default:
164:           				if (lcd_buf.map.slow) { // stay in this state until the slow flag clears below
14B6  0100     MOVLB 0x0
14B8  A1F0     BTFSS 0xF0, 0, BANKED
14BA  D016     BRA 0x14E8
165:           					lcd_buf.map.skip = 1;
14BC  0100     MOVLB 0x0
14BE  8BF0     BSF 0xF0, 5, BANKED
166:           					if (slow++ >= LCD_SLOW) { // for home and clear commands >3ms delay
14C0  0102     MOVLB 0x2
14C2  51E6     MOVF curr_byte, W, BANKED
14C4  2BE6     INCF curr_byte, F, BANKED
14C6  0102     MOVLB 0x2
14C8  6FEE     MOVWF 0xEE, BANKED
14CA  0E08     MOVLW 0x8
14CC  0102     MOVLB 0x2
14CE  6EE7     MOVWF INDF1, ACCESS
14D0  19EE     XORWF 0xEE, W, BANKED
14D2  E702     BNN 0x14D8
14D4  34E7     RLCF INDF1, W, ACCESS
14D6  D002     BRA 0x14DC
14D8  50E7     MOVF INDF1, W, ACCESS
14DA  5DEE     SUBWF 0xEE, W, BANKED
14DC  E304     BNC 0x14E6
167:           						lcd_buf.map.slow = 0;
14DE  0100     MOVLB 0x0
14E0  91F0     BCF 0xF0, 0, BANKED
168:           						slow = 0;
14E2  0102     MOVLB 0x2
14E4  6BE6     CLRF curr_byte, BANKED
169:           					}
170:           				} else {
14E6  D004     BRA 0x14F0
171:           					lcd_buf.map.state = 0;
14E8  0100     MOVLB 0x0
14EA  95F0     BCF 0xF0, 2, BANKED
14EC  97F0     BCF 0xF0, 3, BANKED
14EE  99F0     BCF 0xF0, 4, BANKED
172:           				}
173:           				break;
14F0  D000     BRA 0x14F2
174:           			}
175:           			if (!lcd_buf.map.slow)
14F2  0100     MOVLB 0x0
14F4  B1F0     BTFSC 0xF0, 0, BANKED
14F6  D002     BRA 0x14FC
176:           				PR4 = TIMER4_FAST; // pump the LCD faster than normal
14F8  0E07     MOVLW 0x7
14FA  6E77     MOVWF PR4, ACCESS
177:           		} else {
14FC  D004     BRA 0x1506
178:           			lcd_buf.map.state = 0;
14FE  0100     MOVLB 0x0
1500  95F0     BCF 0xF0, 2, BANKED
1502  97F0     BCF 0xF0, 3, BANKED
1504  99F0     BCF 0xF0, 4, BANKED
179:           		}
180:           	}
181:           
182:           	if (PIE1bits.SSP1IE && PIR1bits.SSP1IF) { // get data from SPI bus 1
1506  509D     MOVF PIE1, W, ACCESS
1508  0B08     ANDLW 0x8
150A  E014     BZ 0x1534
150C  509E     MOVF PIR1, W, ACCESS
150E  0B08     ANDLW 0x8
1510  E011     BZ 0x1534
183:           		spi_link.count++;
1512  0105     MOVLB 0x5
1514  2B07     INCF n, F, BANKED
1516  0E00     MOVLW 0x0
1518  2308     ADDWFC 0x8, F, BANKED
151A  2309     ADDWFC dtime2, F, BANKED
151C  230A     ADDWFC l, F, BANKED
184:           		PIR1bits.SSP1IF = LOW;
151E  969E     BCF PIR1, 3, ACCESS
185:           		ringBufS_put(spi_link.rx1b, SSP1BUF);
1520  50C9     MOVF SSP1BUF, W, ACCESS
1522  6EE6     MOVWF POSTINC1, ACCESS
1524  6AE6     CLRF POSTINC1, ACCESS
1526  C505     MOVFF 0x505, POSTINC1
1528  FFE6     NOP
152A  C506     MOVFF 0x506, POSTINC1
152C  FFE6     NOP
152E  EC6B     CALL 0x2CD6, 0
1530  F016     NOP
1532  E944     SUBFSR 1, 0x4
186:           	}
187:           
188:           	if (INTCON3bits.INT3IF) { // motor QEI input
1534  A4F0     BTFSS INTCON3, 2, ACCESS
1536  D007     BRA 0x1546
189:           		INTCON3bits.INT3IF = LOW;
1538  94F0     BCF INTCON3, 2, ACCESS
190:           		V.b3++;
153A  0105     MOVLB 0x5
153C  2B4E     INCF 0x4E, F, BANKED
153E  0E00     MOVLW 0x0
1540  234F     ADDWFC 0x4F, F, BANKED
1542  2350     ADDWFC 0x50, F, BANKED
1544  2351     ADDWFC 0x51, F, BANKED
191:           	}
192:           
193:           	if (INTCONbits.RBIF) { // PORT B int handler for Qencoder inputs A/B
1546  A0F2     BTFSS INTCON, 0, ACCESS
1548  D0A4     BRA 0x1692
194:           		INTCONbits.RBIF = LOW;
154A  90F2     BCF INTCON, 0, ACCESS
195:           		b_read = EXTIO;
154C  CF81     MOVFF PORTB, b_read
154E  F2E5     NOP
196:           		V.buttonint_count++;
1550  0105     MOVLB 0x5
1552  2B1E     INCF digit_cnt, F, BANKED
1554  0E00     MOVLW 0x0
1556  231F     ADDWFC prefix_cnt, F, BANKED
1558  2320     ADDWFC sign_char, F, BANKED
155A  2321     ADDWFC buf, F, BANKED
197:           		D_UPDATE = TRUE;
155C  0105     MOVLB 0x5
155E  0E01     MOVLW 0x1
1560  6F0E     MOVWF precision, BANKED
198:           
199:           		// modified version from www.piclist.com qenc-dk.htm
200:           		if (OldEncoder.OldPortB[0] != (OldEncoder.byTemp[0] = (b_read & QENC1BITS))) { // read encoder 1
1562  0E30     MOVLW 0x30
1564  0102     MOVLB 0x2
1566  15E5     ANDWF 0xE5, W, BANKED
1568  0103     MOVLB 0x3
156A  6FA7     MOVWF 0xA7, BANKED
156C  0103     MOVLB 0x3
156E  5DA5     SUBWF 0xA5, W, BANKED
1570  E043     BZ 0x15F8
201:           			knob1.ticks = 0;
1572  0103     MOVLB 0x3
1574  6B91     CLRF 0x91, BANKED
202:           			OldEncoder.OldPortB[0] = OldEncoder.byTemp[0];
1576  C3A7     MOVFF 0x3A7, 0x3A5
1578  F3A5     NOP
203:           			if (ENC_A1 == OldEncoder.A1) {
157A  5081     MOVF PORTB, W, ACCESS
157C  0B10     ANDLW 0x10
157E  E001     BZ 0x1582
1580  0E01     MOVLW 0x1
1582  0102     MOVLB 0x2
1584  6FEE     MOVWF 0xEE, BANKED
1586  0103     MOVLB 0x3
1588  51A4     MOVF 0xA4, W, BANKED
158A  0B10     ANDLW 0x10
158C  E001     BZ 0x1590
158E  0EFF     MOVLW 0xFF
1590  0102     MOVLB 0x2
1592  5DEE     SUBWF 0xEE, W, BANKED
1594  E12A     BNZ 0x15EA
204:           				if (ENC_B1 == ENC_A1) {
1596  5081     MOVF PORTB, W, ACCESS
1598  0B20     ANDLW 0x20
159A  E001     BZ 0x159E
159C  0E01     MOVLW 0x1
159E  0102     MOVLB 0x2
15A0  6FEE     MOVWF 0xEE, BANKED
15A2  5081     MOVF PORTB, W, ACCESS
15A4  0B10     ANDLW 0x10
15A6  E001     BZ 0x15AA
15A8  0E01     MOVLW 0x1
15AA  0102     MOVLB 0x2
15AC  5DEE     SUBWF 0xEE, W, BANKED
15AE  E10E     BNZ 0x15CC
205:           					++knob1.c;
15B0  0103     MOVLB 0x3
15B2  2B83     INCF 0x83, F, BANKED
15B4  0E00     MOVLW 0x0
15B6  2384     ADDWFC 0x84, F, BANKED
15B8  2385     ADDWFC 0x85, F, BANKED
15BA  2386     ADDWFC 0x86, F, BANKED
206:           					knob1.cw = TRUE;
15BC  0103     MOVLB 0x3
15BE  0E01     MOVLW 0x1
15C0  6F8F     MOVWF 0x8F, BANKED
207:           					knob1.ccw = FALSE;
15C2  0103     MOVLB 0x3
15C4  6B90     CLRF 0x90, BANKED
208:           					knob1.movement = CW;
15C6  0103     MOVLB 0x3
15C8  6B92     CLRF 0x92, BANKED
209:           				} else {
15CA  D00E     BRA 0x15E8
210:           					--knob1.c;
15CC  0103     MOVLB 0x3
15CE  0783     DECF 0x83, F, BANKED
15D0  0E00     MOVLW 0x0
15D2  5B84     SUBWFB 0x84, F, BANKED
15D4  5B85     SUBWFB 0x85, F, BANKED
15D6  5B86     SUBWFB 0x86, F, BANKED
211:           					knob1.cw = FALSE;
15D8  0103     MOVLB 0x3
15DA  6B8F     CLRF 0x8F, BANKED
212:           					knob1.ccw = TRUE;
15DC  0103     MOVLB 0x3
15DE  0E01     MOVLW 0x1
15E0  6F90     MOVWF 0x90, BANKED
213:           					knob1.movement = CCW;
15E2  0103     MOVLB 0x3
15E4  0E02     MOVLW 0x2
15E6  6F92     MOVWF 0x92, BANKED
214:           				}
215:           			} else {
15E8  D007     BRA 0x15F8
216:           				OldEncoder.A1 = ENC_A1;
15EA  0103     MOVLB 0x3
15EC  5081     MOVF PORTB, W, ACCESS
15EE  0B10     ANDLW 0x10
15F0  E002     BZ 0x15F6
15F2  89A4     BSF 0xA4, 4, BANKED
15F4  D001     BRA 0x15F8
15F6  99A4     BCF 0xA4, 4, BANKED
217:           			}
218:           		}
219:           
220:           		if (OldEncoder.OldPortB[1] != (OldEncoder.byTemp[1] = (b_read & QENC2BITS))) { // read encoder 2
15F8  0EC0     MOVLW 0xC0
15FA  0102     MOVLB 0x2
15FC  15E5     ANDWF 0xE5, W, BANKED
15FE  0103     MOVLB 0x3
1600  6FA8     MOVWF 0xA8, BANKED
1602  0103     MOVLB 0x3
1604  5DA6     SUBWF 0xA6, W, BANKED
1606  E043     BZ 0x168E
221:           			knob2.ticks = 0;
1608  0103     MOVLB 0x3
160A  6BA1     CLRF 0xA1, BANKED
222:           			OldEncoder.OldPortB[1] = OldEncoder.byTemp[1];
160C  C3A8     MOVFF 0x3A8, 0x3A6
160E  F3A6     NOP
223:           			if (ENC_A2 == OldEncoder.A2) {
1610  5081     MOVF PORTB, W, ACCESS
1612  0B40     ANDLW 0x40
1614  E001     BZ 0x1618
1616  0E01     MOVLW 0x1
1618  0102     MOVLB 0x2
161A  6FEE     MOVWF 0xEE, BANKED
161C  0103     MOVLB 0x3
161E  51A4     MOVF 0xA4, W, BANKED
1620  0B40     ANDLW 0x40
1622  E001     BZ 0x1626
1624  0EFF     MOVLW 0xFF
1626  0102     MOVLB 0x2
1628  5DEE     SUBWF 0xEE, W, BANKED
162A  E12A     BNZ 0x1680
224:           				if (ENC_B2 == ENC_A2) {
162C  5081     MOVF PORTB, W, ACCESS
162E  0B80     ANDLW 0x80
1630  E001     BZ 0x1634
1632  0E01     MOVLW 0x1
1634  0102     MOVLB 0x2
1636  6FEE     MOVWF 0xEE, BANKED
1638  5081     MOVF PORTB, W, ACCESS
163A  0B40     ANDLW 0x40
163C  E001     BZ 0x1640
163E  0E01     MOVLW 0x1
1640  0102     MOVLB 0x2
1642  5DEE     SUBWF 0xEE, W, BANKED
1644  E10E     BNZ 0x1662
225:           					++knob2.c;
1646  0103     MOVLB 0x3
1648  2B93     INCF 0x93, F, BANKED
164A  0E00     MOVLW 0x0
164C  2394     ADDWFC 0x94, F, BANKED
164E  2395     ADDWFC 0x95, F, BANKED
1650  2396     ADDWFC 0x96, F, BANKED
226:           					knob2.cw = TRUE;
1652  0103     MOVLB 0x3
1654  0E01     MOVLW 0x1
1656  6F9F     MOVWF 0x9F, BANKED
227:           					knob2.ccw = FALSE;
1658  0103     MOVLB 0x3
165A  6BA0     CLRF 0xA0, BANKED
228:           					knob2.movement = CW;
165C  0103     MOVLB 0x3
165E  6BA2     CLRF 0xA2, BANKED
229:           				} else {
1660  D00E     BRA 0x167E
230:           					--knob2.c;
1662  0103     MOVLB 0x3
1664  0793     DECF 0x93, F, BANKED
1666  0E00     MOVLW 0x0
1668  5B94     SUBWFB 0x94, F, BANKED
166A  5B95     SUBWFB 0x95, F, BANKED
166C  5B96     SUBWFB 0x96, F, BANKED
231:           					knob2.cw = FALSE;
166E  0103     MOVLB 0x3
1670  6B9F     CLRF 0x9F, BANKED
232:           					knob2.ccw = TRUE;
1672  0103     MOVLB 0x3
1674  0E01     MOVLW 0x1
1676  6FA0     MOVWF 0xA0, BANKED
233:           					knob2.movement = CCW;
1678  0103     MOVLB 0x3
167A  0E02     MOVLW 0x2
167C  6FA2     MOVWF 0xA2, BANKED
234:           				}
235:           			} else {
167E  D007     BRA 0x168E
236:           				OldEncoder.A2 = ENC_A2;
1680  0103     MOVLB 0x3
1682  5081     MOVF PORTB, W, ACCESS
1684  0B40     ANDLW 0x40
1686  E002     BZ 0x168C
1688  8DA4     BSF 0xA4, 6, BANKED
168A  D001     BRA 0x168E
168C  9DA4     BCF 0xA4, 6, BANKED
237:           			}
238:           		}
239:           		HID_IDLE_FLAG = FALSE;
168E  0102     MOVLB 0x2
1690  6BE4     CLRF 0xE4, BANKED
240:           	}
241:           
242:           	if (PIR2bits.EEIF) { // EEPROM write complete flag
1692  A8A1     BTFSS PIR2, 4, ACCESS
1694  D008     BRA 0x16A6
243:           		V.eeprom_count++; // just keep count
1696  0105     MOVLB 0x5
1698  2B26     INCF 0x26, F, BANKED
169A  0E00     MOVLW 0x0
169C  2327     ADDWFC 0x27, F, BANKED
169E  2328     ADDWFC 0x28, F, BANKED
16A0  2329     ADDWFC 0x29, F, BANKED
244:           		MPULED = !MPULED; //  flash led
16A2  7090     BTG LATH, 0, ACCESS
245:           		PIR2bits.EEIF = LOW;
16A4  98A1     BCF PIR2, 4, ACCESS
246:           	}
247:           
248:           	if (INTCONbits.TMR0IF) { // check timer0 irq 1 second timer int handler
16A6  A4F2     BTFSS INTCON, 2, ACCESS
16A8  D015     BRA 0x16D4
249:           		INTCONbits.TMR0IF = LOW; //clear interrupt flag
16AA  94F2     BCF INTCON, 2, ACCESS
250:           		//check for TMR0 overflow
251:           
252:           		timer.lt = TIMEROFFSET; // Copy timer value into union
16AC  0E6A     MOVLW 0x6A
16AE  6E01     MOVWF [0x1], ACCESS
16B0  0E67     MOVLW 0x67
16B2  6E02     MOVWF [0x2], ACCESS
253:           		TMR0H = timer.bt[HIGH]; // Write high byte to Timer0
16B4  EB02     MOVSF 0x2, 0xFD7
16B6  FFD7     NOP
254:           		TMR0L = timer.bt[LOW]; // Write low byte to Timer0
16B8  EB01     MOVSF 0x1, 0xFD6
16BA  FFD6     NOP
255:           
256:           		TIMERFLAG = TRUE;
16BC  0105     MOVLB 0x5
16BE  0E01     MOVLW 0x1
16C0  6F0C     MOVWF flags, BANKED
257:           
258:           		MPULED = !MPULED; //  flash led
16C2  7090     BTG LATH, 0, ACCESS
259:           		V.timerint_count++; // set 1 second clock counter.
16C4  0105     MOVLB 0x5
16C6  2B22     INCF 0x22, F, BANKED
16C8  0E00     MOVLW 0x0
16CA  2323     ADDWFC 0x23, F, BANKED
16CC  2324     ADDWFC 0x24, F, BANKED
16CE  2325     ADDWFC 0x25, F, BANKED
260:           		DLED_6 = OFF;
16D0  8C91     BSF LATJ, 6, ACCESS
261:           		DLED_7 = OFF;
16D2  8E91     BSF LATJ, 7, ACCESS
262:           	}
263:           
264:           	/* User terminal comm routines */
265:           	if (PIR3bits.RC2IF) { // is data from user command/dump terminal port
16D4  AAA4     BTFSS PIR3, 5, ACCESS
16D6  D014     BRA 0x1700
266:           		/* clear com2 interrupt flag */
267:           		// a read clears the flag
268:           		V.c2_int++;
16D8  0105     MOVLB 0x5
16DA  2B36     INCF 0x36, F, BANKED
16DC  0E00     MOVLW 0x0
16DE  2337     ADDWFC 0x37, F, BANKED
16E0  2338     ADDWFC 0x38, F, BANKED
16E2  2339     ADDWFC 0x39, F, BANKED
269:           		if (RCSTA2bits.OERR) {
16E4  A26B     BTFSS RCSTA2, 1, ACCESS
16E6  D002     BRA 0x16EC
270:           			RCSTA2bits.CREN = LOW; //      clear overrun
16E8  986B     BCF RCSTA2, 4, ACCESS
271:           			RCSTA2bits.CREN = HIGH; // re-enable
16EA  886B     BSF RCSTA2, 4, ACCESS
272:           		}
273:           
274:           		ringBufS_put(L.rx2b, RCREG2); // read from host port2 and clear PIR3bits.RC2IF
16EC  506E     MOVF RCREG2, W, ACCESS
16EE  6EE6     MOVWF POSTINC1, ACCESS
16F0  6AE6     CLRF POSTINC1, ACCESS
16F2  C437     MOVFF 0x437, POSTINC1
16F4  FFE6     NOP
16F6  C438     MOVFF 0x438, POSTINC1
16F8  FFE6     NOP
16FA  EC6B     CALL 0x2CD6, 0
16FC  F016     NOP
16FE  E944     SUBFSR 1, 0x4
275:           	}
276:           
277:           	/* Control button routines */
278:           	if (INTCONbits.INT0IF) {
1700  A2F2     BTFSS INTCON, 1, ACCESS
1702  D011     BRA 0x1726
279:           		INTCONbits.INT0IF = LOW;
1704  92F2     BCF INTCON, 1, ACCESS
280:           		V.b0++;
1706  0105     MOVLB 0x5
1708  2B42     INCF q, F, BANKED
170A  0E00     MOVLW 0x0
170C  2343     ADDWFC 0x43, F, BANKED
170E  2344     ADDWFC 0x44, F, BANKED
1710  2345     ADDWFC 0x45, F, BANKED
281:           		if (SYSTEM_STABLE && (PB0 == 0u)) {
1712  0105     MOVLB 0x5
1714  510D     MOVF j, W, BANKED
1716  E005     BZ 0x1722
1718  5081     MOVF PORTB, W, ACCESS
171A  0B01     ANDLW 0x1
171C  E102     BNZ 0x1722
282:           			button.B0 = 1;
171E  0103     MOVLB 0x3
1720  81C0     BSF 0xC0, 0, BANKED
283:           		}
284:           		HID_IDLE_FLAG = FALSE;
1722  0102     MOVLB 0x2
1724  6BE4     CLRF 0xE4, BANKED
285:           	}
286:           
287:           	if (INTCON3bits.INT1IF) {
1726  A0F0     BTFSS INTCON3, 0, ACCESS
1728  D011     BRA 0x174C
288:           		INTCON3bits.INT1IF = LOW;
172A  90F0     BCF INTCON3, 0, ACCESS
289:           		V.b1++;
172C  0105     MOVLB 0x5
172E  2B46     INCF 0x46, F, BANKED
1730  0E00     MOVLW 0x0
1732  2347     ADDWFC 0x47, F, BANKED
1734  2348     ADDWFC 0x48, F, BANKED
1736  2349     ADDWFC 0x49, F, BANKED
290:           		if (SYSTEM_STABLE && (PB1 == 0u)) {
1738  0105     MOVLB 0x5
173A  510D     MOVF j, W, BANKED
173C  E005     BZ 0x1748
173E  5081     MOVF PORTB, W, ACCESS
1740  0B02     ANDLW 0x2
1742  E102     BNZ 0x1748
291:           			button.B1 = 1;
1744  0103     MOVLB 0x3
1746  83C0     BSF 0xC0, 1, BANKED
292:           		}
293:           		HID_IDLE_FLAG = FALSE;
1748  0102     MOVLB 0x2
174A  6BE4     CLRF 0xE4, BANKED
294:           	}
295:           
296:           	if (INTCON3bits.INT2IF) {
174C  A2F0     BTFSS INTCON3, 1, ACCESS
174E  D011     BRA 0x1772
297:           		INTCON3bits.INT2IF = LOW;
1750  92F0     BCF INTCON3, 1, ACCESS
298:           		V.b2++;
1752  0105     MOVLB 0x5
1754  2B4A     INCF 0x4A, F, BANKED
1756  0E00     MOVLW 0x0
1758  234B     ADDWFC 0x4B, F, BANKED
175A  234C     ADDWFC 0x4C, F, BANKED
175C  234D     ADDWFC 0x4D, F, BANKED
299:           		if (SYSTEM_STABLE && (PB2 == 0u)) {
175E  0105     MOVLB 0x5
1760  510D     MOVF j, W, BANKED
1762  E005     BZ 0x176E
1764  5081     MOVF PORTB, W, ACCESS
1766  0B04     ANDLW 0x4
1768  E102     BNZ 0x176E
300:           			button.B2 = 1;
176A  0103     MOVLB 0x3
176C  85C0     BSF 0xC0, 2, BANKED
301:           		}
302:           		HID_IDLE_FLAG = FALSE;
176E  0102     MOVLB 0x2
1770  6BE4     CLRF 0xE4, BANKED
303:           	}
304:           	DLED_0 = LOW;
1772  9091     BCF LATJ, 0, ACCESS
305:           }
1774  E943     SUBFSR 1, 0x3
1776  CFE7     MOVFF INDF1, FSR2
1778  FFD9     NOP
177A  52E5     MOVF POSTDEC1, F, ACCESS
177C  EE01     LFSR 0, 0x1FF
177E  F0FF     NOP
1780  0E0F     MOVLW 0xF
1782  04E8     DECF WREG, W, ACCESS
1784  E303     BNC 0x178C
1786  CFE5     MOVFF POSTDEC1, POSTDEC0
1788  FFED     NOP
178A  D7FB     BRA 0x1782
178C  CFE5     MOVFF POSTDEC1, PCLATU
178E  FFFB     NOP
1790  CFE5     MOVFF POSTDEC1, PCLATH
1792  FFFA     NOP
1794  CFE5     MOVFF POSTDEC1, PRODH
1796  FFF4     NOP
1798  CFE5     MOVFF POSTDEC1, PROD
179A  FFF3     NOP
179C  CFE5     MOVFF POSTDEC1, TABLAT
179E  FFF5     NOP
17A0  CFE5     MOVFF POSTDEC1, TBLPTRU
17A2  FFF8     NOP
17A4  CFE5     MOVFF POSTDEC1, TBLPTRH
17A6  FFF7     NOP
17A8  CFE5     MOVFF POSTDEC1, TBLPTR
17AA  FFF6     NOP
17AC  CFE5     MOVFF POSTDEC1, 0xFD
17AE  F0FD     NOP
17B0  CFE5     MOVFF POSTDEC1, 0xFC
17B2  F0FC     NOP
17B4  CFE5     MOVFF POSTDEC1, 0xFB
17B6  F0FB     NOP
17B8  CFE5     MOVFF POSTDEC1, 0xFA
17BA  F0FA     NOP
17BC  CFE5     MOVFF POSTDEC1, FSR0H
17BE  FFEA     NOP
17C0  CFE5     MOVFF POSTDEC1, FSR0
17C2  FFE9     NOP
17C4  CFE5     MOVFF POSTDEC1, FSR2H
17C6  FFDA     NOP
17C8  0011     RETFIE 1
306:           
307:           #pragma interruptlow work_handler
308:           
309:           void work_handler(void) // This is the low priority ISR routine, the high ISR routine will be called during this code section
17CA  CFD8     MOVFF STATUS, PREINC1
17CC  FFE4     NOP
17CE  CFE0     MOVFF BSR, PREINC1
17D0  FFE4     NOP
17D2  6EE4     MOVWF PREINC1, ACCESS
17D4  CFDA     MOVFF FSR2H, PREINC1
17D6  FFE4     NOP
17D8  CFE2     MOVFF FSR1H, FSR2H
17DA  FFDA     NOP
17DC  CFE9     MOVFF FSR0, PREINC1
17DE  FFE4     NOP
17E0  CFEA     MOVFF FSR0H, PREINC1
17E2  FFE4     NOP
17E4  C0FA     MOVFF 0xFA, PREINC1
17E6  FFE4     NOP
17E8  C0FB     MOVFF 0xFB, PREINC1
17EA  FFE4     NOP
17EC  C0FC     MOVFF 0xFC, PREINC1
17EE  FFE4     NOP
17F0  C0FD     MOVFF 0xFD, PREINC1
17F2  FFE4     NOP
17F4  CFF6     MOVFF TBLPTR, PREINC1
17F6  FFE4     NOP
17F8  CFF7     MOVFF TBLPTRH, PREINC1
17FA  FFE4     NOP
17FC  CFF8     MOVFF TBLPTRU, PREINC1
17FE  FFE4     NOP
1800  CFF5     MOVFF TABLAT, PREINC1
1802  FFE4     NOP
1804  CFF3     MOVFF PROD, PREINC1
1806  FFE4     NOP
1808  CFF4     MOVFF PRODH, PREINC1
180A  FFE4     NOP
180C  CFFA     MOVFF PCLATH, PREINC1
180E  FFE4     NOP
1810  CFFB     MOVFF PCLATU, PREINC1
1812  FFE4     NOP
1814  EE01     LFSR 0, 0x1F1
1816  F0F1     NOP
1818  0E0F     MOVLW 0xF
181A  04E8     DECF WREG, W, ACCESS
181C  E303     BNC 0x1824
181E  CFEE     MOVFF POSTINC0, PREINC1
1820  FFE4     NOP
1822  D7FB     BRA 0x181A
1824  52E6     MOVF POSTINC1, F, ACCESS
1826  CFD9     MOVFF FSR2, POSTINC1
1828  FFE6     NOP
182A  CFE1     MOVFF FSR1, FSR2
182C  FFD9     NOP
182E  E981     SUBFSR 2, 0x1
1830  E844     ADDFSR 1, 0x4
310:           { // projector lamp scan converter, mfc totals
311:           	union Timers timerl;
312:           	uint8_t i;
313:           	union mcp4822_adr_type mfc_dac_select;
314:           
315:           	DLED_1 = HIGH;
1832  8291     BSF LATJ, 1, ACCESS
316:           	V.lowint_count++; // low int trigger entropy counter
1834  0105     MOVLB 0x5
1836  2B2E     INCF 0x2E, F, BANKED
1838  0E00     MOVLW 0x0
183A  232F     ADDWFC 0x2F, F, BANKED
183C  2330     ADDWFC 0x30, F, BANKED
183E  2331     ADDWFC 0x31, F, BANKED
317:           
318:           	if (PIR2bits.TMR3IF) { //      Timer3 int handler
1840  A2A1     BTFSS PIR2, 1, ACCESS
1842  D062     BRA 0x1908
319:           		PIR2bits.TMR3IF = LOW; // clear int flag
1844  92A1     BCF PIR2, 1, ACCESS
320:           		timerl.lt = TIMER3REG; // Save the 16-bit value in local
1846  0EE8     MOVLW 0xE8
1848  6E01     MOVWF [0x1], ACCESS
184A  0E0B     MOVLW 0xB
184C  6E02     MOVWF [0x2], ACCESS
321:           		TMR3H = timerl.bt[HIGH]; // Write high byte to Timer3 High byte
184E  EB02     MOVSF 0x2, 0xFB3
1850  FFB3     NOP
322:           		TMR3L = timerl.bt[LOW]; // Write low byte to Timer3 Low byte
1852  EB01     MOVSF 0x1, 0xFB2
1854  FFB2     NOP
323:           		V.clock20++;
1856  2B62     INCF 0x62, F, BANKED
1858  0E00     MOVLW 0x0
185A  2363     ADDWFC 0x63, F, BANKED
185C  2364     ADDWFC 0x64, F, BANKED
185E  2365     ADDWFC 0x65, F, BANKED
324:           
325:           		for (i = AIR_MFC; i <= COLOR2_MFC; i++) {
1860  6A03     CLRF [0x3], ACCESS
1862  5003     MOVF [0x3], W, ACCESS
1864  0803     SUBLW 0x3
1866  E350     BNC 0x1908
1904  2A03     INCF [0x3], F, ACCESS
1906  D7AD     BRA 0x1862
326:           			mfc[i].mfc_integ_total_mass += L.adc_val[i];
1868  D894     RCALL __pa_2
186A  0E17     MOVLW 0x17
186C  D88E     RCALL __pa_1
186E  0103     MOVLB 0x3
1870  D89C     RCALL __pa_3
1992  5003     MOVF [0x3], W, ACCESS
1994  0D04     MULLW 0x4
1996  CFF3     MOVFF PROD, FSR0
1998  FFE9     NOP
199A  CFF4     MOVFF PRODH, FSR0H
199C  FFEA     NOP
199E  0E03     MOVLW 0x3
19A0  26E9     ADDWF FSR0, F, ACCESS
19A2  0E04     MOVLW 0x4
19A4  22EA     ADDWFC FSR0H, F, ACCESS
19A6  EFDE     GOTO 0x19BC
19A8  F00C     NOP
19AA  51FC     MOVF 0xFC, W, BANKED
19AC  26EE     ADDWF POSTINC0, F, ACCESS
19AE  51FD     MOVF 0xFD, W, BANKED
19B0  22EE     ADDWFC POSTINC0, F, ACCESS
19B2  51FE     MOVF Seed, W, BANKED
19B4  22EE     ADDWFC POSTINC0, F, ACCESS
19B6  51FF     MOVF 0xFF, W, BANKED
19B8  22EE     ADDWFC POSTINC0, F, ACCESS
19BA  0012     RETURN 0
327:           			mfc[i].mfc_integ_current_mass += L.adc_val[i];
1872  D88F     RCALL __pa_2
1874  0E1B     MOVLW 0x1B
1876  D889     RCALL __pa_1
1878  D898     RCALL __pa_3
328:           
329:           			switch (mfc[i].gas_t) {
187A  D87C     RCALL __pa_0
187C  0E02     MOVLW 0x2
187E  D885     RCALL __pa_1
1880  50EF     MOVF INDF0, W, ACCESS
1882  0A01     XORLW 0x1
1884  E03F     BZ 0x1904
1886  0A01     XORLW 0x1
1888  E036     BZ 0x18F6
188A  0A02     XORLW 0x2
188C  E13B     BNZ 0x1904
330:           			case MASS: /* turn off the MFC at the total mass setpoint target */
331:           				if (mfc[i].mfc_integ_current_mass >= mfc[i].mfc_integ_target_mass) {
188E  D872     RCALL __pa_0
1890  0E1F     MOVLW 0x1F
1892  D87B     RCALL __pa_1
1894  D893     RCALL __pa_4
1896  0E1B     MOVLW 0x1B
1898  D878     RCALL __pa_1
189A  51FC     MOVF 0xFC, W, BANKED
189C  5CEE     SUBWF POSTINC0, W, ACCESS
189E  51FD     MOVF 0xFD, W, BANKED
18A0  58EE     SUBWFB POSTINC0, W, ACCESS
18A2  51FE     MOVF Seed, W, BANKED
18A4  58EE     SUBWFB POSTINC0, W, ACCESS
18A6  51FF     MOVF 0xFF, W, BANKED
18A8  58EE     SUBWFB POSTINC0, W, ACCESS
18AA  E32C     BNC 0x1904
19BC  CFEE     MOVFF POSTINC0, __tmp_2
19BE  F3FC     NOP
19C0  CFEE     MOVFF POSTINC0, 0x3FD
19C2  F3FD     NOP
19C4  CFEE     MOVFF POSTINC0, 0x3FE
19C6  F3FE     NOP
19C8  CFEF     MOVFF INDF0, 0x3FF
19CA  F3FF     NOP
19CC  EFBA     GOTO 0x1974
19CE  F00C     NOP
332:           					mfc[i].done = HIGH;
18AC  D863     RCALL __pa_0
18AE  52EE     MOVF POSTINC0, F, ACCESS
18B0  80EF     BSF INDF0, 0, ACCESS
333:           					mfc_dac_select.buf = i;
18B2  EB83     MOVSS 0x3, 0x4
18B4  F004     NOP
334:           					mfc[i].mfc_set = 0;
18B6  D85E     RCALL __pa_0
18B8  0E07     MOVLW 0x7
18BA  D867     RCALL __pa_1
18BC  6AEE     CLRF POSTINC0, ACCESS
18BE  6AED     CLRF POSTDEC0, ACCESS
335:           					SPI_Daq_Update(mfc[i].mfc_set, mfc_dac_select.map.cs, mfc_dac_select.map.device);
18C0  50D9     MOVF FSR2, W, ACCESS
18C2  0F04     ADDLW 0x4
18C4  6EE9     MOVWF FSR0, ACCESS
18C6  CFDA     MOVFF FSR2H, FSR0H
18C8  FFEA     NOP
18CA  50EF     MOVF INDF0, W, ACCESS
18CC  0B01     ANDLW 0x1
18CE  6EE6     MOVWF POSTINC1, ACCESS
18D0  50D9     MOVF FSR2, W, ACCESS
18D2  0F04     ADDLW 0x4
18D4  6EE9     MOVWF FSR0, ACCESS
18D6  50EF     MOVF INDF0, W, ACCESS
18D8  0B02     ANDLW 0x2
18DA  E001     BZ 0x18DE
18DC  0E01     MOVLW 0x1
18DE  6EE6     MOVWF POSTINC1, ACCESS
18E0  D849     RCALL __pa_0
18E2  0E07     MOVLW 0x7
18E4  D852     RCALL __pa_1
18E6  CFEE     MOVFF POSTINC0, POSTINC1
18E8  FFE6     NOP
18EA  CFEE     MOVFF POSTINC0, POSTINC1
18EC  FFE6     NOP
18EE  EC40     CALL 0x3080, 0
18F0  F018     NOP
18F2  E944     SUBFSR 1, 0x4
336:           				}
337:           				break;
18F4  D007     BRA 0x1904
338:           			case SHUT:
339:           				mfc[i].mfc_integ_current_mass = 0;
18F6  D83E     RCALL __pa_0
18F8  0E1B     MOVLW 0x1B
18FA  D847     RCALL __pa_1
18FC  6AEE     CLRF POSTINC0, ACCESS
18FE  6AEE     CLRF POSTINC0, ACCESS
1900  6AEE     CLRF POSTINC0, ACCESS
1902  6AEE     CLRF POSTINC0, ACCESS
1974  5003     MOVF [0x3], W, ACCESS
1976  0D2B     MULLW 0x2B
1978  CFF3     MOVFF PROD, FSR0
197A  FFE9     NOP
197C  CFF4     MOVFF PRODH, FSR0H
197E  FFEA     NOP
1980  0E00     MOVLW 0x0
1982  26E9     ADDWF FSR0, F, ACCESS
1984  0E07     MOVLW 0x7
1986  22EA     ADDWFC FSR0H, F, ACCESS
1988  0012     RETURN 0
198A  26E9     ADDWF FSR0, F, ACCESS
198C  0E00     MOVLW 0x0
198E  22EA     ADDWFC FSR0H, F, ACCESS
1990  0012     RETURN 0
340:           				break;
341:           			case FLOW:
342:           				break;
343:           			default:
344:           				break;
345:           			}
346:           		}
347:           	}
348:           	DLED_1 = LOW;
1908  9291     BCF LATJ, 1, ACCESS
349:           }
190A  E945     SUBFSR 1, 0x5
190C  CFE7     MOVFF INDF1, FSR2
190E  FFD9     NOP
1910  52E5     MOVF POSTDEC1, F, ACCESS
1912  EE01     LFSR 0, 0x1FF
1914  F0FF     NOP
1916  0E0F     MOVLW 0xF
1918  04E8     DECF WREG, W, ACCESS
191A  E303     BNC 0x1922
191C  CFE5     MOVFF POSTDEC1, POSTDEC0
191E  FFED     NOP
1920  D7FB     BRA 0x1918
1922  CFE5     MOVFF POSTDEC1, PCLATU
1924  FFFB     NOP
1926  CFE5     MOVFF POSTDEC1, PCLATH
1928  FFFA     NOP
192A  CFE5     MOVFF POSTDEC1, PRODH
192C  FFF4     NOP
192E  CFE5     MOVFF POSTDEC1, PROD
1930  FFF3     NOP
1932  CFE5     MOVFF POSTDEC1, TABLAT
1934  FFF5     NOP
1936  CFE5     MOVFF POSTDEC1, TBLPTRU
1938  FFF8     NOP
193A  CFE5     MOVFF POSTDEC1, TBLPTRH
193C  FFF7     NOP
193E  CFE5     MOVFF POSTDEC1, TBLPTR
1940  FFF6     NOP
1942  CFE5     MOVFF POSTDEC1, 0xFD
1944  F0FD     NOP
1946  CFE5     MOVFF POSTDEC1, 0xFC
1948  F0FC     NOP
194A  CFE5     MOVFF POSTDEC1, 0xFB
194C  F0FB     NOP
194E  CFE5     MOVFF POSTDEC1, 0xFA
1950  F0FA     NOP
1952  CFE5     MOVFF POSTDEC1, FSR0H
1954  FFEA     NOP
1956  CFE5     MOVFF POSTDEC1, FSR0
1958  FFE9     NOP
195A  CFE5     MOVFF POSTDEC1, FSR2H
195C  FFDA     NOP
195E  50E5     MOVF POSTDEC1, W, ACCESS
1960  CFE5     MOVFF POSTDEC1, BSR
1962  FFE0     NOP
1964  CFE5     MOVFF POSTDEC1, STATUS
1966  FFD8     NOP
1968  0010     RETFIE 0
350:           
351:           void Clear_All_Buttons(void)
352:           {
353:           	button.B0 = 0;
196A  0103     MOVLB 0x3
196C  91C0     BCF 0xC0, 0, BANKED
354:           	button.B1 = 0;
196E  93C0     BCF 0xC0, 1, BANKED
355:           	button.B2 = 0;
1970  95C0     BCF 0xC0, 2, BANKED
356:           }
1972  0012     RETURN 0
---  /sdd/work/mx320/pyro/p18pyro.X/pyro8722.c  ---------------------------------------------------------
1:             
2:             // PIC18F8722 Configuration Bit Settings
3:             
4:             #include <p18f8722.h>
5:             
6:             // CONFIG1H
7:             #pragma config OSC = HSPLL      // Oscillator Selection bits (HS oscillator, PLL enabled (Clock Frequency = 4 x FOSC1))
8:             #pragma config FCMEN = OFF      // Fail-Safe Clock Monitor Enable bit (Fail-Safe Clock Monitor disabled)
9:             #pragma config IESO = OFF       // Internal/External Oscillator Switchover bit (Two-Speed Start-up disabled)
10:            
11:            // CONFIG2L
12:            #pragma config PWRT = OFF       // Power-up Timer Enable bit (PWRT disabled)
13:            #pragma config BOREN = ON       // Brown-out Reset Enable bits 
14:            #pragma config BORV = 3         // Brown-out Voltage bits (Max setting)
15:            
16:            // CONFIG2H
17:            #pragma config WDT = ON         // Watchdog Timer (WDT enabled)
18:            #pragma config WDTPS = 1024     // Watchdog Timer Postscale Select bits (1:1024)
19:            
20:            // CONFIG3L
21:            #pragma config MODE = MC        // Processor Data Memory Mode Select bits (Microcontroller mode)
22:            #pragma config ADDRBW = ADDR20BIT// Address Bus Width Select bits (20-bit Address Bus)
23:            #pragma config DATABW = DATA16BIT// Data Bus Width Select bit (16-bit External Bus mode)
24:            #pragma config WAIT = OFF       // External Bus Data Wait Enable bit (Wait selections are unavailable for table reads and table writes)
25:            
26:            // CONFIG3H
27:            #pragma config CCP2MX = PORTC   // CCP2 MUX bit (ECCP2 input/output is multiplexed with RC1)
28:            #pragma config ECCPMX = PORTE   // ECCP MUX bit (ECCP1/3 (P1B/P1C/P3B/P3C) are multiplexed onto RE6, RE5, RE4 and RE3 respectively)
29:            #pragma config LPT1OSC = OFF    // Low-Power Timer1 Oscillator Enable bit (Timer1 configured for higher power operation)
30:            #pragma config MCLRE = ON       // MCLR Pin Enable bit (MCLR pin enabled; RG5 input pin disabled)
31:            
32:            // CONFIG4L
33:            #pragma config STVREN = ON      // Stack Full/Underflow Reset Enable bit (Stack full/underflow will cause Reset)
34:            #pragma config LVP = OFF        // Single-Supply ICSP Enable bit (Single-Supply ICSP disabled)
35:            #pragma config BBSIZ = BB2K     // Boot Block Size Select bits (1K word (2 Kbytes) Boot Block size)
36:            #pragma config XINST = ON      // Extended Instruction Set Enable bit (Instruction set extension and Indexed Addressing mode disabled (Legacy mode))
37:            
38:            // CONFIG5L
39:            #pragma config CP0 = OFF        // Code Protection bit Block 0 (Block 0 (000800, 001000 or 002000-003FFFh) not code-protected)
40:            #pragma config CP1 = OFF        // Code Protection bit Block 1 (Block 1 (004000-007FFFh) not code-protected)
41:            #pragma config CP2 = OFF        // Code Protection bit Block 2 (Block 2 (008000-00BFFFh) not code-protected)
42:            #pragma config CP3 = OFF        // Code Protection bit Block 3 (Block 3 (00C000-00FFFFh) not code-protected)
43:            #pragma config CP4 = OFF        // Code Protection bit Block 4 (Block 4 (010000-013FFFh) not code-protected)
44:            #pragma config CP5 = OFF        // Code Protection bit Block 5 (Block 5 (014000-017FFFh) not code-protected)
45:            #pragma config CP6 = OFF        // Code Protection bit Block 6 (Block 6 (01BFFF-018000h) not code-protected)
46:            #pragma config CP7 = OFF        // Code Protection bit Block 7 (Block 7 (01C000-01FFFFh) not code-protected)
47:            
48:            // CONFIG5H
49:            #pragma config CPB = OFF        // Boot Block Code Protection bit (Boot Block (000000-0007FFh) not code-protected)
50:            #pragma config CPD = OFF        // Data EEPROM Code Protection bit (Data EEPROM not code-protected)
51:            
52:            // CONFIG6L
53:            #pragma config WRT0 = OFF       // Write Protection bit Block 0 (Block 0 (000800, 001000 or 002000-003FFFh) not write-protected)
54:            #pragma config WRT1 = OFF       // Write Protection bit Block 1 (Block 1 (004000-007FFFh) not write-protected)
55:            #pragma config WRT2 = OFF       // Write Protection bit Block 2 (Block 2 (008000-00BFFFh) not write-protected)
56:            #pragma config WRT3 = OFF       // Write Protection bit Block 3 (Block 3 (00C000-00FFFFh) not write-protected)
57:            #pragma config WRT4 = OFF       // Write Protection bit Block 4 (Block 4 (010000-013FFFh) not write-protected)
58:            #pragma config WRT5 = OFF       // Write Protection bit Block 5 (Block 5 (014000-017FFFh) not write-protected)
59:            #pragma config WRT6 = OFF       // Write Protection bit Block 6 (Block 6 (01BFFF-018000h) not write-protected)
60:            #pragma config WRT7 = OFF       // Write Protection bit Block 7 (Block 7 (01C000-01FFFFh) not write-protected)
61:            
62:            // CONFIG6H
63:            #pragma config WRTC = OFF       // Configuration Register Write Protection bit (Configuration registers (300000-3000FFh) not write-protected)
64:            #pragma config WRTB = OFF       // Boot Block Write Protection bit (Boot Block (000000-007FFF, 000FFF or 001FFFh) not write-protected)
65:            #pragma config WRTD = OFF       // Data EEPROM Write Protection bit (Data EEPROM not write-protected)
66:            
67:            // CONFIG7L
68:            #pragma config EBTR0 = OFF      // Table Read Protection bit Block 0 (Block 0 (000800, 001000 or 002000-003FFFh) not protected from table reads executed in other blocks)
69:            #pragma config EBTR1 = OFF      // Table Read Protection bit Block 1 (Block 1 (004000-007FFFh) not protected from table reads executed in other blocks)
70:            #pragma config EBTR2 = OFF      // Table Read Protection bit Block 2 (Block 2 (008000-00BFFFh) not protected from table reads executed in other blocks)
71:            #pragma config EBTR3 = OFF      // Table Read Protection bit Block 3 (Block 3 (00C000-00FFFFh) not protected from table reads executed in other blocks)
72:            #pragma config EBTR4 = OFF      // Table Read Protection bit Block 4 (Block 4 (010000-013FFFh) not protected from table reads executed in other blocks)
73:            #pragma config EBTR5 = OFF      // Table Read Protection bit Block 5 (Block 5 (014000-017FFFh) not protected from table reads executed in other blocks)
74:            #pragma config EBTR6 = OFF      // Table Read Protection bit Block 6 (Block 6 (018000-01BFFFh) not protected from table reads executed in other blocks)
75:            #pragma config EBTR7 = OFF      // Table Read Protection bit Block 7 (Block 7 (01C000-01FFFFh) not protected from table reads executed in other blocks)
76:            
77:            // CONFIG7H
78:            #pragma config EBTRB = OFF      // Boot Block Table Read Protection bit (Boot Block (000000-007FFF, 000FFF or 001FFFh) not protected from table reads executed in other blocks)
79:            
80:            #define	__PYRO_C			//	This is the main program
81:            
82:            /*
83:             *
84:             * standard program units:
85:             * Voltage  in (uint32_t/uint16_t) millivolts,
86:             * Current in (int32_t) hundredths of amps
87:             * Watts Power in (uint32_t)
88:             * 
89:             *
90:             * R: structure, real values from measurements
91:             * C: structure, calculated values from measurements or programs
92:             * V: structure, Volatile variables modified in the ISR in a possible non-atomic fashion
93:             * A: structure ADC buffer data
94:             * S: structure SPI buffer data 
95:             * D: structure LCD buffer data
96:             *
97:             * USART2 		is the host comm port 38400
98:             * Timer0		1 second clock
99:             * TImer1		Not used
100:            * Timer2		Not used
101:            * Timer3		work thread , background I/O clock ~20HZ
102:            * TImer4		State machine Period clock ~1khz
103:           
104:            * 0..11 analog channels are active
105:            * PORTA		analog inputs
106:            * PORTB		HID Qencoder and switch inputs
107:            * PORTC		SPI master and load, select outputs
108:            * PORTD		configuration switch input
109:            * PORTE		relays
110:            * PORTF		analog inputs
111:           
112:            * adc8 Ground REF	zero adc charge cap
113:            * cal table with checksum as last data item in adc_cal[]
114:            * PORTH0		run flasher led onboard, 4x20 LCD status panel
115:            * PORTJ		alarm and diag leds
116:            * PORTG		Alarm and Voice outputs
117:            *
118:            *
119:            */
120:           
121:           
122:           /*
123:            *
124:            * This application is designed for use with the
125:            * ET-BASE PIC8722 board, 4*20 LCD display
126:            */
127:           
128:           #include <p18cxxx.h>
129:           #include "xlcd.h"
130:           #include <delays.h>
131:           #include <string.h>
132:           #include <stdlib.h>
133:           #include <stdio.h>
134:           #include <math.h> 
135:           
136:           #include "pyro_defs.h"
137:           #include "pyro.h"
138:           #include "crit.h"
139:           #include "pyro_msg.h"
140:           #include "hwconf.h"
141:           #include "pyro_vector.h"
142:           #include "pyro_shared.h"
143:           #include "daq.h"
144:           #include "ringbufs.h"
145:           #include "mfc.h"
146:           #include "valve.h"
147:           #include "displays.h"
148:           
149:           extern struct mfctype mfc[4], *mfcptr;
150:           extern struct valvetype valves;
151:           
152:           #pragma udata gpr13
153:           far int8_t bootstr2[MESG_W + 1], f1[MESG_W], f2[MESG_W];
154:           #pragma udata gpr1
155:           volatile struct ringBufS_t ring_buf3;
156:           uint8_t HCRIT[CRIT_8], LCRIT[CRIT_8];
157:           float smooth[LPCHANC];
158:           #pragma udata gpr2
159:           volatile struct L_data L;
160:           volatile struct spi_link_type spi_link = {0};
161:           union mcp4822_buf_type mcp4822;
162:           volatile struct ringBufS_t ring_buf5;
163:           #pragma udata gpr3
164:           volatile struct ringBufS_t ring_buf6;
165:           far int8_t hms_string[16], f3[MESG_W];
166:           volatile uint8_t critc_level = 0;
167:           volatile uint8_t TIMERFLAG = FALSE, SYSTEM_STABLE = FALSE, D_UPDATE = FALSE, WDT_TO = FALSE, EEP_ER = FALSE;
168:           #pragma udata gpr4
169:           volatile uint32_t critc_count = 0;
170:           volatile struct ringBufS_t ring_buf4;
171:           #pragma udata gpr5
172:           int8_t sign = ' ';
173:           float lp_speed = 0.0, lp_x = 0.0;
174:           struct V_data V = {0};
175:           const rom int8_t *build_date = __DATE__, *build_time = __TIME__;
176:           #pragma udata gpr6
177:           float t1 = 0.0, t2 = 0.0, t3 = 0.0, t4 = 0.0, t5 = 0.0, t6 = 0.0, t7 = 0.0, t_time = 0.0;
178:           float voltfrak = 0.0;
179:           float ahfrak = 0.0;
180:           #pragma udata gpr7
181:           volatile uint8_t IDLEFLAG = FALSE, knob_to_pot = 0;
182:           int32_t iw = 0, ip = 0;
183:           #pragma udata gpr8
184:           volatile struct ringBufS_t ring_buf1;
185:           #pragma udata gpr9
186:           volatile struct ringBufS_t ring_buf2;
187:           volatile struct knobtype knob1, knob2;
188:           
189:           /* ADC voltage default calibration values  */
190:           uint8_t adc_cal[] = {128, 128, 128, 128, 128, 128, 128, 128, 128, 127, 127, 127, 127, 127, 127, 0};
191:           uint8_t CRITC = 0, LCD_OK = FALSE;
192:           
193:           volatile enum answer_t {
194:           	WAIT_M, YES_M, NO_M
195:           } YNKEY;
196:           
197:           volatile struct QuadEncoderType OldEncoder;
198:           #pragma idata gpr10
199:           uint8_t lcd18 = 200;
200:           volatile struct qeitype qei1;
201:           volatile int32_t slow_timer = 0;
202:           volatile struct buttontype button;
203:           
204:           /* ISR vectors */
205:           #pragma code tick_interrupt = HIGH_VECTOR
206:           
207:           void tick_int(void)
208:           {
209:           	_asm goto tick_handler _endasm // high
0008  EFA8     GOTO 0x1150
000A  F008     NOP
210:           }
000C  0012     RETURN 0
211:           #pragma code
212:           
213:           #pragma code work_interrupt = LOW_VECTOR
214:           
215:           void work_int(void)
216:           {
217:           	_asm goto work_handler _endasm // low
0018  EFE5     GOTO 0x17CA
001A  F00B     NOP
218:           }
001C  0012     RETURN 0
219:           #pragma code
220:           
221:           void DelayFor18TCY(void)
222:           {
223:           	static uint8_t n;
224:           	_asm nop _endasm // asm code to disable compiler optimizations
0074  0000     NOP
225:           	for (n = 0; n < lcd18; n++) Nop(); // works at 200 (slow white) or 24 (fast blue)
0076  0103     MOVLB 0x3
0078  6BC1     CLRF 0xC1, BANKED
007A  0103     MOVLB 0x3
007C  51DE     MOVF 0xDE, W, BANKED
007E  0103     MOVLB 0x3
0080  5DC1     SUBWF 0xC1, W, BANKED
0082  E204     BC 0x8C
0084  0000     NOP
0086  0103     MOVLB 0x3
0088  2BC1     INCF 0xC1, F, BANKED
008A  D7F7     BRA 0x7A
226:           }
008C  0012     RETURN 0
227:           
228:           //------------------------------------------
229:           
230:           void DelayPORXLCD(void) // works with 15
231:           {
232:           	Delay10KTCYx(15); // Delay of 15ms
008E  0E0F     MOVLW 0xF
0090  6EE6     MOVWF POSTINC1, ACCESS
0092  EC23     CALL 0x3E46, 0
0094  F01F     NOP
0096  E941     SUBFSR 1, 0x1
233:           	return;
234:           }
0098  0012     RETURN 0
235:           
236:           //------------------------------------------
237:           
238:           void DelayXLCD(void) // works with 5
239:           {
240:           	Delay10KTCYx(5); // Delay of 5ms
009A  0E05     MOVLW 0x5
009C  6EE6     MOVWF POSTINC1, ACCESS
009E  EC23     CALL 0x3E46, 0
00A0  F01F     NOP
00A2  E941     SUBFSR 1, 0x1
241:           	return;
242:           }
00A4  0012     RETURN 0
243:           
244:           void wdtdelay(uint32_t delay)
00A6  CFD9     MOVFF FSR2, POSTINC1
00A8  FFE6     NOP
00AA  CFE1     MOVFF FSR1, FSR2
00AC  FFD9     NOP
00AE  E985     SUBFSR 2, 0x5
245:           {
246:           	static uint32_t dcount;
247:           	for (dcount = 0; dcount <= delay; dcount++) { // delay a bit
00B0  0103     MOVLB 0x3
00B2  6BC2     CLRF 0xC2, BANKED
00B4  6BC3     CLRF 0xC3, BANKED
00B6  6BC4     CLRF 0xC4, BANKED
00B8  6BC5     CLRF 0xC5, BANKED
00BA  0103     MOVLB 0x3
00BC  51C2     MOVF 0xC2, W, BANKED
00BE  5C00     SUBWF [0x0], W, ACCESS
00C0  51C3     MOVF 0xC3, W, BANKED
00C2  5801     SUBWFB [0x1], W, ACCESS
00C4  51C4     MOVF 0xC4, W, BANKED
00C6  5802     SUBWFB [0x2], W, ACCESS
00C8  51C5     MOVF 0xC5, W, BANKED
00CA  5803     SUBWFB [0x3], W, ACCESS
00CC  E309     BNC 0xE0
00D2  0103     MOVLB 0x3
00D4  2BC2     INCF 0xC2, F, BANKED
00D6  0E00     MOVLW 0x0
00D8  23C3     ADDWFC 0xC3, F, BANKED
00DA  23C4     ADDWFC 0xC4, F, BANKED
00DC  23C5     ADDWFC 0xC5, F, BANKED
00DE  D7ED     BRA 0xBA
248:           		Nop();
00CE  0000     NOP
249:           		ClrWdt(); // reset the WDT timer
00D0  0004     CLRWDT
250:           	};
251:           }
00E0  E941     SUBFSR 1, 0x1
00E2  CFE7     MOVFF INDF1, FSR2
00E4  FFD9     NOP
00E6  0012     RETURN 0
252:           
253:           void wdttime(uint32_t delay) // delay = ~ .05 seconds
00E8  CFD9     MOVFF FSR2, POSTINC1
00EA  FFE6     NOP
00EC  CFE1     MOVFF FSR1, FSR2
00EE  FFD9     NOP
00F0  E985     SUBFSR 2, 0x5
254:           {
255:           	static uint32_t dcount, timetemp, clocks_hz;
256:           	s_crit(HL);
00F2  0E03     MOVLW 0x3
00F4  6EE6     MOVWF POSTINC1, ACCESS
00F6  ECF6     CALL 0x2DEC, 0
00F8  F016     NOP
00FA  E941     SUBFSR 1, 0x1
257:           	dcount = V.clock20;
00FC  C562     MOVFF 0x562, dcount
00FE  F3C6     NOP
0100  C563     MOVFF 0x563, 0x3C7
0102  F3C7     NOP
0104  C564     MOVFF 0x564, 0x3C8
0106  F3C8     NOP
0108  C565     MOVFF 0x565, 0x3C9
010A  F3C9     NOP
258:           	e_crit();
010C  EC42     CALL 0x2E84, 0
010E  F017     NOP
259:           	clocks_hz = dcount + delay;
0110  CFD9     MOVFF FSR2, FSR0
0112  FFE9     NOP
0114  CFDA     MOVFF FSR2H, FSR0H
0116  FFEA     NOP
0118  0103     MOVLB 0x3
011A  51C6     MOVF 0xC6, W, BANKED
011C  24EE     ADDWF POSTINC0, W, ACCESS
011E  0103     MOVLB 0x3
0120  6FCE     MOVWF 0xCE, BANKED
0122  0103     MOVLB 0x3
0124  51C7     MOVF 0xC7, W, BANKED
0126  20EE     ADDWFC POSTINC0, W, ACCESS
0128  0103     MOVLB 0x3
012A  6FCF     MOVWF 0xCF, BANKED
012C  0103     MOVLB 0x3
012E  51C8     MOVF 0xC8, W, BANKED
0130  20EE     ADDWFC POSTINC0, W, ACCESS
0132  0103     MOVLB 0x3
0134  6FD0     MOVWF 0xD0, BANKED
0136  0103     MOVLB 0x3
0138  51C9     MOVF 0xC9, W, BANKED
013A  20EE     ADDWFC POSTINC0, W, ACCESS
013C  0103     MOVLB 0x3
013E  6FD1     MOVWF 0xD1, BANKED
260:           
261:           	do { // wait until delay
262:           		s_crit(HL);
0140  0E03     MOVLW 0x3
0142  6EE6     MOVWF POSTINC1, ACCESS
0144  ECF6     CALL 0x2DEC, 0
0146  F016     NOP
0148  E941     SUBFSR 1, 0x1
263:           		timetemp = V.clock20;
014A  C562     MOVFF 0x562, timetemp
014C  F3CA     NOP
014E  C563     MOVFF 0x563, 0x3CB
0150  F3CB     NOP
0152  C564     MOVFF 0x564, 0x3CC
0154  F3CC     NOP
0156  C565     MOVFF 0x565, 0x3CD
0158  F3CD     NOP
264:           		e_crit();
015A  EC42     CALL 0x2E84, 0
015C  F017     NOP
265:           		ClrWdt();
015E  0004     CLRWDT
266:           	} while (timetemp < clocks_hz);
0160  0ECA     MOVLW 0xCA
0162  6EE9     MOVWF FSR0, ACCESS
0164  0E03     MOVLW 0x3
0166  6EEA     MOVWF FSR0H, ACCESS
0168  0103     MOVLB 0x3
016A  51CE     MOVF 0xCE, W, BANKED
016C  5CEE     SUBWF POSTINC0, W, ACCESS
016E  51CF     MOVF 0xCF, W, BANKED
0170  58EE     SUBWFB POSTINC0, W, ACCESS
0172  51D0     MOVF 0xD0, W, BANKED
0174  58EE     SUBWFB POSTINC0, W, ACCESS
0176  51D1     MOVF 0xD1, W, BANKED
0178  58EE     SUBWFB POSTINC0, W, ACCESS
017A  E3E2     BNC 0x140
267:           }
017C  E941     SUBFSR 1, 0x1
017E  CFE7     MOVFF INDF1, FSR2
0180  FFD9     NOP
0182  0012     RETURN 0
268:           
269:           /* Misc ACSII spinner character generator, stores position for each shape */
270:           int8_t spinners(uint8_t shape, uint8_t reset)
0184  EC6A     CALL 0xED4, 0
0186  F007     NOP
0188  E983     SUBFSR 2, 0x3
018A  E841     ADDFSR 1, 0x1
271:           {
272:           	static uint8_t s[MAX_SHAPES], last_shape = 0;
273:           	int8_t c;
274:           
275:           	if (shape > (MAX_SHAPES - 1)) shape = 0;
018C  5001     MOVF [0x1], W, ACCESS
018E  0805     SUBLW 0x5
0190  E201     BC 0x194
0192  6A01     CLRF [0x1], ACCESS
276:           	if (reset) s[shape] = 0;
0194  5000     MOVF [0x0], W, ACCESS
0196  E003     BZ 0x19E
0198  EC90     CALL 0xF20, 0
019A  F007     NOP
019C  6AEF     CLRF INDF0, ACCESS
277:           	last_shape = shape;
019E  EB01     MOVSF 0x1, 0x3E3
01A0  F3E3     NOP
278:           	c = spin[shape][s[shape]];
01A2  0101     MOVLB 0x1
01A4  0EA8     MOVLW 0xA8
01A6  6FF4     MOVWF spi_buf, BANKED
01A8  0E38     MOVLW 0x38
01AA  6FF5     MOVWF 0xF5, BANKED
01AC  0E00     MOVLW 0x0
01AE  6FF6     MOVWF upper_lower, BANKED
01B0  EC9E     CALL 0xF3C, 0
01B2  F007     NOP
01B4  CFE5     MOVFF POSTDEC1, 0x1F9
01B6  F1F9     NOP
01B8  CFE5     MOVFF POSTDEC1, 0x1F8
01BA  F1F8     NOP
01BC  CFE7     MOVFF INDF1, 0x1F7
01BE  F1F7     NOP
01C0  0101     MOVLB 0x1
01C2  51F4     MOVF spi_buf, W, BANKED
01C4  25F7     ADDWF 0xF7, W, BANKED
01C6  6FF1     MOVWF spi_buf, BANKED
01C8  51F5     MOVF 0xF5, W, BANKED
01CA  21F8     ADDWFC mcp4822_buf, W, BANKED
01CC  6FF2     MOVWF 0xF2, BANKED
01CE  51F6     MOVF upper_lower, W, BANKED
01D0  21F9     ADDWFC 0xF9, W, BANKED
01D2  6FF3     MOVWF data, BANKED
01D4  EC90     CALL 0xF20, 0
01D6  F007     NOP
01D8  CFEF     MOVFF INDF0, 0x1FA
01DA  F1FA     NOP
01DC  6BFB     CLRF 0xFB, BANKED
01DE  6BFC     CLRF 0xFC, BANKED
01E0  51F1     MOVF spi_buf, W, BANKED
01E2  25FA     ADDWF 0xFA, W, BANKED
01E4  6EF3     MOVWF PROD, ACCESS
01E6  51F2     MOVF 0xF2, W, BANKED
01E8  21FB     ADDWFC 0xFB, W, BANKED
01EA  6EF4     MOVWF PRODH, ACCESS
01EC  51F3     MOVF data, W, BANKED
01EE  21FC     ADDWFC 0xFC, W, BANKED
01F0  6EF8     MOVWF TBLPTRU, ACCESS
01F2  CFF4     MOVFF PRODH, TBLPTRH
01F4  FFF7     NOP
01F6  CFF3     MOVFF PROD, TBLPTR
01F8  FFF6     NOP
01FA  0008     TBLRD*
01FC  50F5     MOVF TABLAT, W, ACCESS
01FE  6E03     MOVWF [0x3], ACCESS
0F3C  0E14     MOVLW 0x14
0F3E  6EE6     MOVWF POSTINC1, ACCESS
0F40  6AE6     CLRF POSTINC1, ACCESS
0F42  6AE6     CLRF POSTINC1, ACCESS
0F44  EB01     MOVSF 0x1, 0xFE6
0F46  FFE6     NOP
0F48  6AE6     CLRF POSTINC1, ACCESS
0F4A  6AE6     CLRF POSTINC1, ACCESS
0F4C  EC69     CALL 0x26D2, 0
0F4E  F013     NOP
0F50  52E5     MOVF POSTDEC1, F, ACCESS
0F52  0012     RETURN 0
279:           	if (++s[shape] >= strlenpgm(spin[shape])) s[shape] = 0;
0200  EC90     CALL 0xF20, 0
0202  F007     NOP
0204  2AEF     INCF INDF0, F, ACCESS
0206  CFEF     MOVFF INDF0, __tmp_0
0208  F1F1     NOP
020A  6BF2     CLRF 0xF2, BANKED
020C  6BF3     CLRF data, BANKED
020E  C1F1     MOVFF __tmp_0, POSTINC1
0210  FFE6     NOP
0212  C1F2     MOVFF 0x1F2, POSTINC1
0214  FFE6     NOP
0216  C1F3     MOVFF 0x1F3, POSTINC1
0218  FFE6     NOP
021A  0EA8     MOVLW 0xA8
021C  6FFA     MOVWF 0xFA, BANKED
021E  0E38     MOVLW 0x38
0220  6FFB     MOVWF 0xFB, BANKED
0222  0E00     MOVLW 0x0
0224  6FFC     MOVWF 0xFC, BANKED
0226  EC9E     CALL 0xF3C, 0
0228  F007     NOP
022A  CFE5     MOVFF POSTDEC1, 0x1FF
022C  F1FF     NOP
022E  CFE5     MOVFF POSTDEC1, 0x1FE
0230  F1FE     NOP
0232  CFE7     MOVFF INDF1, 0x1FD
0234  F1FD     NOP
0236  0101     MOVLB 0x1
0238  51FA     MOVF 0xFA, W, BANKED
023A  25FD     ADDWF 0xFD, W, BANKED
023C  6FF7     MOVWF 0xF7, BANKED
023E  51FB     MOVF 0xFB, W, BANKED
0240  21FE     ADDWFC Seed, W, BANKED
0242  6FF8     MOVWF mcp4822_buf, BANKED
0244  51FC     MOVF 0xFC, W, BANKED
0246  21FF     ADDWFC 0xFF, W, BANKED
0248  6FF9     MOVWF 0xF9, BANKED
024A  C1F7     MOVFF 0x1F7, POSTINC1
024C  FFE6     NOP
024E  C1F8     MOVFF 0x1F8, POSTINC1
0250  FFE6     NOP
0252  6EE6     MOVWF POSTINC1, ACCESS
0254  EC04     CALL 0x3608, 0
0256  F01B     NOP
0258  E943     SUBFSR 1, 0x3
025A  52E5     MOVF POSTDEC1, F, ACCESS
025C  CFE7     MOVFF INDF1, 0x1F3
025E  F1F3     NOP
0260  52E5     MOVF POSTDEC1, F, ACCESS
0262  CFE7     MOVFF INDF1, 0x1F2
0264  F1F2     NOP
0266  52E5     MOVF POSTDEC1, F, ACCESS
0268  CFE7     MOVFF INDF1, __tmp_0
026A  F1F1     NOP
026C  C0FA     MOVFF 0xFA, 0x1F4
026E  F1F4     NOP
0270  C0FB     MOVFF 0xFB, 0x1F5
0272  F1F5     NOP
0274  C0FC     MOVFF 0xFC, 0x1F6
0276  F1F6     NOP
0278  0101     MOVLB 0x1
027A  51F4     MOVF spi_buf, W, BANKED
027C  5DF1     SUBWF spi_buf, W, BANKED
027E  51F5     MOVF 0xF5, W, BANKED
0280  59F2     SUBWFB 0xF2, W, BANKED
0282  51F6     MOVF upper_lower, W, BANKED
0284  59F3     SUBWFB data, W, BANKED
0286  E303     BNC 0x28E
0288  EC90     CALL 0xF20, 0
028A  F007     NOP
028C  6AEF     CLRF INDF0, ACCESS
0F20  5001     MOVF [0x1], W, ACCESS
0F22  6AEA     CLRF FSR0H, ACCESS
0F24  0FD2     ADDLW 0xD2
0F26  6EE9     MOVWF FSR0, ACCESS
0F28  0E03     MOVLW 0x3
0F2A  22EA     ADDWFC FSR0H, F, ACCESS
0F2C  0012     RETURN 0
280:           	return c;
028E  5003     MOVF [0x3], W, ACCESS
281:           }
0290  E942     SUBFSR 1, 0x2
0292  CFE7     MOVFF INDF1, FSR2
0294  FFD9     NOP
0296  0012     RETURN 0
282:           
283:           int8_t* hms(uint32_t sec) // convert int32_t (seconds) to time string
0298  EC6A     CALL 0xED4, 0
029A  F007     NOP
029C  ECDD     CALL 0xFBA, 0
0FBA  E985     SUBFSR 2, 0x5
284:           {
285:           	static uint32_t h = 0, m = 0, s = 0;
286:           
287:           	if (sec > MAXSECONDS) sec = MAXSECONDS; // max time in seconds
029E  F007     NOP
02A0  E202     BC 0x2A6
02A2  ECE7     CALL 0xFCE, 0
02A4  F007     NOP
0FBC  5000     MOVF [0x0], W, ACCESS
0FBE  08C0     SUBLW 0xC0
0FC0  0E4E     MOVLW 0x4E
0FC2  5401     SUBFWB [0x1], W, ACCESS
0FC4  0ECF     MOVLW 0xCF
0FC6  5402     SUBFWB [0x2], W, ACCESS
0FC8  0E12     MOVLW 0x12
0FCA  5403     SUBFWB [0x3], W, ACCESS
0FCC  0012     RETURN 0
0FCE  0EC0     MOVLW 0xC0
0FD0  6E00     MOVWF [0x0], ACCESS
0FD2  0E4E     MOVLW 0x4E
0FD4  6E01     MOVWF [0x1], ACCESS
0FD6  0ECF     MOVLW 0xCF
0FD8  6E02     MOVWF [0x2], ACCESS
0FDA  0E12     MOVLW 0x12
0FDC  6E03     MOVWF [0x3], ACCESS
0FDE  0012     RETURN 0
288:           	s = sec;
02A6  EB00     MOVSF 0x0, 0x3EC
02A8  F3EC     NOP
02AA  EB01     MOVSF 0x1, 0x3ED
02AC  F3ED     NOP
02AE  EB02     MOVSF 0x2, 0x3EE
02B0  F3EE     NOP
02B2  EB03     MOVSF 0x3, 0x3EF
02B4  F3EF     NOP
289:           	h = (s / 3600);
02B6  EC97     CALL 0xF2E, 0
02B8  F007     NOP
02BA  ECAA     CALL 0xF54, 0
02BC  F007     NOP
02BE  CFE5     MOVFF POSTDEC1, 0x3E7
02C0  F3E7     NOP
02C2  CFE5     MOVFF POSTDEC1, 0x3E6
02C4  F3E6     NOP
02C6  CFE5     MOVFF POSTDEC1, 0x3E5
02C8  F3E5     NOP
02CA  CFE7     MOVFF INDF1, h
02CC  F3E4     NOP
0F54  D8D4     RCALL __pa_43
0F56  C3EF     MOVFF 0x3EF, POSTINC1
0F58  FFE6     NOP
0F5A  ECC6     CALL 0x258C, 0
0F5C  F012     NOP
0F5E  52E5     MOVF POSTDEC1, F, ACCESS
0F60  0012     RETURN 0
290:           	s = s - (h * 3600);
02CE  EC97     CALL 0xF2E, 0
02D0  F007     NOP
02D2  ECF0     CALL 0xFE0, 0
02D4  F007     NOP
02D6  EC54     CALL 0x10A8, 0
02D8  F008     NOP
02DA  EC38     CALL 0xE70, 0
02DC  F007     NOP
0E70  0EEC     MOVLW 0xEC
0E72  6EE9     MOVWF FSR0, ACCESS
0E74  0E03     MOVLW 0x3
0E76  6EEA     MOVWF FSR0H, ACCESS
0E78  0101     MOVLB 0x1
0E7A  51F1     MOVF spi_buf, W, BANKED
0E7C  5CEE     SUBWF POSTINC0, W, ACCESS
0E7E  0103     MOVLB 0x3
0E80  6FEC     MOVWF 0xEC, BANKED
0E82  0101     MOVLB 0x1
0E84  51F2     MOVF 0xF2, W, BANKED
0E86  58EE     SUBWFB POSTINC0, W, ACCESS
0E88  0103     MOVLB 0x3
0E8A  6FED     MOVWF adc_buf, BANKED
0E8C  0101     MOVLB 0x1
0E8E  51F3     MOVF data, W, BANKED
0E90  58EE     SUBWFB POSTINC0, W, ACCESS
0E92  0103     MOVLB 0x3
0E94  6FEE     MOVWF 0xEE, BANKED
0E96  0101     MOVLB 0x1
0E98  51F4     MOVF spi_buf, W, BANKED
0E9A  58EE     SUBWFB POSTINC0, W, ACCESS
0E9C  0103     MOVLB 0x3
0E9E  6FEF     MOVWF lcd_buf, BANKED
0EA0  0012     RETURN 0
0FE0  C3E4     MOVFF h, POSTINC1
0FE2  FFE6     NOP
0FE4  C3E5     MOVFF 0x3E5, POSTINC1
0FE6  FFE6     NOP
0FE8  C3E6     MOVFF 0x3E6, POSTINC1
0FEA  FFE6     NOP
0FEC  C3E7     MOVFF 0x3E7, POSTINC1
0FEE  FFE6     NOP
0FF0  0012     RETURN 0
291:           	m = (s / 60);
02DE  ECCD     CALL 0xF9A, 0
02E0  F007     NOP
02E2  ECAA     CALL 0xF54, 0
02E4  F007     NOP
02E6  CFE5     MOVFF POSTDEC1, 0x3EB
02E8  F3EB     NOP
02EA  CFE5     MOVFF POSTDEC1, 0x3EA
02EC  F3EA     NOP
02EE  CFE5     MOVFF POSTDEC1, 0x3E9
02F0  F3E9     NOP
02F2  CFE7     MOVFF INDF1, m
02F4  F3E8     NOP
292:           	s = s - (m * 60);
02F6  ECCD     CALL 0xF9A, 0
02F8  F007     NOP
02FA  ECF9     CALL 0xFF2, 0
02FC  F007     NOP
02FE  EC54     CALL 0x10A8, 0
0300  F008     NOP
0302  EC38     CALL 0xE70, 0
0304  F007     NOP
0FF2  C3E8     MOVFF m, POSTINC1
0FF4  FFE6     NOP
0FF6  C3E9     MOVFF 0x3E9, POSTINC1
0FF8  FFE6     NOP
0FFA  C3EA     MOVFF 0x3EA, POSTINC1
0FFC  FFE6     NOP
0FFE  C3EB     MOVFF 0x3EB, POSTINC1
1000  FFE6     NOP
1002  0012     RETURN 0
293:           	sprintf(hms_string, "%01lu:%02lu:%02lu", h, m, s);
0306  EC7F     CALL 0x10FE, 0
0308  F008     NOP
030A  6EE6     MOVWF POSTINC1, ACCESS
030C  ECF9     CALL 0xFF2, 0
030E  F007     NOP
0310  ECF0     CALL 0xFE0, 0
0312  F007     NOP
0314  0EBC     MOVLW 0xBC
0316  6EE6     MOVWF POSTINC1, ACCESS
0318  0E32     MOVLW 0x32
031A  6EE6     MOVWF POSTINC1, ACCESS
031C  0E00     MOVLW 0x0
031E  EC23     CALL 0x1046, 0
0320  F008     NOP
0322  E951     SUBFSR 1, 0x11
1046  6EE6     MOVWF POSTINC1, ACCESS
1048  0E83     MOVLW 0x83
104A  6EE6     MOVWF POSTINC1, ACCESS
104C  0E02     MOVLW 0x2
104E  6EE6     MOVWF POSTINC1, ACCESS
1050  EF90     GOTO 0x3920
1052  F01C     NOP
10FE  C3EC     MOVFF s, POSTINC1
1100  FFE6     NOP
1102  C3ED     MOVFF 0x3ED, POSTINC1
1104  FFE6     NOP
1106  C3EE     MOVFF 0x3EE, POSTINC1
1108  FFE6     NOP
110A  0012     RETURN 0
294:           	return hms_string;
0324  EFB1     GOTO 0xF62
0326  F007     NOP
0F62  0101     MOVLB 0x1
0F64  0E83     MOVLW 0x83
0F66  6FF1     MOVWF spi_buf, BANKED
0F68  0E02     MOVLW 0x2
0F6A  C1F1     MOVFF __tmp_0, PROD
0F6C  FFF3     NOP
0F6E  6EF4     MOVWF PRODH, ACCESS
295:           }
0F70  D097     BRA __pa_36
10A0  E941     SUBFSR 1, 0x1
10A2  CFE7     MOVFF INDF1, FSR2
10A4  FFD9     NOP
10A6  0012     RETURN 0
296:           
297:           int8_t* hm(uint32_t sec) // convert int32_t (seconds) to time string
0328  EC6A     CALL 0xED4, 0
032A  F007     NOP
032C  ECDD     CALL 0xFBA, 0
298:           {
299:           	static uint32_t h = 0, m = 0, s = 0;
300:           	if (sec > MAXSECONDS) sec = MAXSECONDS; // max time in seconds
032E  F007     NOP
0330  E202     BC 0x336
0332  ECE7     CALL 0xFCE, 0
0334  F007     NOP
301:           	s = sec;
0336  EB00     MOVSF 0x0, 0x3F8
0338  F3F8     NOP
033A  EB01     MOVSF 0x1, 0x3F9
033C  F3F9     NOP
033E  EB02     MOVSF 0x2, 0x3FA
0340  F3FA     NOP
0342  EB03     MOVSF 0x3, 0x3FB
0344  F3FB     NOP
302:           	h = (s / 3600);
0346  EC97     CALL 0xF2E, 0
0348  F007     NOP
034A  ECB9     CALL 0xF72, 0
034C  F007     NOP
034E  CFE5     MOVFF POSTDEC1, 0x3F3
0350  F3F3     NOP
0352  CFE5     MOVFF POSTDEC1, 0x3F2
0354  F3F2     NOP
0356  CFE5     MOVFF POSTDEC1, 0x3F1
0358  F3F1     NOP
035A  CFE7     MOVFF INDF1, h
035C  F3F0     NOP
0F72  C3F8     MOVFF s, POSTINC1
0F74  FFE6     NOP
0F76  C3F9     MOVFF 0x3F9, POSTINC1
0F78  FFE6     NOP
0F7A  C3FA     MOVFF 0x3FA, POSTINC1
0F7C  FFE6     NOP
0F7E  C3FB     MOVFF 0x3FB, POSTINC1
0F80  FFE6     NOP
0F82  ECC6     CALL 0x258C, 0
0F84  F012     NOP
0F86  52E5     MOVF POSTDEC1, F, ACCESS
0F88  0012     RETURN 0
303:           	s = s - (h * 3600);
035E  EC97     CALL 0xF2E, 0
0360  F007     NOP
0362  EC02     CALL 0x1004, 0
0364  F008     NOP
0366  EC54     CALL 0x10A8, 0
0368  F008     NOP
036A  EC51     CALL 0xEA2, 0
036C  F007     NOP
0EA2  0EF8     MOVLW 0xF8
0EA4  6EE9     MOVWF FSR0, ACCESS
0EA6  0E03     MOVLW 0x3
0EA8  6EEA     MOVWF FSR0H, ACCESS
0EAA  0101     MOVLB 0x1
0EAC  51F1     MOVF spi_buf, W, BANKED
0EAE  5CEE     SUBWF POSTINC0, W, ACCESS
0EB0  0103     MOVLB 0x3
0EB2  6FF8     MOVWF mcp4822_buf, BANKED
0EB4  0101     MOVLB 0x1
0EB6  51F2     MOVF 0xF2, W, BANKED
0EB8  58EE     SUBWFB POSTINC0, W, ACCESS
0EBA  0103     MOVLB 0x3
0EBC  6FF9     MOVWF 0xF9, BANKED
0EBE  0101     MOVLB 0x1
0EC0  51F3     MOVF data, W, BANKED
0EC2  58EE     SUBWFB POSTINC0, W, ACCESS
0EC4  0103     MOVLB 0x3
0EC6  6FFA     MOVWF 0xFA, BANKED
0EC8  0101     MOVLB 0x1
0ECA  51F4     MOVF spi_buf, W, BANKED
0ECC  58EE     SUBWFB POSTINC0, W, ACCESS
0ECE  0103     MOVLB 0x3
0ED0  6FFB     MOVWF 0xFB, BANKED
0ED2  0012     RETURN 0
0F2E  0E10     MOVLW 0x10
0F30  6EE6     MOVWF POSTINC1, ACCESS
0F32  0E0E     MOVLW 0xE
0F34  6EE6     MOVWF POSTINC1, ACCESS
0F36  6AE6     CLRF POSTINC1, ACCESS
0F38  6AE6     CLRF POSTINC1, ACCESS
0F3A  0012     RETURN 0
1004  C3F0     MOVFF h, POSTINC1
1006  FFE6     NOP
1008  C3F1     MOVFF 0x3F1, POSTINC1
100A  FFE6     NOP
100C  C3F2     MOVFF 0x3F2, POSTINC1
100E  FFE6     NOP
1010  C3F3     MOVFF 0x3F3, POSTINC1
1012  FFE6     NOP
1014  0012     RETURN 0
304:           	m = (s / 60);
036E  ECCD     CALL 0xF9A, 0
0370  F007     NOP
0372  ECB9     CALL 0xF72, 0
0374  F007     NOP
0376  CFE5     MOVFF POSTDEC1, 0x3F7
0378  F3F7     NOP
037A  CFE5     MOVFF POSTDEC1, 0x3F6
037C  F3F6     NOP
037E  CFE5     MOVFF POSTDEC1, 0x3F5
0380  F3F5     NOP
0382  CFE7     MOVFF INDF1, m
0384  F3F4     NOP
305:           	s = s - (m * 60);
0386  ECCD     CALL 0xF9A, 0
0388  F007     NOP
038A  EC0B     CALL 0x1016, 0
038C  F008     NOP
038E  EC54     CALL 0x10A8, 0
0390  F008     NOP
0392  EC51     CALL 0xEA2, 0
0394  F007     NOP
0F9A  0E3C     MOVLW 0x3C
0F9C  6EE6     MOVWF POSTINC1, ACCESS
0F9E  6AE6     CLRF POSTINC1, ACCESS
0FA0  6AE6     CLRF POSTINC1, ACCESS
0FA2  6AE6     CLRF POSTINC1, ACCESS
0FA4  0012     RETURN 0
1016  C3F4     MOVFF m, POSTINC1
1018  FFE6     NOP
101A  C3F5     MOVFF 0x3F5, POSTINC1
101C  FFE6     NOP
101E  C3F6     MOVFF 0x3F6, POSTINC1
1020  FFE6     NOP
1022  C3F7     MOVFF 0x3F7, POSTINC1
1024  FFE6     NOP
1026  0012     RETURN 0
306:           	sprintf(hms_string, "%01lu:%02lu", h, m);
0396  EC0B     CALL 0x1016, 0
0398  F008     NOP
039A  EC02     CALL 0x1004, 0
039C  F008     NOP
039E  0EB0     MOVLW 0xB0
03A0  6EE6     MOVWF POSTINC1, ACCESS
03A2  0E32     MOVLW 0x32
03A4  6EE6     MOVWF POSTINC1, ACCESS
03A6  0E00     MOVLW 0x0
03A8  EC23     CALL 0x1046, 0
03AA  F008     NOP
03AC  E94D     SUBFSR 1, 0xD
307:           	return hms_string;
03AE  EFB1     GOTO 0xF62
03B0  F007     NOP
308:           }
309:           
310:           int16_t ABSI(int16_t i)
03B2  EC6A     CALL 0xED4, 0
03B4  F007     NOP
03B6  E983     SUBFSR 2, 0x3
311:           {
312:           	if (i < 0)
03B8  3401     RLCF [0x1], W, ACCESS
03BA  E30E     BNC 0x3D8
313:           		return -i;
03BC  EB00     MOVSF 0x0, 0x1F1
03BE  F1F1     NOP
03C0  EB01     MOVSF 0x1, 0x1F2
03C2  F1F2     NOP
03C4  0101     MOVLB 0x1
03C6  6DF1     NEGF spi_buf, BANKED
03C8  1FF2     COMF 0xF2, F, BANKED
03CA  0E00     MOVLW 0x0
03CC  23F2     ADDWFC 0xF2, F, BANKED
03CE  C1F1     MOVFF __tmp_0, PROD
03D0  FFF3     NOP
03D2  C1F2     MOVFF 0x1F2, PRODH
03D4  FFF4     NOP
03D6  D004     BRA 0x3E0
314:           	else
315:           		return i;
03D8  EB00     MOVSF 0x0, 0xFF3
03DA  FFF3     NOP
03DC  EB01     MOVSF 0x1, 0xFF4
03DE  FFF4     NOP
316:           }
03E0  EF50     GOTO 0x10A0
03E2  F008     NOP
317:           
318:           int32_t ABSL(int32_t i)
03E4  EC6A     CALL 0xED4, 0
03E6  F007     NOP
03E8  E985     SUBFSR 2, 0x5
319:           {
320:           	if (i < 0)
03EA  3403     RLCF [0x3], W, ACCESS
03EC  E317     BNC 0x41C
321:           		return -i;
03EE  68E6     SETF POSTINC1, ACCESS
03F0  68E6     SETF POSTINC1, ACCESS
03F2  68E6     SETF POSTINC1, ACCESS
03F4  68E6     SETF POSTINC1, ACCESS
03F6  EB00     MOVSF 0x0, 0xFE6
03F8  FFE6     NOP
03FA  EB01     MOVSF 0x1, 0xFE6
03FC  FFE6     NOP
03FE  EB02     MOVSF 0x2, 0xFE6
0400  FFE6     NOP
0402  EB03     MOVSF 0x3, 0xFE6
0404  FFE6     NOP
0406  EC54     CALL 0x10A8, 0
0408  F008     NOP
040A  C1F1     MOVFF __tmp_0, 0xFA
040C  F0FA     NOP
040E  C1F2     MOVFF 0x1F2, 0xFB
0410  F0FB     NOP
0412  C1F3     MOVFF 0x1F3, 0xFC
0414  F0FC     NOP
0416  C1F4     MOVFF 0x1F4, 0xFD
0418  F0FD     NOP
041A  D008     BRA 0x42C
10A8  ECC9     CALL 0x2792, 0
10AA  F013     NOP
10AC  EF15     GOTO 0xE2A
10AE  F007     NOP
322:           	else
323:           		return i;
041C  EB00     MOVSF 0x0, 0xFA
041E  F0FA     NOP
0420  EB01     MOVSF 0x1, 0xFB
0422  F0FB     NOP
0424  EB02     MOVSF 0x2, 0xFC
0426  F0FC     NOP
0428  EB03     MOVSF 0x3, 0xFD
042A  F0FD     NOP
324:           }
042C  EF50     GOTO 0x10A0
042E  F008     NOP
325:           
326:           int8_t* voltfp(uint32_t millvolts, int8_t *strprt) // convert uint32_t (millvolts) to voltage string
0430  EC58     CALL 0x10B0, 0
0432  F008     NOP
10B0  DF11     RCALL __pa_8
10B2  E987     SUBFSR 2, 0x7
327:           {
328:           	voltfrak = (float) millvolts / 1000;
10B4  DED6     RCALL __pa_5
10B6  EC44     CALL 0x2488, 0
10B8  F012     NOP
10BA  EF07     GOTO 0xE0E
10BC  F007     NOP
329:           	iw = (int32_t) ((float) voltfrak);
330:           	ip = (int32_t) ((float) voltfrak * 100) - iw * 100;
0434  EC93     CALL 0x1126, 0
0436  F008     NOP
0438  ECE2     CALL 0xDC4, 0
043A  F006     NOP
1126  0EC8     MOVLW 0xC8
1128  6EE6     MOVWF POSTINC1, ACCESS
112A  0E42     MOVLW 0x42
112C  DF9B     RCALL __pa_32
112E  0E64     MOVLW 0x64
1130  0012     RETURN 0
331:           	sprintf(strprt, "%d.%02d", (int16_t) iw, (int16_t) ip);
043C  EC14     CALL 0x1028, 0
043E  F008     NOP
0440  0EA8     MOVLW 0xA8
0442  6EE6     MOVWF POSTINC1, ACCESS
0444  0E32     MOVLW 0x32
0446  6EE6     MOVWF POSTINC1, ACCESS
0448  0E00     MOVLW 0x0
044A  EC6F     CALL 0xEDE, 0
044C  F007     NOP
044E  E949     SUBFSR 1, 0x9
1028  C5AA     MOVFF ip, POSTINC1
102A  FFE6     NOP
102C  C5AB     MOVFF 0x5AB, POSTINC1
102E  FFE6     NOP
1030  EFA3     GOTO 0x1146
1032  F008     NOP
332:           	return strprt;
0450  EF82     GOTO 0xF04
0452  F007     NOP
333:           }
334:           
335:           int8_t* voltfps(uint32_t millvolts, int8_t *strprt) // convert uint32_t (millvolts) to voltage string (short)
0454  EC58     CALL 0x10B0, 0
0456  F008     NOP
336:           {
337:           	voltfrak = (float) millvolts / 1000;
0E62  6AE6     CLRF POSTINC1, ACCESS
0E64  6AE6     CLRF POSTINC1, ACCESS
0E66  0E7A     MOVLW 0x7A
0E68  6EE6     MOVWF POSTINC1, ACCESS
0E6A  0E44     MOVLW 0x44
0E6C  EF5F     GOTO 0x10BE
0E6E  F008     NOP
338:           	iw = (int32_t) ((float) voltfrak);
339:           	ip = (int32_t) ((float) voltfrak * 10) - iw * 10;
0458  EC8C     CALL 0x1118, 0
045A  F008     NOP
1118  0E20     MOVLW 0x20
111A  6EE6     MOVWF POSTINC1, ACCESS
111C  0E41     MOVLW 0x41
111E  DFA2     RCALL __pa_32
1120  0E0A     MOVLW 0xA
1122  EFE2     GOTO 0xDC4
1124  F006     NOP
340:           	sprintf(strprt, "%d.%01d", (int16_t) iw, (int16_t) ip);
045C  EC14     CALL 0x1028, 0
045E  F008     NOP
0460  0EA0     MOVLW 0xA0
0462  6EE6     MOVWF POSTINC1, ACCESS
0464  0E32     MOVLW 0x32
0466  6EE6     MOVWF POSTINC1, ACCESS
0468  0E00     MOVLW 0x0
046A  EC6F     CALL 0xEDE, 0
046C  F007     NOP
046E  E949     SUBFSR 1, 0x9
0EDE  6EE6     MOVWF POSTINC1, ACCESS
0EE0  EB00     MOVSF 0x0, 0xFE6
0EE2  FFE6     NOP
0EE4  EB01     MOVSF 0x1, 0xFE6
0EE6  FFE6     NOP
0EE8  EF90     GOTO 0x3920
0EEA  F01C     NOP
341:           	return strprt;
0470  EF82     GOTO 0xF04
0472  F007     NOP
342:           }
343:           
344:           int8_t* voltfpi(int32_t millvolts, int8_t *strprt) // convert int32_t (mill volts/watts/current) to string (integer with Kilo)
0474  EC78     CALL 0x10F0, 0
0476  F008     NOP
10F0  DEF1     RCALL __pa_8
10F2  E987     SUBFSR 2, 0x7
345:           {
346:           	sign = ' '; // init sign
10F4  0105     MOVLB 0x5
10F6  0E20     MOVLW 0x20
10F8  6F15     MOVWF 0x15, BANKED
347:           	if (millvolts < 0)
0478  E302     BNC 0x47E
10FA  3405     RLCF [0x5], W, ACCESS
10FC  0012     RETURN 0
348:           		sign = '-';
047A  0E2D     MOVLW 0x2D
047C  6F15     MOVWF 0x15, BANKED
349:           	voltfrak = (float) millvolts / 1000;
047E  EC31     CALL 0xE62, 0
0480  F007     NOP
0482  EC46     CALL 0x248C, 0
0484  F012     NOP
0486  EC07     CALL 0xE0E, 0
0488  F007     NOP
350:           	iw = (int32_t) ((float) voltfrak);
351:           	ip = (int32_t) ((float) voltfrak * 10) - iw * 10;
048A  EC8C     CALL 0x1118, 0
048C  F008     NOP
352:           	if (ABSL(iw) < 1500) {
048E  EC35     CALL 0x106A, 0
0490  F008     NOP
0492  EC76     CALL 0xEEC, 0
0494  F007     NOP
0496  90D8     BCF STATUS, 0, ACCESS
0498  0101     MOVLB 0x1
049A  51F4     MOVF spi_buf, W, BANKED
049C  0A00     XORLW 0x0
049E  E608     BN 0x4B0
04A0  0EDC     MOVLW 0xDC
04A2  5DF1     SUBWF spi_buf, W, BANKED
04A4  0E05     MOVLW 0x5
04A6  59F2     SUBWFB 0xF2, W, BANKED
04A8  0E00     MOVLW 0x0
04AA  59F3     SUBWFB data, W, BANKED
04AC  0E00     MOVLW 0x0
04AE  59F4     SUBWFB spi_buf, W, BANKED
04B0  E219     BC 0x4E4
353:           		sprintf(strprt, "%c%li", sign, ABSL(iw));
04B2  EC35     CALL 0x106A, 0
04B4  F008     NOP
04B6  EC76     CALL 0xEEC, 0
04B8  F007     NOP
04BA  EC87     CALL 0xF0E, 0
04BC  F007     NOP
04BE  C515     MOVFF sign, 0x1F5
04C0  F1F5     NOP
04C2  0101     MOVLB 0x1
04C4  6BF6     CLRF upper_lower, BANKED
04C6  BFF5     BTFSC 0xF5, 7, BANKED
04C8  69F6     SETF upper_lower, BANKED
04CA  C1F5     MOVFF 0x1F5, POSTINC1
04CC  FFE6     NOP
04CE  C1F6     MOVFF 0x1F6, POSTINC1
04D0  FFE6     NOP
04D2  0E9A     MOVLW 0x9A
04D4  6EE6     MOVWF POSTINC1, ACCESS
04D6  0E32     MOVLW 0x32
04D8  6EE6     MOVWF POSTINC1, ACCESS
04DA  0E00     MOVLW 0x0
04DC  EC6F     CALL 0xEDE, 0
04DE  F007     NOP
04E0  E94B     SUBFSR 1, 0xB
106A  D86D     RCALL __pa_49
106C  C5A8     MOVFF 0x5A8, POSTINC1
106E  FFE6     NOP
1070  C5A9     MOVFF 0x5A9, POSTINC1
1072  FFE6     NOP
1074  0012     RETURN 0
1146  C5A6     MOVFF iw, POSTINC1
1148  FFE6     NOP
114A  C5A7     MOVFF 0x5A7, POSTINC1
114C  FFE6     NOP
114E  0012     RETURN 0
354:           	} else {
04E2  D034     BRA 0x54C
355:           		voltfrak = voltfrak / 1000;
04E4  6AE6     CLRF POSTINC1, ACCESS
04E6  6AE6     CLRF POSTINC1, ACCESS
04E8  0E7A     MOVLW 0x7A
04EA  6EE6     MOVWF POSTINC1, ACCESS
04EC  0E44     MOVLW 0x44
04EE  EC2E     CALL 0xE5C, 0
04F0  F007     NOP
04F2  EC07     CALL 0xE0E, 0
04F4  F007     NOP
0E0E  EC0C     CALL 0x2618, 0
0E10  F013     NOP
0E12  52E5     MOVF POSTDEC1, F, ACCESS
0E14  CFE5     MOVFF POSTDEC1, 0x59F
0E16  F59F     NOP
0E18  CFE5     MOVFF POSTDEC1, 0x59E
0E1A  F59E     NOP
0E1C  CFE5     MOVFF POSTDEC1, 0x59D
0E1E  F59D     NOP
0E20  CFE7     MOVFF INDF1, voltfrak
0E22  F59C     NOP
356:           		iw = (int32_t) ((float) voltfrak);
0E24  D956     RCALL __pa_40
0E26  EF42     GOTO 0x1084
0E28  F008     NOP
10D2  C59C     MOVFF voltfrak, POSTINC1
10D4  FFE6     NOP
10D6  C59D     MOVFF 0x59D, POSTINC1
10D8  FFE6     NOP
10DA  C59E     MOVFF 0x59E, POSTINC1
10DC  FFE6     NOP
10DE  C59F     MOVFF 0x59F, POSTINC1
10E0  FFE6     NOP
10E2  0012     RETURN 0
357:           		ip = (int32_t) ((float) voltfrak * 100) - iw * 100;
04F6  EC93     CALL 0x1126, 0
04F8  F008     NOP
04FA  EC86     CALL 0x110C, 0
04FC  F008     NOP
0E5C  6EE6     MOVWF POSTINC1, ACCESS
0E5E  EF69     GOTO 0x10D2
0E60  F008     NOP
1064  DEFB     RCALL __pa_4
1066  EF99     GOTO 0x1132
1068  F008     NOP
110C  DE5B     RCALL __pa_0
358:           		sprintf(strprt, "%c%li.%02lik", sign, ABSL(iw), ABSL(ip));
04FE  C5AC     MOVFF 0x5AC, POSTINC1
0500  FFE6     NOP
0502  6EE6     MOVWF POSTINC1, ACCESS
0504  EC76     CALL 0xEEC, 0
0506  F007     NOP
0508  EC87     CALL 0xF0E, 0
050A  F007     NOP
050C  EC35     CALL 0x106A, 0
050E  F008     NOP
0510  DF69     RCALL ABSL
0512  E944     SUBFSR 1, 0x4
0514  C0FA     MOVFF 0xFA, 0x1F5
0516  F1F5     NOP
0518  C0FB     MOVFF 0xFB, 0x1F6
051A  F1F6     NOP
051C  C0FC     MOVFF 0xFC, 0x1F7
051E  F1F7     NOP
0520  C0FD     MOVFF 0xFD, 0x1F8
0522  F1F8     NOP
0524  EC87     CALL 0xF0E, 0
0526  F007     NOP
0528  C515     MOVFF sign, 0x1F9
052A  F1F9     NOP
052C  0101     MOVLB 0x1
052E  6BFA     CLRF 0xFA, BANKED
0530  BFF9     BTFSC 0xF9, 7, BANKED
0532  69FA     SETF 0xFA, BANKED
0534  C1F9     MOVFF 0x1F9, POSTINC1
0536  FFE6     NOP
0538  C1FA     MOVFF 0x1FA, POSTINC1
053A  FFE6     NOP
053C  0E8D     MOVLW 0x8D
053E  6EE6     MOVWF POSTINC1, ACCESS
0540  0E32     MOVLW 0x32
0542  6EE6     MOVWF POSTINC1, ACCESS
0544  0E00     MOVLW 0x0
0546  EC6F     CALL 0xEDE, 0
0548  F007     NOP
054A  E94F     SUBFSR 1, 0xF
0EEC  ECF2     CALL 0x3E4, 0
0EEE  F001     NOP
0EF0  E944     SUBFSR 1, 0x4
0EF2  C0FA     MOVFF 0xFA, __tmp_0
0EF4  F1F1     NOP
0EF6  C0FB     MOVFF 0xFB, 0x1F2
0EF8  F1F2     NOP
0EFA  C0FC     MOVFF 0xFC, 0x1F3
0EFC  F1F3     NOP
0EFE  C0FD     MOVFF 0xFD, 0x1F4
0F00  F1F4     NOP
0F02  0012     RETURN 0
0F0E  C0FA     MOVFF 0xFA, POSTINC1
0F10  FFE6     NOP
0F12  C0FB     MOVFF 0xFB, POSTINC1
0F14  FFE6     NOP
0F16  C0FC     MOVFF 0xFC, POSTINC1
0F18  FFE6     NOP
0F1A  C0FD     MOVFF 0xFD, POSTINC1
0F1C  FFE6     NOP
0F1E  0012     RETURN 0
110E  C5AA     MOVFF ip, POSTINC1
1110  FFE6     NOP
1112  C5AB     MOVFF 0x5AB, POSTINC1
1114  FFE6     NOP
1116  0012     RETURN 0
359:           	}
360:           	return strprt;
054C  EF82     GOTO 0xF04
054E  F007     NOP
361:           }
362:           
363:           int8_t* ahfp(int32_t millah, int8_t *strprt) // convert int32_t (.1 of Ah) to Ah string
0550  EC78     CALL 0x10F0, 0
0552  F008     NOP
364:           {
365:           	sign = ' '; // init sign
366:           	if (millah < 0)
0554  E302     BNC 0x55A
367:           		sign = '-';
0556  0E2D     MOVLW 0x2D
0558  6F15     MOVWF 0x15, BANKED
368:           	ahfrak = (float) millah / 10;
055A  6AE6     CLRF POSTINC1, ACCESS
055C  6AE6     CLRF POSTINC1, ACCESS
055E  0E20     MOVLW 0x20
0560  6EE6     MOVWF POSTINC1, ACCESS
0562  0E41     MOVLW 0x41
0564  EC5F     CALL 0x10BE, 0
0566  F008     NOP
0568  EC46     CALL 0x248C, 0
056A  F012     NOP
056C  EC0C     CALL 0x2618, 0
056E  F013     NOP
0570  52E5     MOVF POSTDEC1, F, ACCESS
0572  CFE5     MOVFF POSTDEC1, 0x5A3
0574  F5A3     NOP
0576  CFE5     MOVFF POSTDEC1, 0x5A2
0578  F5A2     NOP
057A  CFE5     MOVFF POSTDEC1, 0x5A1
057C  F5A1     NOP
057E  CFE7     MOVFF INDF1, ahfrak
0580  F5A0     NOP
10BE  6EE6     MOVWF POSTINC1, ACCESS
10C0  EB02     MOVSF 0x2, 0xFE6
10C2  FFE6     NOP
10C4  EB03     MOVSF 0x3, 0xFE6
10C6  FFE6     NOP
10C8  EB04     MOVSF 0x4, 0xFE6
10CA  FFE6     NOP
10CC  EB05     MOVSF 0x5, 0xFE6
10CE  FFE6     NOP
10D0  0012     RETURN 0
369:           	iw = (int32_t) ((float) ahfrak);
0582  EC1A     CALL 0x1034, 0
0584  F008     NOP
0586  EC42     CALL 0x1084, 0
0588  F008     NOP
1034  C5A0     MOVFF ahfrak, POSTINC1
1036  FFE6     NOP
1038  C5A1     MOVFF 0x5A1, POSTINC1
103A  FFE6     NOP
103C  C5A2     MOVFF 0x5A2, POSTINC1
103E  FFE6     NOP
1040  C5A3     MOVFF 0x5A3, POSTINC1
1042  FFE6     NOP
1044  0012     RETURN 0
1084  EC6B     CALL 0x24D6, 0
1086  F012     NOP
1088  52E5     MOVF POSTDEC1, F, ACCESS
108A  CFE5     MOVFF POSTDEC1, 0x5A9
108C  F5A9     NOP
108E  CFE5     MOVFF POSTDEC1, 0x5A8
1090  F5A8     NOP
1092  CFE5     MOVFF POSTDEC1, 0x5A7
1094  F5A7     NOP
1096  CFE7     MOVFF INDF1, iw
1098  F5A6     NOP
370:           	ip = (int32_t) ((float) ahfrak * 10) - iw * 10;
058A  0E20     MOVLW 0x20
058C  6EE6     MOVWF POSTINC1, ACCESS
058E  0E41     MOVLW 0x41
0590  6EE6     MOVWF POSTINC1, ACCESS
0592  EC1A     CALL 0x1034, 0
0594  F008     NOP
0596  EC99     CALL 0x1132, 0
0598  F008     NOP
059A  0E0A     MOVLW 0xA
059C  EC86     CALL 0x110C, 0
059E  F008     NOP
0DC4  6EE6     MOVWF POSTINC1, ACCESS
0DC6  6AE6     CLRF POSTINC1, ACCESS
0DC8  6AE6     CLRF POSTINC1, ACCESS
0DCA  6AE6     CLRF POSTINC1, ACCESS
0DCC  D94E     RCALL __pa_33
0DCE  ECC9     CALL 0x2792, 0
0DD0  F013     NOP
0DD2  52E5     MOVF POSTDEC1, F, ACCESS
0DD4  CFE5     MOVFF POSTDEC1, 0x1F8
0DD6  F1F8     NOP
0DD8  CFE5     MOVFF POSTDEC1, 0x1F7
0DDA  F1F7     NOP
0DDC  CFE5     MOVFF POSTDEC1, 0x1F6
0DDE  F1F6     NOP
0DE0  CFE7     MOVFF INDF1, 0x1F5
0DE2  F1F5     NOP
0DE4  0101     MOVLB 0x1
0DE6  51F5     MOVF 0xF5, W, BANKED
0DE8  5DF1     SUBWF spi_buf, W, BANKED
0DEA  0105     MOVLB 0x5
0DEC  6FAA     MOVWF 0xAA, BANKED
0DEE  0101     MOVLB 0x1
0DF0  51F6     MOVF upper_lower, W, BANKED
0DF2  59F2     SUBWFB 0xF2, W, BANKED
0DF4  0105     MOVLB 0x5
0DF6  6FAB     MOVWF 0xAB, BANKED
0DF8  0101     MOVLB 0x1
0DFA  51F7     MOVF 0xF7, W, BANKED
0DFC  59F3     SUBWFB data, W, BANKED
0DFE  0105     MOVLB 0x5
0E00  6FAC     MOVWF 0xAC, BANKED
0E02  0101     MOVLB 0x1
0E04  51F8     MOVF mcp4822_buf, W, BANKED
0E06  59F4     SUBWFB spi_buf, W, BANKED
0E08  0105     MOVLB 0x5
0E0A  6FAD     MOVWF 0xAD, BANKED
0E0C  0012     RETURN 0
0E2A  52E5     MOVF POSTDEC1, F, ACCESS
0E2C  CFE5     MOVFF POSTDEC1, 0x1F4
0E2E  F1F4     NOP
0E30  CFE5     MOVFF POSTDEC1, 0x1F3
0E32  F1F3     NOP
0E34  CFE5     MOVFF POSTDEC1, 0x1F2
0E36  F1F2     NOP
0E38  CFE7     MOVFF INDF1, __tmp_0
0E3A  F1F1     NOP
0E3C  0012     RETURN 0
109A  6AE6     CLRF POSTINC1, ACCESS
109C  6AE6     CLRF POSTINC1, ACCESS
109E  0012     RETURN 0
1132  EC1A     CALL 0x2834, 0
1134  F014     NOP
1136  EC6B     CALL 0x24D6, 0
1138  F012     NOP
113A  EF15     GOTO 0xE2A
113C  F007     NOP
371:           	sprintf(strprt, "%c%d.%01d", sign, ABSI(iw), ABSI(ip));
05A0  EC2A     CALL 0x1054, 0
05A2  F008     NOP
05A4  ECA3     CALL 0x1146, 0
05A6  F008     NOP
05A8  EC2A     CALL 0x1054, 0
05AA  F008     NOP
05AC  C515     MOVFF sign, __tmp_0
05AE  F1F1     NOP
05B0  0101     MOVLB 0x1
05B2  6BF2     CLRF 0xF2, BANKED
05B4  BFF1     BTFSC spi_buf, 7, BANKED
05B6  69F2     SETF 0xF2, BANKED
05B8  C1F1     MOVFF __tmp_0, POSTINC1
05BA  FFE6     NOP
05BC  C1F2     MOVFF 0x1F2, POSTINC1
05BE  FFE6     NOP
05C0  0E83     MOVLW 0x83
05C2  6EE6     MOVWF POSTINC1, ACCESS
05C4  0E32     MOVLW 0x32
05C6  6EE6     MOVWF POSTINC1, ACCESS
05C8  0E00     MOVLW 0x0
05CA  EC6F     CALL 0xEDE, 0
05CC  F007     NOP
05CE  E94B     SUBFSR 1, 0xB
1054  ECD9     CALL 0x3B2, 0
1056  F001     NOP
1058  E942     SUBFSR 1, 0x2
105A  CFF3     MOVFF PROD, POSTINC1
105C  FFE6     NOP
105E  CFF4     MOVFF PRODH, POSTINC1
1060  FFE6     NOP
1062  0012     RETURN 0
372:           	return strprt;
05D0  EF82     GOTO 0xF04
05D2  F007     NOP
0F04  EB00     MOVSF 0x0, 0xFF3
0F06  FFF3     NOP
0F08  EB01     MOVSF 0x1, 0xFF4
0F0A  FFF4     NOP
373:           }
0F0C  D0C9     BRA __pa_36
374:           
375:           void term_time(void)
376:           {
377:           
378:           }
05D4  0012     RETURN 0
379:           
380:           /*	lp_filters
381:           	0
382:           	1
383:           	2
384:           	3	current
385:           	4	currentin
386:           	5	currentcharger
387:           	6
388:           	7
389:           	8
390:            *	9
391:            */
392:           float lp_filter(float new, int16_t bn, int16_t slow) // low pass filter, slow rate of change for new, LPCHANC channels, slow/fast select (1) to zero channel
05D6  EC6A     CALL 0xED4, 0
05D8  F007     NOP
05DA  E989     SUBFSR 2, 0x9
393:           {
394:           	// smooth,lp_speed,lp_x is a udata global array to save stack space
395:           
396:           	if (bn > LPCHANC)
05DC  3403     RLCF [0x3], W, ACCESS
05DE  E20E     BC 0x5FC
05E0  5002     MOVF [0x2], W, ACCESS
05E2  0808     SUBLW 0x8
05E4  0E00     MOVLW 0x0
05E6  5403     SUBFWB [0x3], W, ACCESS
05E8  E209     BC 0x5FC
397:           		return new;
05EA  EB04     MOVSF 0x4, 0xFA
05EC  F0FA     NOP
05EE  EB05     MOVSF 0x5, 0xFB
05F0  F0FB     NOP
05F2  EB06     MOVSF 0x6, 0xFC
05F4  F0FC     NOP
05F6  EB07     MOVSF 0x7, 0xFD
05F8  F0FD     NOP
05FA  D05D     BRA 0x6B6
398:           	if (slow) {
05FC  5000     MOVF [0x0], W, ACCESS
05FE  1001     IORWF [0x1], W, ACCESS
0600  E009     BZ 0x614
399:           		lp_speed = 0.06;
0602  0105     MOVLB 0x5
0604  0E8F     MOVLW 0x8F
0606  6F16     MOVWF 0x16, BANKED
0608  0EC2     MOVLW 0xC2
060A  6F17     MOVWF romstring, BANKED
060C  0E75     MOVLW 0x75
060E  6F18     MOVWF 0x18, BANKED
0610  0E3D     MOVLW 0x3D
400:           	} else {
0612  D006     BRA 0x620
401:           		lp_speed = 0.250;
0614  0105     MOVLB 0x5
0616  6B16     CLRF 0x16, BANKED
0618  6B17     CLRF romstring, BANKED
061A  0E80     MOVLW 0x80
061C  6F18     MOVWF 0x18, BANKED
061E  0E3E     MOVLW 0x3E
0620  6F19     MOVWF 0x19, BANKED
402:           	}
403:           	lp_x = ((smooth[bn]*100.0) + (((new * 100.0)-(smooth[bn]*100.0)) * lp_speed)) / 100.0;
0622  EC3B     CALL 0x1076, 0
0624  F008     NOP
0626  C516     MOVFF lp_speed, POSTINC1
0628  FFE6     NOP
062A  C517     MOVFF 0x517, POSTINC1
062C  FFE6     NOP
062E  C518     MOVFF 0x518, POSTINC1
0630  FFE6     NOP
0632  C519     MOVFF 0x519, POSTINC1
0634  FFE6     NOP
0636  EC9F     CALL 0x113E, 0
0638  F008     NOP
063A  EC3B     CALL 0x1076, 0
063C  F008     NOP
063E  EB04     MOVSF 0x4, 0xFE6
0640  FFE6     NOP
0642  EB05     MOVSF 0x5, 0xFE6
0644  FFE6     NOP
0646  EB06     MOVSF 0x6, 0xFE6
0648  FFE6     NOP
064A  EB07     MOVSF 0x7, 0xFE6
064C  FFE6     NOP
064E  EC1A     CALL 0x2834, 0
0650  F014     NOP
0652  ECF3     CALL 0x21E6, 0
0654  F010     NOP
0656  EC1A     CALL 0x2834, 0
0658  F014     NOP
065A  EC9F     CALL 0x113E, 0
065C  F008     NOP
065E  ECF5     CALL 0x21EA, 0
0660  F010     NOP
0662  EC0C     CALL 0x2618, 0
0664  F013     NOP
0666  52E5     MOVF POSTDEC1, F, ACCESS
0668  CFE5     MOVFF POSTDEC1, 0x51D
066A  F51D     NOP
066C  CFE5     MOVFF POSTDEC1, 0x51C
066E  F51C     NOP
0670  CFE5     MOVFF POSTDEC1, 0x51B
0672  F51B     NOP
0674  CFE7     MOVFF INDF1, lp_x
0676  F51A     NOP
0FA6  CFEE     MOVFF POSTINC0, POSTINC1
0FA8  FFE6     NOP
0FAA  CFEE     MOVFF POSTINC0, POSTINC1
0FAC  FFE6     NOP
0FAE  CFEE     MOVFF POSTINC0, POSTINC1
0FB0  FFE6     NOP
0FB2  CFEE     MOVFF POSTINC0, POSTINC1
0FB4  FFE6     NOP
0FB6  EF1A     GOTO 0x2834
0FB8  F014     NOP
1076  6AE6     CLRF POSTINC1, ACCESS
1078  6AE6     CLRF POSTINC1, ACCESS
107A  0EC8     MOVLW 0xC8
107C  6EE6     MOVWF POSTINC1, ACCESS
107E  0E42     MOVLW 0x42
1080  6EE6     MOVWF POSTINC1, ACCESS
1082  0012     RETURN 0
113E  DF9B     RCALL __pa_34
1140  DE7E     RCALL __pa_3
1142  EFD3     GOTO 0xFA6
1144  F007     NOP
404:           	smooth[bn] = lp_x;
0678  DBE2     RCALL __pa_3
067A  C51A     MOVFF lp_x, POSTINC0
067C  FFEE     NOP
067E  C51B     MOVFF 0x51B, POSTINC0
0680  FFEE     NOP
0682  C51C     MOVFF 0x51C, POSTINC0
0684  FFEE     NOP
0686  C51D     MOVFF 0x51D, POSTINC0
0688  FFEE     NOP
405:           	if (slow == (-1)) { // reset and return zero
068A  1C00     COMF [0x0], W, ACCESS
068C  E10C     BNZ 0x6A6
068E  1C01     COMF [0x1], W, ACCESS
0690  E10A     BNZ 0x6A6
406:           		lp_x = 0.0;
0692  0105     MOVLB 0x5
0694  6B1A     CLRF ramstring, BANKED
0696  6B1B     CLRF 0x1B, BANKED
0698  6B1C     CLRF n, BANKED
069A  6B1D     CLRF 0x1D, BANKED
407:           		smooth[bn] = 0.0;
069C  DBD0     RCALL __pa_3
069E  6AEE     CLRF POSTINC0, ACCESS
06A0  6AEE     CLRF POSTINC0, ACCESS
06A2  6AEE     CLRF POSTINC0, ACCESS
06A4  6AEE     CLRF POSTINC0, ACCESS
0E3E  EB02     MOVSF 0x2, 0xFE9
0E40  FFE9     NOP
0E42  EB03     MOVSF 0x3, 0xFEA
0E44  FFEA     NOP
0E46  90D8     BCF STATUS, 0, ACCESS
0E48  36E9     RLCF FSR0, F, ACCESS
0E4A  36EA     RLCF FSR0H, F, ACCESS
0E4C  90D8     BCF STATUS, 0, ACCESS
0E4E  36E9     RLCF FSR0, F, ACCESS
0E50  36EA     RLCF FSR0H, F, ACCESS
0E52  0E93     MOVLW 0x93
0E54  26E9     ADDWF FSR0, F, ACCESS
0E56  0E06     MOVLW 0x6
0E58  22EA     ADDWFC FSR0H, F, ACCESS
0E5A  0012     RETURN 0
408:           	}
409:           	return lp_x;
06A6  C51A     MOVFF lp_x, 0xFA
06A8  F0FA     NOP
06AA  C51B     MOVFF 0x51B, 0xFB
06AC  F0FB     NOP
06AE  C51C     MOVFF 0x51C, 0xFC
06B0  F0FC     NOP
06B2  C51D     MOVFF 0x51D, 0xFD
06B4  F0FD     NOP
410:           }
06B6  EF50     GOTO 0x10A0
06B8  F008     NOP
411:           
412:           void init_lcd(void)
413:           {
414:           	lcd18 = 200;
06BA  0103     MOVLB 0x3
06BC  0EC8     MOVLW 0xC8
06BE  6FDE     MOVWF 0xDE, BANKED
415:           	wdtdelay(50000); // delay for power related LCD setup glitch
06C0  0E50     MOVLW 0x50
06C2  6EE6     MOVWF POSTINC1, ACCESS
06C4  0EC3     MOVLW 0xC3
06C6  ECC5     CALL 0xF8A, 0
06C8  F007     NOP
0F8A  6EE6     MOVWF POSTINC1, ACCESS
0F8C  D8AB     RCALL __pa_41
10E4  6AE6     CLRF POSTINC1, ACCESS
10E6  6AE6     CLRF POSTINC1, ACCESS
10E8  EC53     CALL 0xA6, 0
10EA  F000     NOP
10EC  E944     SUBFSR 1, 0x4
10EE  0012     RETURN 0
416:           	OpenXLCD(FOUR_BIT & LINES_5X7);
0F8E  0E2B     MOVLW 0x2B
0F90  6EE6     MOVWF POSTINC1, ACCESS
0F92  EC37     CALL 0x366E, 0
0F94  F01B     NOP
0F96  E941     SUBFSR 1, 0x1
0F98  0012     RETURN 0
417:           	while (BusyXLCD());
06CA  ECD2     CALL 0x3FA4, 0
06CC  F01F     NOP
06CE  0900     IORLW 0x0
06D0  E1FC     BNZ 0x6CA
418:           	wdtdelay(10000); // delay for power related LCD setup glitch
06D2  0E10     MOVLW 0x10
06D4  6EE6     MOVWF POSTINC1, ACCESS
06D6  0E27     MOVLW 0x27
06D8  ECC5     CALL 0xF8A, 0
06DA  F007     NOP
419:           	OpenXLCD(FOUR_BIT & LINES_5X7);
420:           	while (BusyXLCD());
06DC  ECD2     CALL 0x3FA4, 0
06DE  F01F     NOP
06E0  0900     IORLW 0x0
06E2  E1FC     BNZ 0x6DC
421:           	WriteCmdXLCD(0xc); // blink, cursor off
06E4  0E0C     MOVLW 0xC
06E6  6EE6     MOVWF POSTINC1, ACCESS
06E8  ECF0     CALL 0x37E0, 0
06EA  F01B     NOP
06EC  E941     SUBFSR 1, 0x1
422:           	while (BusyXLCD());
06EE  ECD2     CALL 0x3FA4, 0
06F0  F01F     NOP
06F2  0900     IORLW 0x0
06F4  E1FC     BNZ 0x6EE
423:           	WriteCmdXLCD(0x1); // clear screen
06F6  0E01     MOVLW 0x1
06F8  6EE6     MOVWF POSTINC1, ACCESS
06FA  ECF0     CALL 0x37E0, 0
06FC  F01B     NOP
06FE  E941     SUBFSR 1, 0x1
424:           	wdtdelay(10000);
0700  0E10     MOVLW 0x10
0702  6EE6     MOVWF POSTINC1, ACCESS
0704  0E27     MOVLW 0x27
0706  6EE6     MOVWF POSTINC1, ACCESS
0708  EC72     CALL 0x10E4, 0
070A  F008     NOP
425:           	LCD_OK = TRUE;
070C  0105     MOVLB 0x5
070E  0E01     MOVLW 0x1
0710  6FBF     MOVWF 0xBF, BANKED
426:           }
0712  0012     RETURN 0
427:           
428:           /*
429:            * bit set/reset
430:            */
431:           void bitmap_e(uint8_t slot, uint8_t state)
0714  DBDF     RCALL __pa_8
0716  E983     SUBFSR 2, 0x3
0ED4  CFD9     MOVFF FSR2, POSTINC1
0ED6  FFE6     NOP
0ED8  CFE1     MOVFF FSR1, FSR2
0EDA  FFD9     NOP
0EDC  0012     RETURN 0
432:           {
433:           	if (state)
0718  5000     MOVF [0x0], W, ACCESS
071A  E00B     BZ 0x732
434:           		LATE |= 0x01 << slot;
071C  0E01     MOVLW 0x1
071E  EB01     MOVSF 0x1, 0xFF3
0720  FFF3     NOP
0722  5201     MOVF [0x1], F, ACCESS
0724  E004     BZ 0x72E
0726  90D8     BCF STATUS, 0, ACCESS
0728  36E8     RLCF WREG, F, ACCESS
072A  06F3     DECF PROD, F, ACCESS
072C  E1FC     BNZ 0x726
072E  128D     IORWF LATE, F, ACCESS
435:           	else
0730  D00B     BRA 0x748
436:           		LATE &= ~(0x01 << slot);
0732  0E01     MOVLW 0x1
0734  EB01     MOVSF 0x1, 0xFF3
0736  FFF3     NOP
0738  5201     MOVF [0x1], F, ACCESS
073A  E004     BZ 0x744
073C  90D8     BCF STATUS, 0, ACCESS
073E  36E8     RLCF WREG, F, ACCESS
0740  06F3     DECF PROD, F, ACCESS
0742  E1FC     BNZ 0x73C
0744  1CE8     COMF WREG, W, ACCESS
0746  168D     ANDWF LATE, F, ACCESS
437:           }
0748  EF50     GOTO 0x10A0
074A  F008     NOP
438:           
439:           /*
440:            * LEDS are ON with zero, ON=0, OFF=1
441:            */
442:           void fade_up_leds(void)
074C  DBC3     RCALL __pa_8
074E  E981     SUBFSR 2, 0x1
0750  E850     ADDFSR 1, 0x10
443:           {
444:           	uint8_t numbers[] = {0, 1, 3, 7, 15, 31, 63, 127, 255}, l;
0752  6A01     CLRF [0x1], ACCESS
0754  0E01     MOVLW 0x1
0756  6E02     MOVWF [0x2], ACCESS
0758  0E03     MOVLW 0x3
075A  6E03     MOVWF [0x3], ACCESS
075C  0E07     MOVLW 0x7
075E  6E04     MOVWF [0x4], ACCESS
0760  0E0F     MOVLW 0xF
0762  6E05     MOVWF [0x5], ACCESS
0764  0E1F     MOVLW 0x1F
0766  6E06     MOVWF [0x6], ACCESS
0768  0E3F     MOVLW 0x3F
076A  6E07     MOVWF [0x7], ACCESS
076C  0E7F     MOVLW 0x7F
076E  6E08     MOVWF [0x8], ACCESS
0770  6809     SETF [0x9], ACCESS
445:           	int16_t i, j, k;
446:           
447:           
448:           	for (l = 0; l <= 1; l++) {
0772  6A0A     CLRF [0xA], ACCESS
0774  500A     MOVF [0xA], W, ACCESS
0776  0801     SUBLW 0x1
0778  E358     BNC 0x82A
0826  2A0A     INCF [0xA], F, ACCESS
0828  D7A5     BRA 0x774
449:           		k = 200;
077A  0EC8     MOVLW 0xC8
077C  6E0F     MOVWF [0xF], ACCESS
077E  6A10     CLRF [0x10], ACCESS
450:           		j = 0;
0780  6A0D     CLRF [0xD], ACCESS
0782  6A0E     CLRF [0xE], ACCESS
451:           		while (j < 300 && k > 0) {
0784  90D8     BCF STATUS, 0, ACCESS
0786  500E     MOVF [0xE], W, ACCESS
0788  E604     BN 0x792
078A  0E2C     MOVLW 0x2C
078C  5C0D     SUBWF [0xD], W, ACCESS
078E  0E01     MOVLW 0x1
0790  580E     SUBWFB [0xE], W, ACCESS
0792  E23B     BC 0x80A
0794  3410     RLCF [0x10], W, ACCESS
0796  E239     BC 0x80A
0798  500F     MOVF [0xF], W, ACCESS
079A  0800     SUBLW 0x0
079C  0E00     MOVLW 0x0
079E  5410     SUBFWB [0x10], W, ACCESS
07A0  E234     BC 0x80A
0808  D7BD     BRA 0x784
452:           			for (i = 0; i < j; i++) {
07A2  6A0B     CLRF [0xB], ACCESS
07A4  6A0C     CLRF [0xC], ACCESS
07A6  340E     RLCF [0xE], W, ACCESS
07A8  500C     MOVF [0xC], W, ACCESS
07AA  180E     XORWF [0xE], W, ACCESS
07AC  E604     BN 0x7B6
07AE  500D     MOVF [0xD], W, ACCESS
07B0  5C0B     SUBWF [0xB], W, ACCESS
07B2  500E     MOVF [0xE], W, ACCESS
07B4  580C     SUBWFB [0xC], W, ACCESS
07B6  E20E     BC 0x7D4
07CC  2A0B     INCF [0xB], F, ACCESS
07CE  0E00     MOVLW 0x0
07D0  220C     ADDWFC [0xC], F, ACCESS
07D2  D7E9     BRA 0x7A6
453:           				bitmap_e(l, ON);
07B8  6AE6     CLRF POSTINC1, ACCESS
07BA  EB0A     MOVSF 0xA, 0xFE6
07BC  FFE6     NOP
07BE  DFAA     RCALL bitmap_e
07C0  E942     SUBFSR 1, 0x2
454:           				wdtdelay(1); // short delay function
07C2  0E01     MOVLW 0x1
07C4  6EE6     MOVWF POSTINC1, ACCESS
07C6  6AE6     CLRF POSTINC1, ACCESS
07C8  EC72     CALL 0x10E4, 0
07CA  F008     NOP
455:           			}
456:           			for (i = 0; i < k; i++) {
07D4  6A0B     CLRF [0xB], ACCESS
07D6  6A0C     CLRF [0xC], ACCESS
07D8  3410     RLCF [0x10], W, ACCESS
07DA  500C     MOVF [0xC], W, ACCESS
07DC  1810     XORWF [0x10], W, ACCESS
07DE  E604     BN 0x7E8
07E0  500F     MOVF [0xF], W, ACCESS
07E2  5C0B     SUBWF [0xB], W, ACCESS
07E4  5010     MOVF [0x10], W, ACCESS
07E6  580C     SUBWFB [0xC], W, ACCESS
07E8  E20A     BC 0x7FE
07F6  2A0B     INCF [0xB], F, ACCESS
07F8  0E00     MOVLW 0x0
07FA  220C     ADDWFC [0xC], F, ACCESS
07FC  D7ED     BRA 0x7D8
457:           				bitmap_e(l, OFF);
07EA  0E01     MOVLW 0x1
07EC  6EE6     MOVWF POSTINC1, ACCESS
07EE  EB0A     MOVSF 0xA, 0xFE6
07F0  FFE6     NOP
07F2  DF90     RCALL bitmap_e
07F4  E942     SUBFSR 1, 0x2
458:           			}
459:           			j++;
07FE  2A0D     INCF [0xD], F, ACCESS
0800  0E00     MOVLW 0x0
0802  220E     ADDWFC [0xE], F, ACCESS
460:           			k--;
0804  060F     DECF [0xF], F, ACCESS
0806  5A10     SUBWFB [0x10], F, ACCESS
461:           		}
462:           		LATE = ~numbers[l + 1]; // flip the bits for my setup
080A  0101     MOVLB 0x1
080C  50D9     MOVF FSR2, W, ACCESS
080E  0F01     ADDLW 0x1
0810  6FF1     MOVWF spi_buf, BANKED
0812  CFDA     MOVFF FSR2H, 0x1F2
0814  F1F2     NOP
0816  280A     INCF [0xA], W, ACCESS
0818  6AEA     CLRF FSR0H, ACCESS
081A  25F1     ADDWF spi_buf, W, BANKED
081C  6EE9     MOVWF FSR0, ACCESS
081E  50DA     MOVF FSR2H, W, ACCESS
0820  22EA     ADDWFC FSR0H, F, ACCESS
0822  1CEF     COMF INDF0, W, ACCESS
0824  6E8D     MOVWF LATE, ACCESS
463:           	}
464:           }
082A  E951     SUBFSR 1, 0x11
082C  CFE7     MOVFF INDF1, FSR2
082E  FFD9     NOP
0830  0012     RETURN 0
465:           
466:           void main(void) // Lets Party
0832  CFD9     MOVFF FSR2, POSTINC1
0834  FFE6     NOP
0836  CFE1     MOVFF FSR1, FSR2
0838  FFD9     NOP
083A  E981     SUBFSR 2, 0x1
083C  E84C     ADDFSR 1, 0xC
467:           {
468:           	static uint32_t z;
469:           	static union adc_buf_type adc_buf;
470:           	uint16_t dac1, dac2 = 5000;
083E  0E88     MOVLW 0x88
0840  6E03     MOVWF [0x3], ACCESS
0842  0E13     MOVLW 0x13
0844  6E04     MOVWF [0x4], ACCESS
471:           	uint32_t dtime1, dtime2;
472:           
473:           
474:           #ifdef	__18F8722
475:           	config_pic(PIC_8722); // configure all controller hardware to the correct settings and ports
0846  0E12     MOVLW 0x12
0848  6EE6     MOVWF POSTINC1, ACCESS
084A  0E22     MOVLW 0x22
084C  6EE6     MOVWF POSTINC1, ACCESS
084E  EC72     CALL 0x32E4, 0
0850  F019     NOP
0852  E942     SUBFSR 1, 0x2
476:           #endif
477:           
478:           #ifdef	__18F8722
479:           	start_pic(PIC_8722); // configure external hardware to the correct startup conditions
0854  0E12     MOVLW 0x12
0856  6EE6     MOVWF POSTINC1, ACCESS
0858  0E22     MOVLW 0x22
085A  6EE6     MOVWF POSTINC1, ACCESS
085C  EC1C     CALL 0x3438, 0
085E  F01A     NOP
0860  E942     SUBFSR 1, 0x2
480:           #endif
481:           
482:           	init_lcd();
0862  DF2B     RCALL init_lcd
483:           	fade_up_leds();
0864  DF73     RCALL fade_up_leds
484:           
485:           #ifdef	__18F8722
486:           	if (STKPTRbits.STKFUL) {
0866  AEFC     BTFSS STKPTR, 7, ACCESS
0868  D014     BRA 0x892
487:           		STKPTRbits.STKFUL = 0;
086A  9EFC     BCF STKPTR, 7, ACCESS
488:           		putrs2USART("\r\n");
086C  0E80     MOVLW 0x80
086E  6EE6     MOVWF POSTINC1, ACCESS
0870  0E32     MOVLW 0x32
0872  6EE6     MOVWF POSTINC1, ACCESS
0874  0E00     MOVLW 0x0
0876  6EE6     MOVWF POSTINC1, ACCESS
0878  EC8F     CALL 0x3B1E, 0
087A  F01D     NOP
087C  E943     SUBFSR 1, 0x3
489:           		term_time();
087E  DEAA     RCALL term_time
490:           		putrs2USART("\x1b[7m Restart from Stack Full. \x1b[0m\r\n");
0880  0E5B     MOVLW 0x5B
0882  6EE6     MOVWF POSTINC1, ACCESS
0884  0E32     MOVLW 0x32
0886  6EE6     MOVWF POSTINC1, ACCESS
0888  0E00     MOVLW 0x0
088A  6EE6     MOVWF POSTINC1, ACCESS
088C  EC8F     CALL 0x3B1E, 0
088E  F01D     NOP
0890  E943     SUBFSR 1, 0x3
491:           	}
492:           	if (STKPTRbits.STKUNF) {
0892  ACFC     BTFSS STKPTR, 6, ACCESS
0894  D014     BRA 0x8BE
493:           		STKPTRbits.STKUNF = 0;
0896  9CFC     BCF STKPTR, 6, ACCESS
494:           		putrs2USART("\r\n");
0898  0E80     MOVLW 0x80
089A  6EE6     MOVWF POSTINC1, ACCESS
089C  0E32     MOVLW 0x32
089E  6EE6     MOVWF POSTINC1, ACCESS
08A0  0E00     MOVLW 0x0
08A2  6EE6     MOVWF POSTINC1, ACCESS
08A4  EC8F     CALL 0x3B1E, 0
08A6  F01D     NOP
08A8  E943     SUBFSR 1, 0x3
495:           		term_time();
08AA  DE94     RCALL term_time
496:           		putrs2USART("\x1b[7m Restart from Stack Underflow. \x1b[0m\r\n");
08AC  0E31     MOVLW 0x31
08AE  6EE6     MOVWF POSTINC1, ACCESS
08B0  0E32     MOVLW 0x32
08B2  6EE6     MOVWF POSTINC1, ACCESS
08B4  0E00     MOVLW 0x0
08B6  6EE6     MOVWF POSTINC1, ACCESS
08B8  EC8F     CALL 0x3B1E, 0
08BA  F01D     NOP
08BC  E943     SUBFSR 1, 0x3
497:           	}
498:           #endif
499:           
500:           	if (WDT_TO) {
08BE  0105     MOVLB 0x5
08C0  510F     MOVF k, W, BANKED
08C2  E013     BZ 0x8EA
501:           		putrs2USART("\r\n");
08C4  0E80     MOVLW 0x80
08C6  6EE6     MOVWF POSTINC1, ACCESS
08C8  0E32     MOVLW 0x32
08CA  6EE6     MOVWF POSTINC1, ACCESS
08CC  0E00     MOVLW 0x0
08CE  6EE6     MOVWF POSTINC1, ACCESS
08D0  EC8F     CALL 0x3B1E, 0
08D2  F01D     NOP
08D4  E943     SUBFSR 1, 0x3
502:           		term_time();
08D6  DE7E     RCALL term_time
503:           		putrs2USART("\x1b[7m Restart from Watchdog Timer. \x1b[0m\r\n");
08D8  0E08     MOVLW 0x8
08DA  6EE6     MOVWF POSTINC1, ACCESS
08DC  0E32     MOVLW 0x32
08DE  6EE6     MOVWF POSTINC1, ACCESS
08E0  0E00     MOVLW 0x0
08E2  6EE6     MOVWF POSTINC1, ACCESS
08E4  EC8F     CALL 0x3B1E, 0
08E6  F01D     NOP
08E8  E943     SUBFSR 1, 0x3
504:           	}
505:           
506:           	if (EEP_ER) {
08EA  0105     MOVLB 0x5
08EC  5110     MOVF size, W, BANKED
08EE  E013     BZ 0x916
507:           		putrs2USART("\r\n");
08F0  0E80     MOVLW 0x80
08F2  6EE6     MOVWF POSTINC1, ACCESS
08F4  0E32     MOVLW 0x32
08F6  6EE6     MOVWF POSTINC1, ACCESS
08F8  0E00     MOVLW 0x0
08FA  6EE6     MOVWF POSTINC1, ACCESS
08FC  EC8F     CALL 0x3B1E, 0
08FE  F01D     NOP
0900  E943     SUBFSR 1, 0x3
508:           		term_time();
0902  DE68     RCALL term_time
509:           		putrs2USART("\x1b[7m Possible EEPROM write error. \x1b[0m\r\n");
0904  0EDF     MOVLW 0xDF
0906  6EE6     MOVWF POSTINC1, ACCESS
0908  0E31     MOVLW 0x31
090A  6EE6     MOVWF POSTINC1, ACCESS
090C  0E00     MOVLW 0x0
090E  6EE6     MOVWF POSTINC1, ACCESS
0910  EC8F     CALL 0x3B1E, 0
0912  F01D     NOP
0914  E943     SUBFSR 1, 0x3
510:           	}
511:           
512:           	/* state machine setups */
513:           	L.adc_chan = 0;
0916  0104     MOVLB 0x4
0918  6B01     CLRF adc_val, BANKED
091A  6B02     CLRF addr, BANKED
514:           
515:           	/* setup the link buffers first */
516:           	L.rx1b = &ring_buf1;
091C  0104     MOVLB 0x4
091E  0E60     MOVLW 0x60
0920  6F33     MOVWF 0x33, BANKED
0922  0E00     MOVLW 0x0
0924  6F34     MOVWF 0x34, BANKED
517:           	L.tx1b = &ring_buf2;
0926  0104     MOVLB 0x4
0928  0E00     MOVLW 0x0
092A  6F35     MOVWF 0x35, BANKED
092C  0E03     MOVLW 0x3
092E  6F36     MOVWF 0x36, BANKED
518:           	L.rx2b = &ring_buf3;
0930  0104     MOVLB 0x4
0932  0E00     MOVLW 0x0
0934  6F37     MOVWF 0x37, BANKED
0936  0E06     MOVLW 0x6
0938  6F38     MOVWF 0x38, BANKED
519:           	L.tx2b = &ring_buf4;
093A  0104     MOVLB 0x4
093C  0E00     MOVLW 0x0
093E  6F39     MOVWF 0x39, BANKED
0940  0E08     MOVLW 0x8
0942  6F3A     MOVWF 0x3A, BANKED
520:           	spi_link.tx1b = &ring_buf5;
0944  0105     MOVLB 0x5
0946  0E3D     MOVLW 0x3D
0948  6F03     MOVWF ret, BANKED
094A  0E04     MOVLW 0x4
094C  6F04     MOVWF count, BANKED
521:           	spi_link.rx1b = &ring_buf6;
094E  0105     MOVLB 0x5
0950  0E00     MOVLW 0x0
0952  6F05     MOVWF data, BANKED
0954  0E02     MOVLW 0x2
0956  6F06     MOVWF mfc, BANKED
522:           
523:           	ringBufS_init(L.rx1b); // adc rx buffer
0958  C433     MOVFF 0x433, POSTINC1
095A  FFE6     NOP
095C  C434     MOVFF 0x434, POSTINC1
095E  FFE6     NOP
0960  EC19     CALL 0x2C32, 0
0962  F016     NOP
0964  E942     SUBFSR 1, 0x2
524:           	ringBufS_init(L.tx1b); // lcd tx buffer
0966  C435     MOVFF 0x435, POSTINC1
0968  FFE6     NOP
096A  C436     MOVFF 0x436, POSTINC1
096C  FFE6     NOP
096E  EC19     CALL 0x2C32, 0
0970  F016     NOP
0972  E942     SUBFSR 1, 0x2
525:           	ringBufS_init(L.rx2b); // rs232 rx buffer
0974  C437     MOVFF 0x437, POSTINC1
0976  FFE6     NOP
0978  C438     MOVFF 0x438, POSTINC1
097A  FFE6     NOP
097C  EC19     CALL 0x2C32, 0
097E  F016     NOP
0980  E942     SUBFSR 1, 0x2
526:           	ringBufS_init(L.tx2b); // rs232 tx buffer
0982  C439     MOVFF 0x439, POSTINC1
0984  FFE6     NOP
0986  C43A     MOVFF 0x43A, POSTINC1
0988  FFE6     NOP
098A  EC19     CALL 0x2C32, 0
098C  F016     NOP
098E  E942     SUBFSR 1, 0x2
527:           	ringBufS_init(spi_link.tx1b); // spi tx buffer
0990  C503     MOVFF 0x503, POSTINC1
0992  FFE6     NOP
0994  C504     MOVFF 0x504, POSTINC1
0996  FFE6     NOP
0998  EC19     CALL 0x2C32, 0
099A  F016     NOP
099C  E942     SUBFSR 1, 0x2
528:           	ringBufS_init(spi_link.rx1b); // spi rx buffer
099E  C505     MOVFF 0x505, POSTINC1
09A0  FFE6     NOP
09A2  C506     MOVFF 0x506, POSTINC1
09A4  FFE6     NOP
09A6  EC19     CALL 0x2C32, 0
09A8  F016     NOP
09AA  E942     SUBFSR 1, 0x2
529:           
530:           	/* valve setup */
531:           	valve_config();
09AC  EC2D     CALL 0x345A, 0
09AE  F01A     NOP
532:           	
533:           	/*
534:           	 * MFC setup
535:           	 */
536:           
537:           	mfcptr = &mfc[AIR_MFC];
09B0  0102     MOVLB 0x2
09B2  0E00     MOVLW 0x0
09B4  6FEA     MOVWF data_ptr, BANKED
09B6  0E07     MOVLW 0x7
09B8  6FEB     MOVWF 0xEB, BANKED
538:           	mfc_config();
09BA  ECC5     CALL 0x298A, 0
09BC  F014     NOP
539:           
540:           	/*      Work thread start */
541:           	start_workerthread();
09BE  EC2C     CALL 0x3458, 0
09C0  F01A     NOP
542:           
543:           	SYSTEM_STABLE = TRUE;
09C2  0105     MOVLB 0x5
09C4  0E01     MOVLW 0x1
09C6  6F0D     MOVWF j, BANKED
544:           	srand((uint16_t) 1957); // set random seed
09C8  0EA5     MOVLW 0xA5
09CA  6EE6     MOVWF POSTINC1, ACCESS
09CC  0E07     MOVLW 0x7
09CE  6EE6     MOVWF POSTINC1, ACCESS
09D0  EC8B     CALL 0x3D16, 0
09D2  F01E     NOP
09D4  E942     SUBFSR 1, 0x2
545:           	putrsXLCD("Pyro MFC Control");
09D6  0ECE     MOVLW 0xCE
09D8  6EE6     MOVWF POSTINC1, ACCESS
09DA  0E31     MOVLW 0x31
09DC  6EE6     MOVWF POSTINC1, ACCESS
09DE  0E00     MOVLW 0x0
09E0  6EE6     MOVWF POSTINC1, ACCESS
09E2  EC03     CALL 0x3C06, 0
09E4  F01E     NOP
09E6  E943     SUBFSR 1, 0x3
546:           
547:           	dtime1 = V.clock20;
09E8  0105     MOVLB 0x5
09EA  5162     MOVF 0x62, W, BANKED
09EC  6E05     MOVWF [0x5], ACCESS
09EE  5163     MOVF 0x63, W, BANKED
09F0  6E06     MOVWF [0x6], ACCESS
09F2  5164     MOVF 0x64, W, BANKED
09F4  6E07     MOVWF [0x7], ACCESS
09F6  5165     MOVF 0x65, W, BANKED
09F8  6E08     MOVWF [0x8], ACCESS
548:           	dtime2 = V.clock20;
09FA  0105     MOVLB 0x5
09FC  5162     MOVF 0x62, W, BANKED
09FE  6E09     MOVWF [0x9], ACCESS
0A00  5163     MOVF 0x63, W, BANKED
0A02  6E0A     MOVWF [0xA], ACCESS
0A04  5164     MOVF 0x64, W, BANKED
0A06  6E0B     MOVWF [0xB], ACCESS
0A08  5165     MOVF 0x65, W, BANKED
0A0A  6E0C     MOVWF [0xC], ACCESS
549:           	/* Loop forever */
550:           	while (TRUE) {
0DBA  D628     BRA 0xA0C
551:           		ClrWdt(); // reset the WDT timer
0A0C  0004     CLRWDT
552:           		if (ringBufS_empty(L.rx1b)) {
0A0E  C433     MOVFF 0x433, POSTINC1
0A10  FFE6     NOP
0A12  C434     MOVFF 0x434, POSTINC1
0A14  FFE6     NOP
0A16  EC26     CALL 0x2C4C, 0
0A18  F016     NOP
0A1A  E942     SUBFSR 1, 0x2
0A1C  0900     IORLW 0x0
0A1E  E101     BNZ 0xA22
0A20  D0F1     BRA 0xC04
553:           			if (V.clock20 > dtime1 + 10) { // ~5hz display update freq
0A22  EB05     MOVSF 0x5, 0x1F1
0A24  F1F1     NOP
0A26  EB06     MOVSF 0x6, 0x1F2
0A28  F1F2     NOP
0A2A  EB07     MOVSF 0x7, 0x1F3
0A2C  F1F3     NOP
0A2E  EB08     MOVSF 0x8, 0x1F4
0A30  F1F4     NOP
0A32  0E0A     MOVLW 0xA
0A34  0101     MOVLB 0x1
0A36  27F1     ADDWF spi_buf, F, BANKED
0A38  0E00     MOVLW 0x0
0A3A  0101     MOVLB 0x1
0A3C  23F2     ADDWFC 0xF2, F, BANKED
0A3E  0E00     MOVLW 0x0
0A40  0101     MOVLB 0x1
0A42  23F3     ADDWFC data, F, BANKED
0A44  0E00     MOVLW 0x0
0A46  0101     MOVLB 0x1
0A48  23F4     ADDWFC spi_buf, F, BANKED
0A4A  0E62     MOVLW 0x62
0A4C  6EE9     MOVWF FSR0, ACCESS
0A4E  0E05     MOVLW 0x5
0A50  6EEA     MOVWF FSR0H, ACCESS
0A52  50EE     MOVF POSTINC0, W, ACCESS
0A54  0101     MOVLB 0x1
0A56  5DF1     SUBWF spi_buf, W, BANKED
0A58  50EE     MOVF POSTINC0, W, ACCESS
0A5A  59F2     SUBWFB 0xF2, W, BANKED
0A5C  50EE     MOVF POSTINC0, W, ACCESS
0A5E  59F3     SUBWFB data, W, BANKED
0A60  50EE     MOVF POSTINC0, W, ACCESS
0A62  59F4     SUBWFB spi_buf, W, BANKED
0A64  E301     BNC 0xA68
0A66  D0CD     BRA 0xC02
554:           				voltfp(L.adc_val[0], f1); // analog control input 0
0A68  0E51     MOVLW 0x51
0A6A  6EE6     MOVWF POSTINC1, ACCESS
0A6C  0E01     MOVLW 0x1
0A6E  6EE6     MOVWF POSTINC1, ACCESS
0A70  C403     MOVFF 0x403, POSTINC1
0A72  FFE6     NOP
0A74  C404     MOVFF 0x404, POSTINC1
0A76  FFE6     NOP
0A78  C405     MOVFF 0x405, POSTINC1
0A7A  FFE6     NOP
0A7C  C406     MOVFF 0x406, POSTINC1
0A7E  FFE6     NOP
0A80  DCD7     RCALL voltfp
0A82  E946     SUBFSR 1, 0x6
555:           				voltfp(L.adc_val[2], f2); // mfc readback 0
0A84  0EA1     MOVLW 0xA1
0A86  6EE6     MOVWF POSTINC1, ACCESS
0A88  0E01     MOVLW 0x1
0A8A  6EE6     MOVWF POSTINC1, ACCESS
0A8C  C40B     MOVFF 0x40B, POSTINC1
0A8E  FFE6     NOP
0A90  C40C     MOVFF 0x40C, POSTINC1
0A92  FFE6     NOP
0A94  C40D     MOVFF 0x40D, POSTINC1
0A96  FFE6     NOP
0A98  C40E     MOVFF 0x40E, POSTINC1
0A9A  FFE6     NOP
0A9C  DCC9     RCALL voltfp
0A9E  E946     SUBFSR 1, 0x6
556:           				voltfp(L.adc_val[3], f3); // mfc setpoint 0
0AA0  0E93     MOVLW 0x93
0AA2  6EE6     MOVWF POSTINC1, ACCESS
0AA4  0E02     MOVLW 0x2
0AA6  6EE6     MOVWF POSTINC1, ACCESS
0AA8  C40F     MOVFF 0x40F, POSTINC1
0AAA  FFE6     NOP
0AAC  C410     MOVFF 0x410, POSTINC1
0AAE  FFE6     NOP
0AB0  C411     MOVFF 0x411, POSTINC1
0AB2  FFE6     NOP
0AB4  C412     MOVFF 0x412, POSTINC1
0AB6  FFE6     NOP
0AB8  DCBB     RCALL voltfp
0ABA  E946     SUBFSR 1, 0x6
557:           				sprintf(bootstr2, "%sV %sV %sV                        ", f1, f3, f2);
0ABC  0EA1     MOVLW 0xA1
0ABE  6EE6     MOVWF POSTINC1, ACCESS
0AC0  0E01     MOVLW 0x1
0AC2  6EE6     MOVWF POSTINC1, ACCESS
0AC4  0E93     MOVLW 0x93
0AC6  6EE6     MOVWF POSTINC1, ACCESS
0AC8  0E02     MOVLW 0x2
0ACA  6EE6     MOVWF POSTINC1, ACCESS
0ACC  0E51     MOVLW 0x51
0ACE  6EE6     MOVWF POSTINC1, ACCESS
0AD0  0E01     MOVLW 0x1
0AD2  6EE6     MOVWF POSTINC1, ACCESS
0AD4  0EAA     MOVLW 0xAA
0AD6  6EE6     MOVWF POSTINC1, ACCESS
0AD8  0E31     MOVLW 0x31
0ADA  6EE6     MOVWF POSTINC1, ACCESS
0ADC  0E00     MOVLW 0x0
0ADE  6EE6     MOVWF POSTINC1, ACCESS
0AE0  0E00     MOVLW 0x0
0AE2  6EE6     MOVWF POSTINC1, ACCESS
0AE4  0E01     MOVLW 0x1
0AE6  6EE6     MOVWF POSTINC1, ACCESS
0AE8  EC90     CALL 0x3920, 0
0AEA  F01C     NOP
0AEC  E94B     SUBFSR 1, 0xB
558:           				DLED_4 = HIGH;
0AEE  8891     BSF LATJ, 4, ACCESS
559:           				lcd_display_line(bootstr2, LL2);
0AF0  0E40     MOVLW 0x40
0AF2  6EE6     MOVWF POSTINC1, ACCESS
0AF4  0E00     MOVLW 0x0
0AF6  6EE6     MOVWF POSTINC1, ACCESS
0AF8  0E01     MOVLW 0x1
0AFA  6EE6     MOVWF POSTINC1, ACCESS
0AFC  ECEA     CALL 0x3DD4, 0
0AFE  F01E     NOP
0B00  E943     SUBFSR 1, 0x3
560:           				sprintf(bootstr2, "%u %u %u %d                          ", L.adc_raw[0], L.adc_raw[3], L.adc_raw[2], (int16_t) (L.adc_raw[3] - L.adc_raw[2]));
0B02  0104     MOVLB 0x4
0B04  5127     MOVF 0x27, W, BANKED
0B06  0104     MOVLB 0x4
0B08  5D29     SUBWF 0x29, W, BANKED
0B0A  0101     MOVLB 0x1
0B0C  6FF1     MOVWF spi_buf, BANKED
0B0E  0104     MOVLB 0x4
0B10  5128     MOVF 0x28, W, BANKED
0B12  0104     MOVLB 0x4
0B14  592A     SUBWFB 0x2A, W, BANKED
0B16  0101     MOVLB 0x1
0B18  6FF2     MOVWF 0xF2, BANKED
0B1A  C1F1     MOVFF __tmp_0, POSTINC1
0B1C  FFE6     NOP
0B1E  C1F2     MOVFF 0x1F2, POSTINC1
0B20  FFE6     NOP
0B22  C427     MOVFF 0x427, POSTINC1
0B24  FFE6     NOP
0B26  C428     MOVFF 0x428, POSTINC1
0B28  FFE6     NOP
0B2A  C429     MOVFF 0x429, POSTINC1
0B2C  FFE6     NOP
0B2E  C42A     MOVFF 0x42A, POSTINC1
0B30  FFE6     NOP
0B32  C423     MOVFF 0x423, POSTINC1
0B34  FFE6     NOP
0B36  C424     MOVFF 0x424, POSTINC1
0B38  FFE6     NOP
0B3A  0E84     MOVLW 0x84
0B3C  6EE6     MOVWF POSTINC1, ACCESS
0B3E  0E31     MOVLW 0x31
0B40  6EE6     MOVWF POSTINC1, ACCESS
0B42  0E00     MOVLW 0x0
0B44  6EE6     MOVWF POSTINC1, ACCESS
0B46  0E00     MOVLW 0x0
0B48  6EE6     MOVWF POSTINC1, ACCESS
0B4A  0E01     MOVLW 0x1
0B4C  6EE6     MOVWF POSTINC1, ACCESS
0B4E  EC90     CALL 0x3920, 0
0B50  F01C     NOP
0B52  E94D     SUBFSR 1, 0xD
561:           				lcd_display_line(bootstr2, LL3);
0B54  0E14     MOVLW 0x14
0B56  6EE6     MOVWF POSTINC1, ACCESS
0B58  0E00     MOVLW 0x0
0B5A  6EE6     MOVWF POSTINC1, ACCESS
0B5C  0E01     MOVLW 0x1
0B5E  6EE6     MOVWF POSTINC1, ACCESS
0B60  ECEA     CALL 0x3DD4, 0
0B62  F01E     NOP
0B64  E943     SUBFSR 1, 0x3
562:           				sprintf(f1, "%lu %lu SLM 0                              ", mfc[COLOR1_MFC].mfc_integ_current_mass / MFC_INTEG,
0BA2  0EB0     MOVLW 0xB0
0BA4  6EE6     MOVWF POSTINC1, ACCESS
0BA6  0E04     MOVLW 0x4
0BA8  6EE6     MOVWF POSTINC1, ACCESS
0BAA  6AE6     CLRF POSTINC1, ACCESS
0BAC  6AE6     CLRF POSTINC1, ACCESS
0BAE  C771     MOVFF 0x771, POSTINC1
0BB0  FFE6     NOP
0BB2  C772     MOVFF 0x772, POSTINC1
0BB4  FFE6     NOP
0BB6  C773     MOVFF 0x773, POSTINC1
0BB8  FFE6     NOP
0BBA  C774     MOVFF 0x774, POSTINC1
0BBC  FFE6     NOP
0BBE  ECC6     CALL 0x258C, 0
0BC0  F012     NOP
0BC2  0E58     MOVLW 0x58
0BC4  6EE6     MOVWF POSTINC1, ACCESS
0BC6  0E31     MOVLW 0x31
0BC8  6EE6     MOVWF POSTINC1, ACCESS
0BCA  0E00     MOVLW 0x0
0BCC  6EE6     MOVWF POSTINC1, ACCESS
0BCE  0E51     MOVLW 0x51
0BD0  6EE6     MOVWF POSTINC1, ACCESS
0BD2  0E01     MOVLW 0x1
0BD4  6EE6     MOVWF POSTINC1, ACCESS
563:           					(uint32_t) ((float) (mfc[COLOR1_MFC].mfc_integ_current_mass / MFC_INTEG) * mfc[COLOR1_MFC].scale_out));
0B66  C765     MOVFF 0x765, POSTINC1
0B68  FFE6     NOP
0B6A  C766     MOVFF 0x766, POSTINC1
0B6C  FFE6     NOP
0B6E  C767     MOVFF 0x767, POSTINC1
0B70  FFE6     NOP
0B72  C768     MOVFF 0x768, POSTINC1
0B74  FFE6     NOP
0B76  0EB0     MOVLW 0xB0
0B78  6EE6     MOVWF POSTINC1, ACCESS
0B7A  0E04     MOVLW 0x4
0B7C  6EE6     MOVWF POSTINC1, ACCESS
0B7E  6AE6     CLRF POSTINC1, ACCESS
0B80  6AE6     CLRF POSTINC1, ACCESS
0B82  C771     MOVFF 0x771, POSTINC1
0B84  FFE6     NOP
0B86  C772     MOVFF 0x772, POSTINC1
0B88  FFE6     NOP
0B8A  C773     MOVFF 0x773, POSTINC1
0B8C  FFE6     NOP
0B8E  C774     MOVFF 0x774, POSTINC1
0B90  FFE6     NOP
0B92  ECC6     CALL 0x258C, 0
0B94  F012     NOP
0B96  EC44     CALL 0x2488, 0
0B98  F012     NOP
0B9A  EC1A     CALL 0x2834, 0
0B9C  F014     NOP
0B9E  EC6B     CALL 0x24D6, 0
0BA0  F012     NOP
0BD6  EC90     CALL 0x3920, 0
0BD8  F01C     NOP
0BDA  E94D     SUBFSR 1, 0xD
564:           				lcd_display_line(f1, LL4);
0BDC  0E54     MOVLW 0x54
0BDE  6EE6     MOVWF POSTINC1, ACCESS
0BE0  0E51     MOVLW 0x51
0BE2  6EE6     MOVWF POSTINC1, ACCESS
0BE4  0E01     MOVLW 0x1
0BE6  6EE6     MOVWF POSTINC1, ACCESS
0BE8  ECEA     CALL 0x3DD4, 0
0BEA  F01E     NOP
0BEC  E943     SUBFSR 1, 0x3
565:           				DLED_4 = LOW;
0BEE  9891     BCF LATJ, 4, ACCESS
566:           				dtime1 = V.clock20;
0BF0  0105     MOVLB 0x5
0BF2  5162     MOVF 0x62, W, BANKED
0BF4  6E05     MOVWF [0x5], ACCESS
0BF6  5163     MOVF 0x63, W, BANKED
0BF8  6E06     MOVWF [0x6], ACCESS
0BFA  5164     MOVF 0x64, W, BANKED
0BFC  6E07     MOVWF [0x7], ACCESS
0BFE  5165     MOVF 0x65, W, BANKED
0C00  6E08     MOVWF [0x8], ACCESS
567:           			}
568:           		} else {
0C02  D0C0     BRA 0xD84
569:           			z = 0;
0C04  0103     MOVLB 0x3
0C06  6BD8     CLRF 0xD8, BANKED
0C08  6BD9     CLRF 0xD9, BANKED
0C0A  6BDA     CLRF 0xDA, BANKED
0C0C  6BDB     CLRF 0xDB, BANKED
570:           			while (!ringBufS_empty(L.rx1b)) {
0C0E  C433     MOVFF 0x433, POSTINC1
0C10  FFE6     NOP
0C12  C434     MOVFF 0x434, POSTINC1
0C14  FFE6     NOP
0C16  EC26     CALL 0x2C4C, 0
0C18  F016     NOP
0C1A  E942     SUBFSR 1, 0x2
0C1C  0900     IORLW 0x0
0C1E  E12C     BNZ 0xC78
0C76  D7CB     BRA 0xC0E
571:           				adc_buf.buf = ringBufS_get(L.rx1b); // get the analog voltages			
0C20  C433     MOVFF 0x433, POSTINC1
0C22  FFE6     NOP
0C24  C434     MOVFF 0x434, POSTINC1
0C26  FFE6     NOP
0C28  EC3B     CALL 0x2C76, 0
0C2A  F016     NOP
0C2C  E942     SUBFSR 1, 0x2
0C2E  CFF3     MOVFF PROD, adc_buf
0C30  F3DC     NOP
0C32  CFF4     MOVFF PRODH, 0x3DD
0C34  F3DD     NOP
572:           				ADC_Update(adc_buf.buf & ADC_MASK, adc_buf.map.index);
0C36  0103     MOVLB 0x3
0C38  51DD     MOVF 0xDD, W, BANKED
0C3A  0BE0     ANDLW 0xE0
0C3C  42E8     RRNCF WREG, F, ACCESS
0C3E  42E8     RRNCF WREG, F, ACCESS
0C40  42E8     RRNCF WREG, F, ACCESS
0C42  42E8     RRNCF WREG, F, ACCESS
0C44  42E8     RRNCF WREG, F, ACCESS
0C46  6EE6     MOVWF POSTINC1, ACCESS
0C48  0EFF     MOVLW 0xFF
0C4A  0103     MOVLB 0x3
0C4C  15DC     ANDWF 0xDC, W, BANKED
0C4E  0101     MOVLB 0x1
0C50  6FF1     MOVWF spi_buf, BANKED
0C52  0E03     MOVLW 0x3
0C54  0103     MOVLB 0x3
0C56  15DD     ANDWF 0xDD, W, BANKED
0C58  0101     MOVLB 0x1
0C5A  6FF2     MOVWF 0xF2, BANKED
0C5C  C1F1     MOVFF __tmp_0, POSTINC1
0C5E  FFE6     NOP
0C60  C1F2     MOVFF 0x1F2, POSTINC1
0C62  FFE6     NOP
0C64  ECE2     CALL 0x2FC4, 0
0C66  F017     NOP
0C68  E943     SUBFSR 1, 0x3
573:           				z++;
0C6A  0103     MOVLB 0x3
0C6C  2BD8     INCF 0xD8, F, BANKED
0C6E  0E00     MOVLW 0x0
0C70  23D9     ADDWFC 0xD9, F, BANKED
0C72  23DA     ADDWFC 0xDA, F, BANKED
0C74  23DB     ADDWFC 0xDB, F, BANKED
574:           			}
575:           
576:           
577:           			if (V.clock20 > dtime2 + 1) { // ~10hz DAC update rate
0C78  EB09     MOVSF 0x9, 0x1F1
0C7A  F1F1     NOP
0C7C  EB0A     MOVSF 0xA, 0x1F2
0C7E  F1F2     NOP
0C80  EB0B     MOVSF 0xB, 0x1F3
0C82  F1F3     NOP
0C84  EB0C     MOVSF 0xC, 0x1F4
0C86  F1F4     NOP
0C88  0101     MOVLB 0x1
0C8A  2BF1     INCF spi_buf, F, BANKED
0C8C  0E00     MOVLW 0x0
0C8E  0101     MOVLB 0x1
0C90  23F2     ADDWFC 0xF2, F, BANKED
0C92  0E00     MOVLW 0x0
0C94  0101     MOVLB 0x1
0C96  23F3     ADDWFC data, F, BANKED
0C98  0E00     MOVLW 0x0
0C9A  0101     MOVLB 0x1
0C9C  23F4     ADDWFC spi_buf, F, BANKED
0C9E  0E62     MOVLW 0x62
0CA0  6EE9     MOVWF FSR0, ACCESS
0CA2  0E05     MOVLW 0x5
0CA4  6EEA     MOVWF FSR0H, ACCESS
0CA6  50EE     MOVF POSTINC0, W, ACCESS
0CA8  0101     MOVLB 0x1
0CAA  5DF1     SUBWF spi_buf, W, BANKED
0CAC  50EE     MOVF POSTINC0, W, ACCESS
0CAE  59F2     SUBWFB 0xF2, W, BANKED
0CB0  50EE     MOVF POSTINC0, W, ACCESS
0CB2  59F3     SUBWFB data, W, BANKED
0CB4  50EE     MOVF POSTINC0, W, ACCESS
0CB6  59F4     SUBWFB spi_buf, W, BANKED
0CB8  E265     BC 0xD84
578:           				dac1 += 3;
0CBA  0E03     MOVLW 0x3
0CBC  2601     ADDWF [0x1], F, ACCESS
0CBE  0E00     MOVLW 0x0
0CC0  2202     ADDWFC [0x2], F, ACCESS
579:           				dac2 -= 3;
0CC2  0E03     MOVLW 0x3
0CC4  5E03     SUBWF [0x3], F, ACCESS
0CC6  0E00     MOVLW 0x0
0CC8  5A04     SUBWFB [0x4], F, ACCESS
580:           				DLED_2 = HIGH;
0CCA  8491     BSF LATJ, 2, ACCESS
581:           				// do something
582:           				mfc_flow(&mfc[AIR_MFC], dac1);
0CCC  EB01     MOVSF 0x1, 0xFE6
0CCE  FFE6     NOP
0CD0  EB02     MOVSF 0x2, 0xFE6
0CD2  FFE6     NOP
0CD4  0E00     MOVLW 0x0
0CD6  6EE6     MOVWF POSTINC1, ACCESS
0CD8  0E07     MOVLW 0x7
0CDA  6EE6     MOVWF POSTINC1, ACCESS
0CDC  EC65     CALL 0x2ACA, 0
0CDE  F015     NOP
0CE0  E944     SUBFSR 1, 0x4
583:           
584:           				mfc_flow(&mfc[GAS_MFC], dac2);
0CE2  EB03     MOVSF 0x3, 0xFE6
0CE4  FFE6     NOP
0CE6  EB04     MOVSF 0x4, 0xFE6
0CE8  FFE6     NOP
0CEA  0E2B     MOVLW 0x2B
0CEC  6EE6     MOVWF POSTINC1, ACCESS
0CEE  0E07     MOVLW 0x7
0CF0  6EE6     MOVWF POSTINC1, ACCESS
0CF2  EC65     CALL 0x2ACA, 0
0CF4  F015     NOP
0CF6  E944     SUBFSR 1, 0x4
585:           
586:           				mfc_mass(&mfc[COLOR1_MFC], 3000, 25);
0CF8  0E19     MOVLW 0x19
0CFA  6EE6     MOVWF POSTINC1, ACCESS
0CFC  6AE6     CLRF POSTINC1, ACCESS
0CFE  6AE6     CLRF POSTINC1, ACCESS
0D00  6AE6     CLRF POSTINC1, ACCESS
0D02  0EB8     MOVLW 0xB8
0D04  6EE6     MOVWF POSTINC1, ACCESS
0D06  0E0B     MOVLW 0xB
0D08  6EE6     MOVWF POSTINC1, ACCESS
0D0A  0E56     MOVLW 0x56
0D0C  6EE6     MOVWF POSTINC1, ACCESS
0D0E  0E07     MOVLW 0x7
0D10  6EE6     MOVWF POSTINC1, ACCESS
0D12  EC7D     CALL 0x2AFA, 0
0D14  F015     NOP
0D16  E948     SUBFSR 1, 0x8
587:           				if (mfc_done(&mfc[COLOR1_MFC]))
0D18  0E56     MOVLW 0x56
0D1A  6EE6     MOVWF POSTINC1, ACCESS
0D1C  0E07     MOVLW 0x7
0D1E  6EE6     MOVWF POSTINC1, ACCESS
0D20  EC4E     CALL 0x2A9C, 0
0D22  F015     NOP
0D24  E942     SUBFSR 1, 0x2
0D26  0900     IORLW 0x0
0D28  E007     BZ 0xD38
588:           					mfc_shut(&mfc[COLOR1_MFC]);
0D2A  0E56     MOVLW 0x56
0D2C  6EE6     MOVWF POSTINC1, ACCESS
0D2E  0E07     MOVLW 0x7
0D30  6EE6     MOVWF POSTINC1, ACCESS
0D32  EC5B     CALL 0x2AB6, 0
0D34  F015     NOP
0D36  E942     SUBFSR 1, 0x2
589:           
590:           				mfc_flow(&mfc[COLOR2_MFC], rand());
0D38  EC92     CALL 0x3D24, 0
0D3A  F01E     NOP
0D3C  CFF3     MOVFF PROD, POSTINC1
0D3E  FFE6     NOP
0D40  CFF4     MOVFF PRODH, POSTINC1
0D42  FFE6     NOP
0D44  0E81     MOVLW 0x81
0D46  6EE6     MOVWF POSTINC1, ACCESS
0D48  0E07     MOVLW 0x7
0D4A  6EE6     MOVWF POSTINC1, ACCESS
0D4C  EC65     CALL 0x2ACA, 0
0D4E  F015     NOP
0D50  E944     SUBFSR 1, 0x4
591:           
592:           				valves.buf.bd[0]=rand();
0D52  EC92     CALL 0x3D24, 0
0D54  F01E     NOP
0D56  CFF3     MOVFF PROD, valves
0D58  F2E7     NOP
593:           				valves.buf.bd[1]=rand();
0D5A  EC92     CALL 0x3D24, 0
0D5C  F01E     NOP
0D5E  CFF3     MOVFF PROD, 0x2E8
0D60  F2E8     NOP
594:           				valve_set(&valves);
0D62  0EE7     MOVLW 0xE7
0D64  6EE6     MOVWF POSTINC1, ACCESS
0D66  0E02     MOVLW 0x2
0D68  6EE6     MOVWF POSTINC1, ACCESS
0D6A  EC33     CALL 0x3466, 0
0D6C  F01A     NOP
0D6E  E942     SUBFSR 1, 0x2
595:           				dtime2 = V.clock20;
0D70  0105     MOVLB 0x5
0D72  5162     MOVF 0x62, W, BANKED
0D74  6E09     MOVWF [0x9], ACCESS
0D76  5163     MOVF 0x63, W, BANKED
0D78  6E0A     MOVWF [0xA], ACCESS
0D7A  5164     MOVF 0x64, W, BANKED
0D7C  6E0B     MOVWF [0xB], ACCESS
0D7E  5165     MOVF 0x65, W, BANKED
0D80  6E0C     MOVWF [0xC], ACCESS
596:           				DLED_2 = LOW;
0D82  9491     BCF LATJ, 2, ACCESS
597:           			}
598:           		}
599:           
600:           		if (SSPCON1bits.WCOL || SSPCON1bits.SSPOV) { // check for overruns/collisions
0D84  50C6     MOVF SSP1CON1, W, ACCESS
0D86  0B80     ANDLW 0x80
0D88  E103     BNZ 0xD90
0D8A  50C6     MOVF SSP1CON1, W, ACCESS
0D8C  0B40     ANDLW 0x40
0D8E  E015     BZ 0xDBA
601:           			SSPCON1bits.WCOL = (SSPCON1bits.SSPOV = LOW);
0D90  9CC6     BCF SSP1CON1, 6, ACCESS
0D92  9EC6     BCF SSP1CON1, 7, ACCESS
602:           			ringBufS_flush(spi_link.tx1b, 1); // dump the spi buffers
0D94  0E01     MOVLW 0x1
0D96  6EE6     MOVWF POSTINC1, ACCESS
0D98  C503     MOVFF 0x503, POSTINC1
0D9A  FFE6     NOP
0D9C  C504     MOVFF 0x504, POSTINC1
0D9E  FFE6     NOP
0DA0  EC8D     CALL 0x2D1A, 0
0DA2  F016     NOP
0DA4  E943     SUBFSR 1, 0x3
603:           			ringBufS_flush(spi_link.rx1b, 1);
0DA6  0E01     MOVLW 0x1
0DA8  6EE6     MOVWF POSTINC1, ACCESS
0DAA  C505     MOVFF 0x505, POSTINC1
0DAC  FFE6     NOP
0DAE  C506     MOVFF 0x506, POSTINC1
0DB0  FFE6     NOP
0DB2  EC8D     CALL 0x2D1A, 0
0DB4  F016     NOP
0DB6  E943     SUBFSR 1, 0x3
604:           			DLED_6 = ON;
0DB8  9C91     BCF LATJ, 6, ACCESS
605:           		}
606:           	}
607:           }
0DBC  E94D     SUBFSR 1, 0xD
0DBE  CFE7     MOVFF INDF1, FSR2
0DC0  FFD9     NOP
0DC2  0012     RETURN 0
608:           
---  /sdd/work/mx320/pyro/p18pyro.X/mfc.c  --------------------------------------------------------------
1:             /*
2:              * the MFC state machine control routines
3:              * needs to return the integrated flow value since the last reset command for each unit in the structure pointer
4:              * with a status value returned from the function
5:              */
6:             
7:             #include "mfc.h"
8:             
9:             struct mfctype mfc[4] = {0}, *mfcptr;
10:            
11:            void mfc_config(void)
298A  D906     RCALL __pa_5
298C  E981     SUBFSR 2, 0x1
298E  E841     ADDFSR 1, 0x1
12:            {
13:            	uint8_t i;
14:            
15:            	mfc[AIR_MFC].mfc_flow_size = 500; // 0.1 units 50SLM for 5 volts
2990  0107     MOVLB 0x7
2992  0EF4     MOVLW 0xF4
2994  6F03     MOVWF ret, BANKED
2996  0E01     MOVLW 0x1
2998  6F04     MOVWF count, BANKED
16:            	mfc[GAS_MFC].mfc_flow_size = 150;
299A  0E96     MOVLW 0x96
299C  6F2E     MOVWF 0x2E, BANKED
299E  6B2F     CLRF 0x2F, BANKED
17:            	mfc[COLOR1_MFC].mfc_flow_size = 500;
29A0  0EF4     MOVLW 0xF4
29A2  6F59     MOVWF 0x59, BANKED
29A4  0E01     MOVLW 0x1
29A6  6F5A     MOVWF 0x5A, BANKED
18:            	mfc[COLOR2_MFC].mfc_flow_size = 10;
29A8  0E0A     MOVLW 0xA
29AA  6F84     MOVWF 0x84, BANKED
29AC  6B85     CLRF 0x85, BANKED
19:            
20:            	/*
21:            	 * setup defaults
22:            	 */
23:            	for (i = 0; i <= 3; i++) {
29AE  6A01     CLRF [0x1], ACCESS
29B0  5001     MOVF [0x1], W, ACCESS
29B2  0803     SUBLW 0x3
29B4  E323     BNC 0x29FC
29F8  2A01     INCF [0x1], F, ACCESS
29FA  D7DA     BRA 0x29B0
24:            		mfc[i].id = i;
29B6  D8C8     RCALL __pa_0
29B8  EB01     MOVSF 0x1, 0xFEF
29BA  FFEF     NOP
25:            		mfc[i].gas_t = SHUT;
29BC  D8C5     RCALL __pa_0
29BE  D91C     RCALL __pa_13
29C0  6AEF     CLRF INDF0, ACCESS
26:            		mfc[i].mfc_integ_total_mass = 1;
29C2  D8C2     RCALL __pa_0
29C4  0E17     MOVLW 0x17
29C6  D90E     RCALL __pa_11
2BE4  DFCF     RCALL __pa_3
2BE6  DFF0     RCALL __pa_8
27:            		mfc[i].mfc_integ_current_mass = 1;
29C8  0E1B     MOVLW 0x1B
29CA  D90C     RCALL __pa_11
2BC8  0E01     MOVLW 0x1
2BCA  6EEE     MOVWF POSTINC0, ACCESS
2BCC  6AEE     CLRF POSTINC0, ACCESS
2BCE  6AEE     CLRF POSTINC0, ACCESS
2BD0  6AEE     CLRF POSTINC0, ACCESS
2BD2  0012     RETURN 0
2BE8  EFA4     GOTO 0x2B48
2BEA  F015     NOP
28:            		mfc[i].mfc_integ_target_mass = 1;
29CC  0E1F     MOVLW 0x1F
29CE  D8DA     RCALL __pa_3
29D0  D8FB     RCALL __pa_8
29:            		mfc[i].scale_out = ((float) mfc[i].mfc_flow_size) / MFC_VOLTS;
29D2  6AE6     CLRF POSTINC1, ACCESS
29D4  0E40     MOVLW 0x40
29D6  6EE6     MOVWF POSTINC1, ACCESS
29D8  0E9C     MOVLW 0x9C
29DA  6EE6     MOVWF POSTINC1, ACCESS
29DC  0E45     MOVLW 0x45
29DE  6EE6     MOVWF POSTINC1, ACCESS
29E0  D8B3     RCALL __pa_0
29E2  0E03     MOVLW 0x3
29E4  D903     RCALL __pa_12
29E6  EC23     CALL 0x2446, 0
29E8  F012     NOP
29EA  EC0C     CALL 0x2618, 0
29EC  F013     NOP
29EE  D8D9     RCALL __pa_6
29F0  D8AB     RCALL __pa_0
29F2  0E0F     MOVLW 0xF
29F4  D8C7     RCALL __pa_3
29F6  D8DF     RCALL __pa_7
2B48  5001     MOVF [0x1], W, ACCESS
2B4A  0D2B     MULLW 0x2B
2B4C  CFF3     MOVFF PROD, FSR0
2B4E  FFE9     NOP
2B50  CFF4     MOVFF PRODH, FSR0H
2B52  FFEA     NOP
2B54  0E00     MOVLW 0x0
2B56  26E9     ADDWF FSR0, F, ACCESS
2B58  0E07     MOVLW 0x7
2B5A  22EA     ADDWFC FSR0H, F, ACCESS
2B5C  0012     RETURN 0
2BA2  52E5     MOVF POSTDEC1, F, ACCESS
2BA4  CFE5     MOVFF POSTDEC1, 0x1F4
2BA6  F1F4     NOP
2BA8  CFE5     MOVFF POSTDEC1, 0x1F3
2BAA  F1F3     NOP
2BAC  CFE5     MOVFF POSTDEC1, 0x1F2
2BAE  F1F2     NOP
2BB0  CFE7     MOVFF INDF1, __tmp_0
2BB2  F1F1     NOP
2BB4  0012     RETURN 0
2BB6  C1F1     MOVFF __tmp_0, POSTINC0
2BB8  FFEE     NOP
2BBA  C1F2     MOVFF 0x1F2, POSTINC0
2BBC  FFEE     NOP
2BBE  C1F3     MOVFF 0x1F3, POSTINC0
2BC0  FFEE     NOP
2BC2  C1F4     MOVFF 0x1F4, POSTINC0
2BC4  FFEE     NOP
2BC6  0012     RETURN 0
2BEC  DFCB     RCALL __pa_3
2BEE  CFEE     MOVFF POSTINC0, POSTINC1
2BF0  FFE6     NOP
2BF2  CFEE     MOVFF POSTINC0, POSTINC1
2BF4  FFE6     NOP
2BF6  0012     RETURN 0
30:            	}
31:            }
29FC  E942     SUBFSR 1, 0x2
29FE  CFE7     MOVFF INDF1, FSR2
2A00  FFD9     NOP
2A02  0012     RETURN 0
32:            
33:            int8_t mfc_set(struct mfctype * mfc)
2A04  D8C9     RCALL __pa_5
2A06  E983     SUBFSR 2, 0x3
2A08  E843     ADDFSR 1, 0x3
34:            {
35:            	int8_t ret = -1;
2A0A  6803     SETF [0x3], ACCESS
36:            	uint8_t mfc_id = mfc->id;
2A0C  D8B6     RCALL __pa_2
2A0E  50EF     MOVF INDF0, W, ACCESS
2A10  6E04     MOVWF [0x4], ACCESS
37:            	union mcp4822_adr_type mfc_dac_select;
38:            
39:            	mfcptr = mfc;
2A12  EB00     MOVSF 0x0, 0x2EA
2A14  F2EA     NOP
2A16  EB01     MOVSF 0x1, 0x2EB
2A18  F2EB     NOP
40:            
41:            	switch (mfc->gas_t) {
2A1A  D8AF     RCALL __pa_2
2A1C  D8ED     RCALL __pa_13
2A1E  50EF     MOVF INDF0, W, ACCESS
2A20  E01F     BZ 0x2A60
2A22  0A01     XORLW 0x1
2A24  E015     BZ 0x2A50
2A26  0A03     XORLW 0x3
2A28  E11F     BNZ 0x2A68
42:            	case MASS:
43:            		ret = 0;
2A2A  6A03     CLRF [0x3], ACCESS
44:            		if (!mfc->measure) {
2A2C  D8D8     RCALL __pa_10
2A2E  50EF     MOVF INDF0, W, ACCESS
2A30  0B04     ANDLW 0x4
2A32  E12C     BNZ 0x2A8C
45:            			mfc->measure = HIGH;
2A34  D8D4     RCALL __pa_10
2A36  84EF     BSF INDF0, 2, ACCESS
46:            			mfc_dac_select.buf = mfc_id;
2A38  EB84     MOVSS 0x4, 0x5
2A3A  F005     NOP
47:            			mfc->mfc_integ_current_mass = 0;
2A3C  D89E     RCALL __pa_2
2A3E  0E1B     MOVLW 0x1B
2A40  D8A1     RCALL __pa_3
2A42  6AEE     CLRF POSTINC0, ACCESS
2A44  6AEE     CLRF POSTINC0, ACCESS
2A46  6AEE     CLRF POSTINC0, ACCESS
2A48  6AEE     CLRF POSTINC0, ACCESS
48:            			ret = SPI_Daq_Update(mfc->mfc_set, mfc_dac_select.map.cs, mfc_dac_select.map.device);
2A4A  D889     RCALL __pa_1
2A4C  E017     BZ 0x2A7C
49:            		}
50:            		break;
2A4E  D006     BRA 0x2A5C
51:            	case FLOW:
52:            		mfc->measure = HIGH;
2A50  D8C6     RCALL __pa_10
2A52  84EF     BSF INDF0, 2, ACCESS
53:            		mfc_dac_select.buf = mfc_id;
2A54  EB84     MOVSS 0x4, 0x5
2A56  F005     NOP
54:            		ret = SPI_Daq_Update(mfc->mfc_set, mfc_dac_select.map.cs, mfc_dac_select.map.device);
2A58  D882     RCALL __pa_1
2A5A  E010     BZ 0x2A7C
2A5C  0E01     MOVLW 0x1
55:            		break;
2A5E  D00E     BRA 0x2A7C
56:            	case SHUT:
57:            		mfc->done = LOW;
2A60  D8BE     RCALL __pa_10
2A62  90EF     BCF INDF0, 0, ACCESS
58:            		mfc->measure = LOW;
2A64  D8BC     RCALL __pa_10
2A66  94EF     BCF INDF0, 2, ACCESS
59:            	default:
60:            		mfc->mfc_set = 0;
2A68  D888     RCALL __pa_2
2A6A  0E07     MOVLW 0x7
2A6C  6AEB     CLRF PLUSW0, ACCESS
2A6E  0E08     MOVLW 0x8
2A70  6AEB     CLRF PLUSW0, ACCESS
61:            		mfc_dac_select.buf = mfc_id;
2A72  EB84     MOVSS 0x4, 0x5
2A74  F005     NOP
62:            		ret = SPI_Daq_Update(mfc->mfc_set, mfc_dac_select.map.cs, mfc_dac_select.map.device);
2A76  D873     RCALL __pa_1
2A78  E001     BZ 0x2A7C
2A7A  0E01     MOVLW 0x1
2A7C  6EE6     MOVWF POSTINC1, ACCESS
2A7E  D87D     RCALL __pa_2
2A80  0E07     MOVLW 0x7
2A82  D8B4     RCALL __pa_12
2A84  EC40     CALL 0x3080, 0
2A86  F018     NOP
2A88  E944     SUBFSR 1, 0x4
2A8A  6E03     MOVWF [0x3], ACCESS
2B5E  50D9     MOVF FSR2, W, ACCESS
2B60  0F05     ADDLW 0x5
2B62  6EE9     MOVWF FSR0, ACCESS
2B64  CFDA     MOVFF FSR2H, FSR0H
2B66  FFEA     NOP
2B68  50EF     MOVF INDF0, W, ACCESS
2B6A  0B01     ANDLW 0x1
2B6C  6EE6     MOVWF POSTINC1, ACCESS
2B6E  50D9     MOVF FSR2, W, ACCESS
2B70  0F05     ADDLW 0x5
2B72  6EE9     MOVWF FSR0, ACCESS
2B74  50EF     MOVF INDF0, W, ACCESS
2B76  0B02     ANDLW 0x2
2B78  0012     RETURN 0
63:            		break;
64:            	}
65:            	if (ret)
2A8C  5003     MOVF [0x3], W, ACCESS
2A8E  E001     BZ 0x2A92
66:            		DLED_6 = ON;
2A90  9C91     BCF LATJ, 6, ACCESS
67:            
68:            	return ret;
2A92  5003     MOVF [0x3], W, ACCESS
69:            }
2A94  E944     SUBFSR 1, 0x4
2A96  CFE7     MOVFF INDF1, FSR2
2A98  FFD9     NOP
2A9A  0012     RETURN 0
70:            
71:            int8_t mfc_done(struct mfctype * mfc)
2A9C  D87D     RCALL __pa_5
2A9E  E983     SUBFSR 2, 0x3
72:            {
73:            	if (mfc->done)
2AA0  D89E     RCALL __pa_10
2AA2  50EF     MOVF INDF0, W, ACCESS
2AA4  0B01     ANDLW 0x1
2AA6  E002     BZ 0x2AAC
2BDE  DFCD     RCALL __pa_2
2BE0  52EE     MOVF POSTINC0, F, ACCESS
2BE2  0012     RETURN 0
74:            		return 1;
2AA8  0E01     MOVLW 0x1
2AAA  D001     BRA 0x2AAE
75:            	else
76:            		return 0;
2AAC  0E00     MOVLW 0x0
77:            }
2AAE  E941     SUBFSR 1, 0x1
2AB0  CFE7     MOVFF INDF1, FSR2
2AB2  FFD9     NOP
2AB4  0012     RETURN 0
78:            
79:            int8_t mfc_shut(struct mfctype * mfc)
2AB6  D870     RCALL __pa_5
2AB8  E983     SUBFSR 2, 0x3
80:            {
81:            	mfc->gas_t = SHUT;
2ABA  D85F     RCALL __pa_2
2ABC  D89D     RCALL __pa_13
2ABE  6AEF     CLRF INDF0, ACCESS
2B7A  EB00     MOVSF 0x0, 0xFE9
2B7C  FFE9     NOP
2B7E  EB01     MOVSF 0x1, 0xFEA
2B80  FFEA     NOP
2B82  0012     RETURN 0
2BF8  0E02     MOVLW 0x2
2BFA  EFC2     GOTO 0x2B84
2BFC  F015     NOP
82:            	return mfc_set(mfc);
2AC0  EB00     MOVSF 0x0, 0xFE6
2AC2  FFE6     NOP
2AC4  EB01     MOVSF 0x1, 0xFE6
2AC6  FFE6     NOP
2AC8  D061     BRA __pa_4
83:            }
84:            
85:            int8_t mfc_flow(struct mfctype * mfc, uint16_t flow)
2ACA  D866     RCALL __pa_5
2ACC  E985     SUBFSR 2, 0x5
86:            {
87:            	mfc->mfc_set = flow;
2ACE  EB02     MOVSF 0x2, 0xFE9
2AD0  FFE9     NOP
2AD2  EB03     MOVSF 0x3, 0xFEA
2AD4  FFEA     NOP
2AD6  0E07     MOVLW 0x7
2AD8  D855     RCALL __pa_3
2ADA  EB00     MOVSF 0x0, 0xFEE
2ADC  FFEE     NOP
2ADE  EB01     MOVSF 0x1, 0xFED
2AE0  FFED     NOP
88:            	mfc->gas_t = FLOW;
2AE2  EB02     MOVSF 0x2, 0xFE9
2AE4  FFE9     NOP
2AE6  EB03     MOVSF 0x3, 0xFEA
2AE8  FFEA     NOP
2AEA  D886     RCALL __pa_13
2AEC  0E01     MOVLW 0x1
2AEE  6EEF     MOVWF INDF0, ACCESS
89:            	return mfc_set(mfc);
2AF0  EB02     MOVSF 0x2, 0xFE6
2AF2  FFE6     NOP
2AF4  EB03     MOVSF 0x3, 0xFE6
2AF6  FFE6     NOP
2AF8  D049     BRA __pa_4
90:            }
91:            
92:            int8_t mfc_mass(struct mfctype * mfc, uint16_t flow, uint32_t mass)
2AFA  D84E     RCALL __pa_5
2AFC  E989     SUBFSR 2, 0x9
2B98  CFD9     MOVFF FSR2, POSTINC1
2B9A  FFE6     NOP
2B9C  CFE1     MOVFF FSR1, FSR2
2B9E  FFD9     NOP
2BA0  0012     RETURN 0
93:            {
94:            	mfc->mfc_set = flow;
2AFE  D86A     RCALL __pa_9
2B00  0E07     MOVLW 0x7
2B02  D840     RCALL __pa_3
2B04  EB04     MOVSF 0x4, 0xFEE
2B06  FFEE     NOP
2B08  EB05     MOVSF 0x5, 0xFED
2B0A  FFED     NOP
95:            	mfc->mfc_integ_target_mass = mass * MFC_INTEG; // total volts
2B0C  0EB0     MOVLW 0xB0
2B0E  6EE6     MOVWF POSTINC1, ACCESS
2B10  0E04     MOVLW 0x4
2B12  6EE6     MOVWF POSTINC1, ACCESS
2B14  6AE6     CLRF POSTINC1, ACCESS
2B16  6AE6     CLRF POSTINC1, ACCESS
2B18  EB00     MOVSF 0x0, 0xFE6
2B1A  FFE6     NOP
2B1C  EB01     MOVSF 0x1, 0xFE6
2B1E  FFE6     NOP
2B20  EB02     MOVSF 0x2, 0xFE6
2B22  FFE6     NOP
2B24  EB03     MOVSF 0x3, 0xFE6
2B26  FFE6     NOP
2B28  ECC9     CALL 0x2792, 0
2B2A  F013     NOP
2B2C  D83A     RCALL __pa_6
2B2E  D852     RCALL __pa_9
2B30  0E1F     MOVLW 0x1F
2B32  D828     RCALL __pa_3
2B34  D840     RCALL __pa_7
96:            	mfc->gas_t = MASS;
2B36  D84E     RCALL __pa_9
2B38  D85F     RCALL __pa_13
2B3A  0E02     MOVLW 0x2
2B3C  6EEF     MOVWF INDF0, ACCESS
2B84  26E9     ADDWF FSR0, F, ACCESS
2B86  0E00     MOVLW 0x0
2B88  22EA     ADDWFC FSR0H, F, ACCESS
2B8A  0012     RETURN 0
2BD4  EB06     MOVSF 0x6, 0xFE9
2BD6  FFE9     NOP
2BD8  EB07     MOVSF 0x7, 0xFEA
2BDA  FFEA     NOP
2BDC  0012     RETURN 0
97:            	return mfc_set(mfc);
2B3E  EB06     MOVSF 0x6, 0xFE6
2B40  FFE6     NOP
2B42  EB07     MOVSF 0x7, 0xFE6
2B44  FFE6     NOP
2B46  D022     BRA __pa_4
2B8C  DF3B     RCALL mfc_set
2B8E  E942     SUBFSR 1, 0x2
98:            }
2B90  E941     SUBFSR 1, 0x1
2B92  CFE7     MOVFF INDF1, FSR2
2B94  FFD9     NOP
2B96  0012     RETURN 0
---  /sdd/work/mx320/pyro/p18pyro.X/hwconf.c  -----------------------------------------------------------
1:             #include "hwconf.h"
2:             
3:             void config_pic(uint16_t hw_config)
32E4  CFD9     MOVFF FSR2, POSTINC1
32E6  FFE6     NOP
32E8  CFE1     MOVFF FSR1, FSR2
32EA  FFD9     NOP
32EC  E983     SUBFSR 2, 0x3
4:             {
5:             	static char z;
6:             	if (hw_config == 8722u) {
32EE  0E12     MOVLW 0x12
32F0  1800     XORWF [0x0], W, ACCESS
32F2  E102     BNZ 0x32F8
32F4  0E22     MOVLW 0x22
32F6  1801     XORWF [0x1], W, ACCESS
32F8  E001     BZ 0x32FC
32FA  D09A     BRA 0x3430
7:             		_asm nop _endasm // asm code to disable compiler optimizations
32FC  0000     NOP
8:             		if (RCONbits.TO == (uint8_t) LOW) WDT_TO = TRUE;
32FE  B6D0     BTFSC RCON, 3, ACCESS
3300  D003     BRA 0x3308
3302  0105     MOVLB 0x5
3304  0E01     MOVLW 0x1
3306  6F0F     MOVWF k, BANKED
9:             		if (EECON1bits.WRERR && (EECON1bits.EEPGD == (uint8_t) LOW)) EEP_ER = TRUE;
3308  50A6     MOVF EECON1, W, ACCESS
330A  0B08     ANDLW 0x8
330C  E006     BZ 0x331A
330E  50A6     MOVF EECON1, W, ACCESS
3310  0B80     ANDLW 0x80
3312  E103     BNZ 0x331A
3314  0105     MOVLB 0x5
3316  0E01     MOVLW 0x1
3318  6F10     MOVWF size, BANKED
10:            		/* Configure all PORT  pins  */
11:            
12:            		TRISAbits.TRISA4 = LOW; // output
331A  9892     BCF TRISA, 4, ACCESS
13:            		TRISAbits.TRISA0 = HIGH; // an0	systemvoltage
331C  8092     BSF TRISA, 0, ACCESS
14:            		TRISAbits.TRISA1 = HIGH; // an1 motorvoltage
331E  8292     BSF TRISA, 1, ACCESS
15:            		TRISAbits.TRISA2 = HIGH; // an2 current_x
3320  8492     BSF TRISA, 2, ACCESS
16:            		TRISAbits.TRISA3 = HIGH; // VREF input
3322  8692     BSF TRISA, 3, ACCESS
17:            		TRISAbits.TRISA5 = HIGH; // an4 current_z
3324  8A92     BSF TRISA, 5, ACCESS
18:            
19:            		TRISB = 0x00; // all outputs first
3326  6A93     CLRF TRISB, ACCESS
20:            		LATB = 0xFF;
3328  688A     SETF LATB, ACCESS
21:            		TRISBbits.TRISB0 = HIGH; // switch 1
332A  8093     BSF TRISB, 0, ACCESS
22:            		TRISBbits.TRISB1 = HIGH; // 2
332C  8293     BSF TRISB, 1, ACCESS
23:            		TRISBbits.TRISB2 = HIGH; // 3
332E  8493     BSF TRISB, 2, ACCESS
24:            		TRISBbits.TRISB3 = HIGH; // motor QEI1 channel A
3330  8693     BSF TRISB, 3, ACCESS
25:            		TRISBbits.TRISB4 = HIGH; // quad1 a
3332  8893     BSF TRISB, 4, ACCESS
26:            		TRISBbits.TRISB5 = HIGH; // quad1 b
3334  8A93     BSF TRISB, 5, ACCESS
27:            		TRISBbits.TRISB6 = HIGH; // quad2 a
3336  8C93     BSF TRISB, 6, ACCESS
28:            		TRISBbits.TRISB7 = HIGH; // quad2 b
3338  8E93     BSF TRISB, 7, ACCESS
29:            		TRISC = 0x00; // SPI outputs
333A  6A94     CLRF TRISC, ACCESS
30:            		LATC = 0xff; // all devices disabled/HIGH
333C  688B     SETF LATC, ACCESS
31:            
32:            		TRISD = 0xff; // dip switch inputs
333E  6895     SETF TRISD, ACCESS
33:            
34:            		TRISE = LOW; // motor relay outputs
3340  6A96     CLRF TRISE, ACCESS
35:            		LATE = R_ALL_ON;
3342  688D     SETF LATE, ACCESS
36:            
37:            		TRISF = 0xff; // all inputs for ADC inputs
3344  6897     SETF TRISF, ACCESS
38:            
39:            		LATGbits.LATG0 = LOW; // output latch to zero Alarm signal
3346  908F     BCF LATG, 0, ACCESS
40:            		LATGbits.LATG3 = LOW; // output latch to zero Voice1 signal
3348  968F     BCF LATG, 3, ACCESS
41:            		LATGbits.LATG4 = LOW; // output latch to zero Voice2 signal
334A  988F     BCF LATG, 4, ACCESS
42:            		TRISGbits.TRISG4 = HIGH; //
334C  8898     BSF TRISG, 4, ACCESS
43:            		TRISGbits.TRISG3 = HIGH; // set to input for OFF and output for ON
334E  8698     BSF TRISG, 3, ACCESS
44:            		TRISGbits.TRISG0 = LOW; // output
3350  9098     BCF TRISG, 0, ACCESS
45:            
46:            		TRISH = LOW; // mpuled and LCD
3352  6A99     CLRF TRISH, ACCESS
47:            		LATH = 0xff;
3354  6890     SETF LATH, ACCESS
48:            
49:            		TRISJ = 0; // internal diag LEDS
3356  6A9A     CLRF TRISJ, ACCESS
50:            		LATJ = 0xff;
3358  6891     SETF LATJ, ACCESS
51:            
52:            		/* SPI pins setup */
53:            		TRISCbits.TRISC3 = LOW; // SCK 
335A  9694     BCF TRISC, 3, ACCESS
54:            		TRISCbits.TRISC4 = HIGH; // SDI
335C  8894     BSF TRISC, 4, ACCESS
55:            		TRISCbits.TRISC5 = LOW; // SDO
335E  9A94     BCF TRISC, 5, ACCESS
56:            
57:            		OpenSPI1(SPI_FOSC_4, MODE_00, SMPEND); // 1MHz
3360  0E80     MOVLW 0x80
3362  6EE6     MOVWF POSTINC1, ACCESS
3364  6AE6     CLRF POSTINC1, ACCESS
3366  6AE6     CLRF POSTINC1, ACCESS
3368  EC60     CALL 0x3AC0, 0
336A  F01D     NOP
336C  E943     SUBFSR 1, 0x3
58:            		SSP1CON1 |= SPI_FOSC_4;
59:            
60:            		/* clear SPI module possible flags */
61:            		PIE1bits.SSP1IE = HIGH;
336E  869D     BSF PIE1, 3, ACCESS
62:            		IPR1bits.SSP1IP = HIGH;
3370  869F     BSF IPR1, 3, ACCESS
63:            		PIR1bits.SSP1IF = LOW;
3372  969E     BCF PIR1, 3, ACCESS
64:            
65:            		/*
66:            		 * Open the USARTs configured as
67:            		 * 8N1, 38400,38400 baud, in send and receive INT mode
68:            		 */
69:            		BAUDCON2 |= 0x08; // 16 bit mode speed register
3374  867C     BSF BAUDCON2, 3, ACCESS
70:            
71:            		Open2USART(USART_TX_INT_OFF & USART_RX_INT_ON & USART_ASYNCH_MODE & USART_EIGHT_BIT & USART_CONT_RX & USART_BRGH_LOW, 64); // 40mhz osc HS         38.4 kbaud, 16bit divider
3376  0E40     MOVLW 0x40
3378  6EE6     MOVWF POSTINC1, ACCESS
337A  6AE6     CLRF POSTINC1, ACCESS
337C  0E6C     MOVLW 0x6C
337E  6EE6     MOVWF POSTINC1, ACCESS
3380  EC12     CALL 0x3824, 0
3382  F01C     NOP
3384  E943     SUBFSR 1, 0x3
72:            		SPBRGH2 = 0x00;
3386  6A7D     CLRF SPBRGH2, ACCESS
73:            		SPBRG2 = 0x40;
3388  0E40     MOVLW 0x40
338A  6E6F     MOVWF SPBRG2, ACCESS
74:            
75:            		while (DataRdy2USART()) { // dump 2 rx data
338C  AAA4     BTFSS PIR3, 5, ACCESS
338E  D005     BRA 0x339A
3398  D7F9     BRA 0x338C
76:            			z = Read2USART();
3390  ECCB     CALL 0x3D96, 0
3392  F01E     NOP
3394  0102     MOVLB 0x2
3396  6FF2     MOVWF 0xF2, BANKED
77:            		};
78:            		RCSTA1bits.SPEN = 0; // disable port 1
339A  9EAB     BCF RCSTA1, 7, ACCESS
79:            
80:            		OpenADC(ADC_FOSC_32 & ADC_RIGHT_JUST & ADC_4_TAD, ADC_CH0 & ADC_REF_VDD_VSS & ADC_INT_ON, ADC_11ANA); // open ADC channels for current and voltage readings
339C  0EF4     MOVLW 0xF4
339E  6EE6     MOVWF POSTINC1, ACCESS
33A0  0E84     MOVLW 0x84
33A2  6EE6     MOVWF POSTINC1, ACCESS
33A4  0EA5     MOVLW 0xA5
33A6  6EE6     MOVWF POSTINC1, ACCESS
33A8  EC2E     CALL 0x3A5C, 0
33AA  F01D     NOP
33AC  E943     SUBFSR 1, 0x3
81:            		ADCON1 = 0x03; // adc [0..11] enable, the OpenADC ADC_11ANA sets this also
33AE  0E03     MOVLW 0x3
33B0  6EC1     MOVWF ADCON1, ACCESS
82:            		PIE1bits.ADIE = HIGH; // the ADC interrupt enable bit
33B2  8C9D     BSF PIE1, 6, ACCESS
83:            		IPR1bits.ADIP = HIGH; // ADC use high pri
33B4  8C9F     BSF IPR1, 6, ACCESS
84:            
85:            		OpenTimer0(TIMER_INT_ON & T0_16BIT & T0_SOURCE_INT & T0_PS_1_256);
33B6  0E97     MOVLW 0x97
33B8  6EE6     MOVWF POSTINC1, ACCESS
33BA  EC3E     CALL 0x3E7C, 0
33BC  F01F     NOP
33BE  E941     SUBFSR 1, 0x1
86:            		OpenTimer3(TIMER_INT_ON & T1_16BIT_RW & T1_SOURCE_INT & T1_PS_1_8 &
87:            			T1_OSC1EN_OFF & T1_SYNC_EXT_OFF); // for lamp scanner
33C0  0EF5     MOVLW 0xF5
33C2  6EE6     MOVWF POSTINC1, ACCESS
33C4  ECAB     CALL 0x3D56, 0
33C6  F01E     NOP
33C8  E941     SUBFSR 1, 0x1
88:            		PR4 = TIMER4_NORM;
33CA  0E07     MOVLW 0x7
33CC  6E77     MOVWF PR4, ACCESS
89:            		OpenTimer4(TIMER_INT_ON & T4_PS_1_16 & T4_POST_1_16);
33CE  68E6     SETF POSTINC1, ACCESS
33D0  EC59     CALL 0x3EB2, 0
33D2  F01F     NOP
33D4  E941     SUBFSR 1, 0x1
90:            		IPR3bits.TMR4IP = HIGH; // make it high pri level
33D6  86A5     BSF IPR3, 3, ACCESS
91:            		PIE3bits.TMR4IE = HIGH; // TIMER4 int enable bit
33D8  86A3     BSF PIE3, 3, ACCESS
92:            
93:            		INTCONbits.RBIE = HIGH; // enable PORTB interrupts 1=enable
33DA  86F2     BSF INTCON, 3, ACCESS
94:            		INTCON2bits.RBIP = HIGH; // Set the PORTB interrupt-on-change as a high priority interrupt
33DC  80F1     BSF INTCON2, 0, ACCESS
95:            
96:            		INTCONbits.INT0IE = HIGH; //
33DE  88F2     BSF INTCON, 4, ACCESS
97:            		INTCON2bits.INTEDG0 = LOW; // falling edge
33E0  9CF1     BCF INTCON2, 6, ACCESS
98:            		INTCONbits.INT0IF = LOW; // clean possible flag
33E2  92F2     BCF INTCON, 1, ACCESS
99:            
100:           		INTCON3bits.INT1IE = HIGH; //
33E4  86F0     BSF INTCON3, 3, ACCESS
101:           		INTCON2bits.INTEDG1 = LOW; // falling edge
33E6  9AF1     BCF INTCON2, 5, ACCESS
102:           		INTCON3bits.INT1IF = LOW; // clean possible flag
33E8  90F0     BCF INTCON3, 0, ACCESS
103:           
104:           		INTCON3bits.INT2IE = HIGH; //
33EA  88F0     BSF INTCON3, 4, ACCESS
105:           		INTCON2bits.INTEDG2 = LOW; // falling edge
33EC  98F1     BCF INTCON2, 4, ACCESS
106:           		INTCON3bits.INT2IF = LOW; // clean possible flag
33EE  92F0     BCF INTCON3, 1, ACCESS
107:           
108:           		INTCON3bits.INT3IE = HIGH; //
33F0  8AF0     BSF INTCON3, 5, ACCESS
109:           		INTCON2bits.INTEDG3 = LOW; // falling edge
33F2  96F1     BCF INTCON2, 3, ACCESS
110:           		INTCON3bits.INT3IF = LOW; // clean possible flag
33F4  94F0     BCF INTCON3, 2, ACCESS
111:           
112:           		z = PORTB; // dummy read to clear possible b irq
33F6  CF81     MOVFF PORTB, z
33F8  F2F2     NOP
113:           		INTCONbits.RBIF = LOW; // reset B flag
33FA  90F2     BCF INTCON, 0, ACCESS
114:           		INTCON2bits.RBPU = LOW; // enable input pullup. 0=on
33FC  9EF1     BCF INTCON2, 7, ACCESS
115:           
116:           		WriteTimer0(TIMEROFFSET); // start timer0 at 1 second ticks
33FE  0E6A     MOVLW 0x6A
3400  6EE6     MOVWF POSTINC1, ACCESS
3402  0E67     MOVLW 0x67
3404  6EE6     MOVWF POSTINC1, ACCESS
3406  EC8B     CALL 0x3F16, 0
3408  F01F     NOP
340A  E942     SUBFSR 1, 0x2
117:           		WriteTimer3(TIMER3REG); // worker thread timer about 20hz                                                           //
340C  0EE8     MOVLW 0xE8
340E  6EE6     MOVWF POSTINC1, ACCESS
3410  0E0B     MOVLW 0xB
3412  6EE6     MOVWF POSTINC1, ACCESS
3414  EC73     CALL 0x3EE6, 0
3416  F01F     NOP
3418  E942     SUBFSR 1, 0x2
118:           
119:           		/*      work int thread setup */
120:           		IPR2bits.TMR3IP = LOW; // make it low pri level
341A  92A2     BCF IPR2, 1, ACCESS
121:           		PIE2bits.TMR3IE = HIGH; // enable int
341C  82A0     BSF PIE2, 1, ACCESS
122:           
123:           		/* EEPROM write int enable */
124:           		PIE2bits.EEIE = HIGH;
341E  88A0     BSF PIE2, 4, ACCESS
125:           
126:           		/* Enable interrupt priority */
127:           		RCONbits.IPEN = HIGH;
3420  8ED0     BSF RCON, 7, ACCESS
128:           		PIR1 = LOW; // clear int flags
3422  6A9E     CLRF PIR1, ACCESS
129:           		PIR2 = LOW;
3424  6AA1     CLRF PIR2, ACCESS
130:           		PIR3 = LOW;
3426  6AA4     CLRF PIR3, ACCESS
131:           
132:           		/* Make receive interrupt high priority */
133:           		IPR3bits.RC2IP = HIGH;
3428  8AA5     BSF IPR3, 5, ACCESS
134:           
135:           		/* Enable all high/low priority interrupts */
136:           		INTCONbits.GIEH = HIGH;
342A  8EF2     BSF INTCON, 7, ACCESS
137:           		INTCONbits.GIEL = HIGH;
342C  8CF2     BSF INTCON, 6, ACCESS
138:           		DLED_1 = LOW;
342E  9291     BCF LATJ, 1, ACCESS
139:           	}
140:           }
3430  E941     SUBFSR 1, 0x1
3432  CFE7     MOVFF INDF1, FSR2
3434  FFD9     NOP
3436  0012     RETURN 0
141:           
142:           void start_pic(uint16_t hw_config)
3438  CFD9     MOVFF FSR2, POSTINC1
343A  FFE6     NOP
343C  CFE1     MOVFF FSR1, FSR2
343E  FFD9     NOP
3440  E983     SUBFSR 2, 0x3
143:           {
144:           	if (hw_config == 8722u) {
3442  0E12     MOVLW 0x12
3444  1800     XORWF [0x0], W, ACCESS
3446  E104     BNZ 0x3450
3448  0E22     MOVLW 0x22
344A  1801     XORWF [0x1], W, ACCESS
344C  E101     BNZ 0x3450
145:           		IORELAYS = 0xff; // set control relays to off at powerup/reset
344E  6888     SETF PORTJ, ACCESS
146:           	}
147:           }
3450  E941     SUBFSR 1, 0x1
3452  CFE7     MOVFF INDF1, FSR2
3454  FFD9     NOP
3456  0012     RETURN 0
148:           
149:           void start_workerthread(void)
150:           {
151:           	//	T2CONbits.TMR2ON = HIGH;
152:           }
3458  0012     RETURN 0
---  /sdd/work/mx320/pyro/p18pyro.X/displays.c  ---------------------------------------------------------
1:             #include "displays.h"
2:             
3:             void lcd_display_line(int8_t * text, uint8_t row)
3DD4  CFD9     MOVFF FSR2, POSTINC1
3DD6  FFE6     NOP
3DD8  CFE1     MOVFF FSR1, FSR2
3DDA  FFD9     NOP
3DDC  E984     SUBFSR 2, 0x4
4:             {
5:             
6:             	text[20] = NULL0; // limit the string to 20 chars
3DDE  0E14     MOVLW 0x14
3DE0  2401     ADDWF [0x1], W, ACCESS
3DE2  6EE9     MOVWF FSR0, ACCESS
3DE4  0E00     MOVLW 0x0
3DE6  2002     ADDWFC [0x2], W, ACCESS
3DE8  6EEA     MOVWF FSR0H, ACCESS
3DEA  6AEF     CLRF INDF0, ACCESS
7:             	S_WriteCmdXLCD(0b10000000 | row); // SetDDRamAddr
3DEC  0E80     MOVLW 0x80
3DEE  1000     IORWF [0x0], W, ACCESS
3DF0  6EE6     MOVWF POSTINC1, ACCESS
3DF2  ECCB     CALL 0x3796, 0
3DF4  F01B     NOP
3DF6  E941     SUBFSR 1, 0x1
8:             	putsXLCD(text);
3DF8  EB01     MOVSF 0x1, 0xFE6
3DFA  FFE6     NOP
3DFC  EB02     MOVSF 0x2, 0xFE6
3DFE  FFE6     NOP
3E00  EC07     CALL 0x3E0E, 0
3E02  F01F     NOP
3E04  E942     SUBFSR 1, 0x2
9:             }
3E06  E941     SUBFSR 1, 0x1
3E08  CFE7     MOVFF INDF1, FSR2
3E0A  FFD9     NOP
3E0C  0012     RETURN 0
---  /sdd/work/mx320/pyro/p18pyro.X/daq.c  --------------------------------------------------------------
1:             /* Read analog voltage and current inputs */
2:             #include "daq.h"
3:             
4:             /* switch to ADC chan 8 (shorted to ground) to reset ADC measurement cap to zero before next measurement */
5:             void ADC_zero(void)
6:             {
7:             	ClrWdt(); // reset the WDT timer
2FAC  0004     CLRWDT
8:             	SetChanADC(ADC_CH8); // F3 grounded input
2FAE  0EC7     MOVLW 0xC7
2FB0  6EE6     MOVWF POSTINC1, ACCESS
2FB2  ECA3     CALL 0x3F46, 0
2FB4  F01F     NOP
2FB6  E941     SUBFSR 1, 0x1
9:             	Delay10TCYx(ADC_CHAN_DELAY);
2FB8  0E64     MOVLW 0x64
2FBA  6EE6     MOVWF POSTINC1, ACCESS
2FBC  EC25     CALL 0x404A, 0
2FBE  F020     NOP
2FC0  E941     SUBFSR 1, 0x1
10:            }
2FC2  0012     RETURN 0
11:            
12:            void ADC_Update(uint16_t adc_val, uint8_t chan)
2FC4  CFD9     MOVFF FSR2, POSTINC1
2FC6  FFE6     NOP
2FC8  CFE1     MOVFF FSR1, FSR2
2FCA  FFD9     NOP
2FCC  E984     SUBFSR 2, 0x4
13:            {
14:            	if (chan >= ADC_INDEX)
2FCE  0E08     MOVLW 0x8
2FD0  5C00     SUBWF [0x0], W, ACCESS
2FD2  E252     BC 0x3078
15:            		return;
16:            	L.adc_raw[chan] = adc_val;
2FD4  6AEA     CLRF FSR0H, ACCESS
2FD6  3400     RLCF [0x0], W, ACCESS
2FD8  0BFE     ANDLW 0xFE
2FDA  6EE9     MOVWF FSR0, ACCESS
2FDC  36EA     RLCF FSR0H, F, ACCESS
2FDE  0E23     MOVLW 0x23
2FE0  26E9     ADDWF FSR0, F, ACCESS
2FE2  0E04     MOVLW 0x4
2FE4  22EA     ADDWFC FSR0H, F, ACCESS
2FE6  EB01     MOVSF 0x1, 0xFEE
2FE8  FFEE     NOP
2FEA  EB02     MOVSF 0x2, 0xFED
2FEC  FFED     NOP
17:            	L.adc_val[chan] = (adc_val * (ADC_5V_MV - ADC_NULL + adc_cal[chan])) / 100; //      voltage correction factor;
2FEE  0E64     MOVLW 0x64
2FF0  6EE6     MOVWF POSTINC1, ACCESS
2FF2  6AE6     CLRF POSTINC1, ACCESS
2FF4  6AE6     CLRF POSTINC1, ACCESS
2FF6  6AE6     CLRF POSTINC1, ACCESS
2FF8  5000     MOVF [0x0], W, ACCESS
2FFA  6AEA     CLRF FSR0H, ACCESS
2FFC  0FAE     ADDLW 0xAE
2FFE  6EE9     MOVWF FSR0, ACCESS
3000  0E05     MOVLW 0x5
3002  22EA     ADDWFC FSR0H, F, ACCESS
3004  CFEF     MOVFF INDF0, 0x1F5
3006  F1F5     NOP
3008  0101     MOVLB 0x1
300A  6BF6     CLRF upper_lower, BANKED
300C  6BF7     CLRF 0xF7, BANKED
300E  6BF8     CLRF mcp4822_buf, BANKED
3010  0E69     MOVLW 0x69
3012  27F5     ADDWF 0xF5, F, BANKED
3014  0E01     MOVLW 0x1
3016  23F6     ADDWFC upper_lower, F, BANKED
3018  0E00     MOVLW 0x0
301A  23F7     ADDWFC 0xF7, F, BANKED
301C  23F8     ADDWFC mcp4822_buf, F, BANKED
301E  C1F5     MOVFF 0x1F5, POSTINC1
3020  FFE6     NOP
3022  C1F6     MOVFF 0x1F6, POSTINC1
3024  FFE6     NOP
3026  C1F7     MOVFF 0x1F7, POSTINC1
3028  FFE6     NOP
302A  C1F8     MOVFF 0x1F8, POSTINC1
302C  FFE6     NOP
302E  EB01     MOVSF 0x1, 0xFE6
3030  FFE6     NOP
3032  EB02     MOVSF 0x2, 0xFE6
3034  FFE6     NOP
3036  6AE6     CLRF POSTINC1, ACCESS
3038  6AE6     CLRF POSTINC1, ACCESS
303A  ECC9     CALL 0x2792, 0
303C  F013     NOP
303E  ECC6     CALL 0x258C, 0
3040  F012     NOP
3042  52E5     MOVF POSTDEC1, F, ACCESS
3044  CFE5     MOVFF POSTDEC1, 0x1F4
3046  F1F4     NOP
3048  CFE5     MOVFF POSTDEC1, 0x1F3
304A  F1F3     NOP
304C  CFE5     MOVFF POSTDEC1, 0x1F2
304E  F1F2     NOP
3050  CFE7     MOVFF INDF1, __tmp_0
3052  F1F1     NOP
3054  5000     MOVF [0x0], W, ACCESS
3056  0D04     MULLW 0x4
3058  CFF3     MOVFF PROD, FSR0
305A  FFE9     NOP
305C  CFF4     MOVFF PRODH, FSR0H
305E  FFEA     NOP
3060  0E03     MOVLW 0x3
3062  26E9     ADDWF FSR0, F, ACCESS
3064  0E04     MOVLW 0x4
3066  22EA     ADDWFC FSR0H, F, ACCESS
3068  C1F1     MOVFF __tmp_0, POSTINC0
306A  FFEE     NOP
306C  C1F2     MOVFF 0x1F2, POSTINC0
306E  FFEE     NOP
3070  C1F3     MOVFF 0x1F3, POSTINC0
3072  FFEE     NOP
3074  C1F4     MOVFF 0x1F4, POSTINC0
3076  FFEE     NOP
18:            }
3078  E941     SUBFSR 1, 0x1
307A  CFE7     MOVFF INDF1, FSR2
307C  FFD9     NOP
307E  0012     RETURN 0
19:            
20:            /*
21:             * SPI 16 output driver
22:             */
23:            int8_t SPI_Daq_Update(uint16_t data, uint8_t cs, uint8_t device)
3080  CFD9     MOVFF FSR2, POSTINC1
3082  FFE6     NOP
3084  CFE1     MOVFF FSR1, FSR2
3086  FFD9     NOP
3088  E985     SUBFSR 2, 0x5
308A  E841     ADDFSR 1, 0x1
24:            {
25:            	static union spi_buf_type spi_buf = {0};
26:            	static union bytes2 upper_lower = {0};
27:            	static union mcp4822_buf_type mcp4822_buf = {0};
28:            	int8_t ret = -2; // preset fail code
308C  0EFE     MOVLW 0xFE
308E  6E05     MOVWF [0x5], ACCESS
29:            
30:            	if (ringBufS_full(spi_link.tx1b)) {
3090  D846     RCALL __pa_0
3092  E003     BZ 0x309A
31:            		ret = -3; // buffer full
3094  0EFD     MOVLW 0xFD
3096  6E05     MOVWF [0x5], ACCESS
32:            		goto err1;
3098  D03A     BRA 0x310E
33:            	}
34:            
35:            	switch (cs) {
309A  5001     MOVF [0x1], W, ACCESS
309C  0A0A     XORLW 0xA
309E  E02F     BZ 0x30FE
30A0  0A08     XORLW 0x8
30A2  E026     BZ 0x30F0
30A4  0A01     XORLW 0x1
30A6  E024     BZ 0x30F0
30A8  0A03     XORLW 0x3
30AA  E002     BZ 0x30B0
30AC  0A01     XORLW 0x1
30AE  E12E     BNZ 0x310C
36:            	case 0: // DAC
37:            	case 1: // DAC
38:            		/*
39:            		 * setup the mcp4822 register
40:            		 */
41:            		mcp4822_buf.buf = data & 0x0fff;
30B0  0100     MOVLB 0x0
30B2  0EFF     MOVLW 0xFF
30B4  1402     ANDWF [0x2], W, ACCESS
30B6  6FF8     MOVWF mcp4822_buf, BANKED
30B8  0E0F     MOVLW 0xF
30BA  1403     ANDWF [0x3], W, ACCESS
30BC  6FF9     MOVWF 0xF9, BANKED
42:            		mcp4822_buf.map.ab = device;
30BE  5000     MOVF [0x0], W, ACCESS
30C0  9FF9     BCF 0xF9, 7, BANKED
30C2  B0E8     BTFSC WREG, 0, ACCESS
30C4  8FF9     BSF 0xF9, 7, BANKED
43:            		mcp4822_buf.map.ga = 0;
30C6  9BF9     BCF 0xF9, 5, BANKED
44:            		mcp4822_buf.map.shdn = 1;
30C8  89F9     BSF 0xF9, 4, BANKED
45:            		upper_lower.ld = mcp4822_buf.buf; // load HL selector var
30CA  C0F8     MOVFF mcp4822_buf, upper_lower
30CC  F0F6     NOP
30CE  C0F9     MOVFF 0xF9, 0xF7
30D0  F0F7     NOP
46:            		/*
47:            		 * setup ring-buffer for transfer in two parts
48:            		 */
49:            		spi_buf.map.buf = upper_lower.bd[1]; // load high byte
30D2  C0F9     MOVFF 0xF9, spi_buf
30D4  F0F4     NOP
50:            		spi_buf.map.select = cs;
30D6  5001     MOVF [0x1], W, ACCESS
30D8  D82B     RCALL __pa_1
3130  0B03     ANDLW 0x3
3132  6EF3     MOVWF PROD, ACCESS
3134  46F3     RLNCF PROD, F, ACCESS
3136  46F3     RLNCF PROD, F, ACCESS
3138  0EF3     MOVLW 0xF3
313A  15F5     ANDWF 0xF5, W, BANKED
313C  10F3     IORWF PROD, W, ACCESS
313E  6FF5     MOVWF 0xF5, BANKED
51:            		spi_buf.map.load = 0;
3140  93F5     BCF 0xF5, 1, BANKED
3142  0012     RETURN 0
52:            		spi_buf.map.cs = 0;
30DA  91F5     BCF 0xF5, 0, BANKED
53:            		ringBufS_put(spi_link.tx1b, spi_buf.buf); // send data/control data to SPI devices (DAC)
30DC  C0F9     MOVFF 0xF9, POSTINC1
30DE  FFE6     NOP
30E0  D831     RCALL __pa_2
3144  C0F5     MOVFF 0xF5, POSTINC1
3146  FFE6     NOP
3148  C503     MOVFF 0x503, POSTINC1
314A  FFE6     NOP
314C  C504     MOVFF 0x504, POSTINC1
314E  FFE6     NOP
3150  EC6B     CALL 0x2CD6, 0
3152  F016     NOP
3154  E944     SUBFSR 1, 0x4
3156  0012     RETURN 0
54:            		spi_buf.map.buf = upper_lower.bd[0]; // load low byte
30E2  C0F6     MOVFF upper_lower, spi_buf
30E4  F0F4     NOP
55:            		spi_buf.map.cs = 1;
30E6  0100     MOVLB 0x0
30E8  81F5     BSF 0xF5, 0, BANKED
56:            		if (ringBufS_full(spi_link.tx1b)) goto err1; // second byte failed
30EA  D819     RCALL __pa_0
30EC  E110     BNZ 0x310E
57:            		ringBufS_put(spi_link.tx1b, spi_buf.buf); // send data/control data to SPI devices (DAC)
58:            		ret = 0;
59:            		break;
30EE  D009     BRA 0x3102
60:            	case 2:
61:            	case 3: // shift register output
62:            		spi_buf.map.buf = data; // load byte
30F0  EB02     MOVSF 0x2, 0xF4
30F2  F0F4     NOP
63:            		spi_buf.map.select = cs;
30F4  5001     MOVF [0x1], W, ACCESS
30F6  0100     MOVLB 0x0
30F8  D81B     RCALL __pa_1
64:            		spi_buf.map.load = 0;
65:            		spi_buf.map.cs = 1;
30FA  81F5     BSF 0xF5, 0, BANKED
66:            		ringBufS_put(spi_link.tx1b, spi_buf.buf); // send data/control data to SPI devices (shift register)
67:            		ret = 0;
68:            		break;
30FC  D002     BRA 0x3102
69:            	case 10: // retry second byte for DAC
70:            		if (ringBufS_full(spi_link.tx1b)) goto err1; // check again, buffer refilled quickly
30FE  D80F     RCALL __pa_0
3100  E106     BNZ 0x310E
311E  C503     MOVFF 0x503, POSTINC1
3120  FFE6     NOP
3122  C504     MOVFF 0x504, POSTINC1
3124  FFE6     NOP
3126  EC2E     CALL 0x2C5C, 0
3128  F016     NOP
312A  E942     SUBFSR 1, 0x2
312C  0900     IORLW 0x0
312E  0012     RETURN 0
71:            		ringBufS_put(spi_link.tx1b, spi_buf.buf); // send data/control data to SPI devices (DAC)
3102  C0F4     MOVFF spi_buf, POSTINC1
3104  FFE6     NOP
3106  D81E     RCALL __pa_2
72:            		ret = 0;
3108  6A05     CLRF [0x5], ACCESS
73:            		break;
310A  D001     BRA 0x310E
74:            	default:
75:            		ret = -1; // invalid device
310C  6805     SETF [0x5], ACCESS
76:            		break;
77:            	}
78:            err1:
79:            	if (ret)
310E  5005     MOVF [0x5], W, ACCESS
3110  E001     BZ 0x3114
80:            		DLED_7 = ON;
3112  9E91     BCF LATJ, 7, ACCESS
81:            	return ret;
3114  5005     MOVF [0x5], W, ACCESS
82:            }
3116  E942     SUBFSR 1, 0x2
3118  CFE7     MOVFF INDF1, FSR2
311A  FFD9     NOP
311C  0012     RETURN 0
---  /sdd/work/mx320/pyro/p18pyro.X/crit.c  -------------------------------------------------------------
1:             /* Switch on and off ISR enables */
2:             #include "crit.h"
3:             #include "pyro.h"
4:             
5:             volatile void s_crit(uint8_t mode) // Start critical section of code that needs protection for the ISR
2DEC  CFD9     MOVFF FSR2, POSTINC1
2DEE  FFE6     NOP
2DF0  CFE1     MOVFF FSR1, FSR2
2DF2  FFD9     NOP
2DF4  E982     SUBFSR 2, 0x2
6:             { // remember old high and low int bits so they can be restored correctly
7:             	static uint8_t H_tmp = 0; // keep track of time spent in critical section
8:             
9:             	_asm nop _endasm // asm code to disable compiler optimizations
2DF6  0000     NOP
10:            	LCRIT[CRITC] = INTCONbits.GIEL;
2DF8  50F2     MOVF INTCON, W, ACCESS
2DFA  0B40     ANDLW 0x40
2DFC  E001     BZ 0x2E00
2DFE  0E01     MOVLW 0x1
2E00  6EE6     MOVWF POSTINC1, ACCESS
2E02  0105     MOVLB 0x5
2E04  51BE     MOVF 0xBE, W, BANKED
2E06  6AEA     CLRF FSR0H, ACCESS
2E08  0F8B     ADDLW 0x8B
2E0A  6EE9     MOVWF FSR0, ACCESS
2E0C  0E06     MOVLW 0x6
2E0E  22EA     ADDWFC FSR0H, F, ACCESS
2E10  52E5     MOVF POSTDEC1, F, ACCESS
2E12  50E7     MOVF INDF1, W, ACCESS
2E14  6EEF     MOVWF INDF0, ACCESS
11:            	if (mode & 0x2) INTCONbits.GIEL = LOW;
2E16  B200     BTFSC [0x0], 1, ACCESS
2E18  9CF2     BCF INTCON, 6, ACCESS
12:            	HCRIT[CRITC] = INTCONbits.GIEH;
2E1A  50F2     MOVF INTCON, W, ACCESS
2E1C  0B80     ANDLW 0x80
2E1E  E001     BZ 0x2E22
2E20  0E01     MOVLW 0x1
2E22  6EE6     MOVWF POSTINC1, ACCESS
2E24  0105     MOVLB 0x5
2E26  51BE     MOVF 0xBE, W, BANKED
2E28  6AEA     CLRF FSR0H, ACCESS
2E2A  0F83     ADDLW 0x83
2E2C  6EE9     MOVWF FSR0, ACCESS
2E2E  0E06     MOVLW 0x6
2E30  22EA     ADDWFC FSR0H, F, ACCESS
2E32  52E5     MOVF POSTDEC1, F, ACCESS
2E34  50E7     MOVF INDF1, W, ACCESS
2E36  6EEF     MOVWF INDF0, ACCESS
13:            	if (mode & 0x1) INTCONbits.GIEH = LOW;
2E38  B000     BTFSC [0x0], 0, ACCESS
2E3A  9EF2     BCF INTCON, 7, ACCESS
14:            	critc_count++; // track counts
2E3C  0105     MOVLB 0x5
2E3E  2B11     INCF space_cnt, F, BANKED
2E40  0E00     MOVLW 0x0
2E42  2312     ADDWFC cval, F, BANKED
2E44  2313     ADDWFC larg, F, BANKED
2E46  2314     ADDWFC 0x14, F, BANKED
15:            	CRITC++; // array nest level index
2E48  0105     MOVLB 0x5
2E4A  2BBE     INCF 0xBE, F, BANKED
16:            	if (CRITC > critc_level) critc_level = CRITC; // track nesting checking
2E4C  0105     MOVLB 0x5
2E4E  510B     MOVF i, W, BANKED
2E50  0105     MOVLB 0x5
2E52  80D8     BSF STATUS, 0, ACCESS
2E54  55BE     SUBFWB 0xBE, W, BANKED
2E56  E202     BC 0x2E5C
2E58  C5BE     MOVFF CRITC, critc_level
2E5A  F50B     NOP
17:            	if ((uint8_t) CRITC == (uint8_t) CRITC1) { // only update at the first level
2E5C  0105     MOVLB 0x5
2E5E  05BE     DECF 0xBE, W, BANKED
2E60  E10D     BNZ 0x2E7C
18:            		H_tmp = INTCONbits.GIEH;
2E62  50F2     MOVF INTCON, W, ACCESS
2E64  0B80     ANDLW 0x80
2E66  E001     BZ 0x2E6A
2E68  0E01     MOVLW 0x1
2E6A  0102     MOVLB 0x2
2E6C  6FEC     MOVWF 0xEC, BANKED
19:            		INTCONbits.GIEH = LOW;
2E6E  9EF2     BCF INTCON, 7, ACCESS
20:            		INTCONbits.GIEH = H_tmp;
2E70  0102     MOVLB 0x2
2E72  51EC     MOVF 0xEC, W, BANKED
2E74  B0E8     BTFSC WREG, 0, ACCESS
2E76  8EF2     BSF INTCON, 7, ACCESS
2E78  A0E8     BTFSS WREG, 0, ACCESS
2E7A  9EF2     BCF INTCON, 7, ACCESS
21:            	}
22:            }
2E7C  E941     SUBFSR 1, 0x1
2E7E  CFE7     MOVFF INDF1, FSR2
2E80  FFD9     NOP
2E82  0012     RETURN 0
23:            
24:            volatile void e_crit(void) // End section of code that need protection from ISR
25:            {
26:            	static uint8_t H_tmp = 0;
27:            
28:            	_asm nop _endasm // asm code to disable compiler optimizations
2E84  0000     NOP
29:            	if (CRITC) {
2E86  0105     MOVLB 0x5
2E88  51BE     MOVF 0xBE, W, BANKED
2E8A  E02B     BZ 0x2EE2
30:            		CRITC--;
2E8C  0105     MOVLB 0x5
2E8E  07BE     DECF 0xBE, F, BANKED
31:            		if (!CRITC) { // only update at the first level
2E90  0105     MOVLB 0x5
2E92  51BE     MOVF 0xBE, W, BANKED
2E94  E10D     BNZ 0x2EB0
32:            			H_tmp = INTCONbits.GIEH;
2E96  50F2     MOVF INTCON, W, ACCESS
2E98  0B80     ANDLW 0x80
2E9A  E001     BZ 0x2E9E
2E9C  0E01     MOVLW 0x1
2E9E  0102     MOVLB 0x2
2EA0  6FED     MOVWF adc_buf, BANKED
33:            			INTCONbits.GIEH = LOW;
2EA2  9EF2     BCF INTCON, 7, ACCESS
34:            			INTCONbits.GIEH = H_tmp;
2EA4  0102     MOVLB 0x2
2EA6  51ED     MOVF adc_buf, W, BANKED
2EA8  B0E8     BTFSC WREG, 0, ACCESS
2EAA  8EF2     BSF INTCON, 7, ACCESS
2EAC  A0E8     BTFSS WREG, 0, ACCESS
2EAE  9EF2     BCF INTCON, 7, ACCESS
35:            		}
36:            		INTCONbits.GIEH = HCRIT[CRITC];
2EB0  0105     MOVLB 0x5
2EB2  51BE     MOVF 0xBE, W, BANKED
2EB4  6AEA     CLRF FSR0H, ACCESS
2EB6  0F83     ADDLW 0x83
2EB8  6EE9     MOVWF FSR0, ACCESS
2EBA  0E06     MOVLW 0x6
2EBC  22EA     ADDWFC FSR0H, F, ACCESS
2EBE  50EF     MOVF INDF0, W, ACCESS
2EC0  B0E8     BTFSC WREG, 0, ACCESS
2EC2  8EF2     BSF INTCON, 7, ACCESS
2EC4  A0E8     BTFSS WREG, 0, ACCESS
2EC6  9EF2     BCF INTCON, 7, ACCESS
37:            		INTCONbits.GIEL = LCRIT[CRITC];
2EC8  0105     MOVLB 0x5
2ECA  51BE     MOVF 0xBE, W, BANKED
2ECC  6AEA     CLRF FSR0H, ACCESS
2ECE  0F8B     ADDLW 0x8B
2ED0  6EE9     MOVWF FSR0, ACCESS
2ED2  0E06     MOVLW 0x6
2ED4  22EA     ADDWFC FSR0H, F, ACCESS
2ED6  50EF     MOVF INDF0, W, ACCESS
2ED8  B0E8     BTFSC WREG, 0, ACCESS
2EDA  8CF2     BSF INTCON, 6, ACCESS
2EDC  A0E8     BTFSS WREG, 0, ACCESS
2EDE  9CF2     BCF INTCON, 6, ACCESS
38:            	} else { // default to all interrupts on with overflow
2EE0  D004     BRA 0x2EEA
39:            		INTCONbits.GIEH = HIGH;
2EE2  8EF2     BSF INTCON, 7, ACCESS
40:            		INTCONbits.GIEL = HIGH;
2EE4  8CF2     BSF INTCON, 6, ACCESS
41:            		TXREG2 = '*'; // restore with no save, output to terminal port
2EE6  0E2A     MOVLW 0x2A
2EE8  6E6D     MOVWF TXREG2, ACCESS
42:            	}
43:            }
2EEA  0012     RETURN 0
44:            
45:            volatile void clear_crit(void)
46:            {
47:            	CRITC = NULL0;
2EEC  0105     MOVLB 0x5
2EEE  6BBE     CLRF 0xBE, BANKED
48:            	INTCONbits.GIEH = HIGH;
2EF0  8EF2     BSF INTCON, 7, ACCESS
49:            	INTCONbits.GIEL = HIGH;
2EF2  8CF2     BSF INTCON, 6, ACCESS
50:            }
2EF4  0012     RETURN 0
51:            
52:            void write_data_eeprom(uint8_t data, uint8_t count, uint16_t addr, uint16_t offset)
2EF6  CFD9     MOVFF FSR2, POSTINC1
2EF8  FFE6     NOP
2EFA  CFE1     MOVFF FSR1, FSR2
2EFC  FFD9     NOP
2EFE  E987     SUBFSR 2, 0x7
53:            {
54:            
55:            	//  eeprom data array: 0=CHECKMARK checksum, 1=length of array 2=start of array data, array offset, writes must be protected from ISR
56:            	if (addr == NULL0) { // only write header when on addr 0
2F00  5002     MOVF [0x2], W, ACCESS
2F02  1003     IORWF [0x3], W, ACCESS
2F04  E116     BNZ 0x2F32
57:            		s_crit(HL);
2F06  D84C     RCALL __pa_1
2FA0  0E03     MOVLW 0x3
2FA2  6EE6     MOVWF POSTINC1, ACCESS
2FA4  DF23     RCALL s_crit
2FA6  E941     SUBFSR 1, 0x1
58:            		Busy_eep();
2FA8  EF07     GOTO 0xE
2FAA  F000     NOP
59:            		Write_b_eep(0 + offset, CHECKMARK); //      write checksum  at byte 0 of the offset
2F08  0E59     MOVLW 0x59
2F0A  6EE6     MOVWF POSTINC1, ACCESS
2F0C  EB00     MOVSF 0x0, 0xFE6
2F0E  FFE6     NOP
2F10  EB01     MOVSF 0x1, 0xFE6
2F12  FFE6     NOP
2F14  ECFC     CALL 0x39F8, 0
2F16  F01C     NOP
2F18  E943     SUBFSR 1, 0x3
60:            		Busy_eep();
2F1A  EC07     CALL 0xE, 0
2F1C  F000     NOP
61:            		Busy_eep();
2F1E  EC07     CALL 0xE, 0
2F20  F000     NOP
62:            		Write_b_eep(1 + offset, count); // length of data
2F22  EB04     MOVSF 0x4, 0xFE6
2F24  FFE6     NOP
2F26  0101     MOVLB 0x1
2F28  2800     INCF [0x0], W, ACCESS
2F2A  6FF1     MOVWF spi_buf, BANKED
2F2C  0E00     MOVLW 0x0
2F2E  2001     ADDWFC [0x1], W, ACCESS
2F30  D82C     RCALL __pa_0
2F8A  6FF2     MOVWF 0xF2, BANKED
2F8C  C1F1     MOVFF __tmp_0, POSTINC1
2F8E  FFE6     NOP
2F90  6EE6     MOVWF POSTINC1, ACCESS
2F92  ECFC     CALL 0x39F8, 0
2F94  F01C     NOP
2F96  E943     SUBFSR 1, 0x3
63:            		Busy_eep();
2F98  EC07     CALL 0xE, 0
2F9A  F000     NOP
64:            		e_crit();
2F9C  EF42     GOTO 0x2E84
2F9E  F017     NOP
65:            	}
66:            	s_crit(HL);
2F32  D836     RCALL __pa_1
67:            	Busy_eep();
68:            	Write_b_eep(addr + 2 + offset, data); //  data
2F34  EB05     MOVSF 0x5, 0xFE6
2F36  FFE6     NOP
2F38  0E02     MOVLW 0x2
2F3A  0101     MOVLB 0x1
2F3C  2402     ADDWF [0x2], W, ACCESS
2F3E  6FF3     MOVWF data, BANKED
2F40  0E00     MOVLW 0x0
2F42  2003     ADDWFC [0x3], W, ACCESS
2F44  6FF4     MOVWF spi_buf, BANKED
2F46  5000     MOVF [0x0], W, ACCESS
2F48  25F3     ADDWF data, W, BANKED
2F4A  6FF1     MOVWF spi_buf, BANKED
2F4C  5001     MOVF [0x1], W, ACCESS
2F4E  21F4     ADDWFC spi_buf, W, BANKED
2F50  D81C     RCALL __pa_0
69:            	Busy_eep();
70:            	e_crit();
71:            }
2F52  E941     SUBFSR 1, 0x1
2F54  CFE7     MOVFF INDF1, FSR2
2F56  FFD9     NOP
2F58  0012     RETURN 0
72:            
73:            uint8_t read_data_eeprom(uint16_t addr, uint16_t offset)
2F5A  CFD9     MOVFF FSR2, POSTINC1
2F5C  FFE6     NOP
2F5E  CFE1     MOVFF FSR1, FSR2
2F60  FFD9     NOP
2F62  E985     SUBFSR 2, 0x5
74:            {
75:            	Busy_eep();
2F64  EC07     CALL 0xE, 0
2F66  F000     NOP
76:            	return Read_b_eep(addr + offset);
2F68  0101     MOVLB 0x1
2F6A  5002     MOVF [0x2], W, ACCESS
2F6C  2400     ADDWF [0x0], W, ACCESS
2F6E  6FF1     MOVWF spi_buf, BANKED
2F70  5003     MOVF [0x3], W, ACCESS
2F72  2001     ADDWFC [0x1], W, ACCESS
2F74  6FF2     MOVWF 0xF2, BANKED
2F76  C1F1     MOVFF __tmp_0, POSTINC1
2F78  FFE6     NOP
2F7A  6EE6     MOVWF POSTINC1, ACCESS
2F7C  EC6A     CALL 0x3CD4, 0
2F7E  F01E     NOP
2F80  E942     SUBFSR 1, 0x2
77:            }
2F82  E941     SUBFSR 1, 0x1
2F84  CFE7     MOVFF INDF1, FSR2
2F86  FFD9     NOP
2F88  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/pmc_common/USART/u2write.c  -----------------------------------
3F76  CFD9     MOVFF FSR2, POSTINC1
3F78  FFE6     NOP
3F7A  CFDA     MOVFF FSR2H, POSTINC1
3F7C  FFE6     NOP
3F7E  CFE1     MOVFF FSR1, FSR2
3F80  FFD9     NOP
3F82  CFE2     MOVFF FSR1H, FSR2H
3F84  FFDA     NOP
3F86  E983     SUBFSR 2, 0x3
3F88  AC6C     BTFSS TXSTA2, 6, ACCESS
3F8A  D004     BRA 0x3F94
3F8C  906C     BCF TXSTA2, 0, ACCESS
3F8E  0102     MOVLB 0x2
3F90  B3F1     BTFSC spi_buf, 1, BANKED
3F92  806C     BSF TXSTA2, 0, ACCESS
3F94  EB00     MOVSF 0x0, 0xF6D
3F96  FF6D     NOP
3F98  E941     SUBFSR 1, 0x1
3F9A  CFE5     MOVFF POSTDEC1, FSR2H
3F9C  FFDA     NOP
3F9E  CFE7     MOVFF INDF1, FSR2
3FA0  FFD9     NOP
3FA2  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/pmc_common/USART/u2read.c  ------------------------------------
3D96  CFD9     MOVFF FSR2, POSTINC1
3D98  FFE6     NOP
3D9A  CFDA     MOVFF FSR2H, POSTINC1
3D9C  FFE6     NOP
3D9E  CFE1     MOVFF FSR1, FSR2
3DA0  FFD9     NOP
3DA2  CFE2     MOVFF FSR1H, FSR2H
3DA4  FFDA     NOP
3DA6  E982     SUBFSR 2, 0x2
3DA8  E841     ADDFSR 1, 0x1
3DAA  0EF2     MOVLW 0xF2
3DAC  0102     MOVLB 0x2
3DAE  17F1     ANDWF spi_buf, F, BANKED
3DB0  AC6B     BTFSS RCSTA2, 6, ACCESS
3DB2  D003     BRA 0x3DBA
3DB4  91F1     BCF spi_buf, 0, BANKED
3DB6  B06B     BTFSC RCSTA2, 0, ACCESS
3DB8  81F1     BSF spi_buf, 0, BANKED
3DBA  B46B     BTFSC RCSTA2, 2, ACCESS
3DBC  85F1     BSF spi_buf, 2, BANKED
3DBE  B26B     BTFSC RCSTA2, 1, ACCESS
3DC0  87F1     BSF spi_buf, 3, BANKED
3DC2  506E     MOVF RCREG2, W, ACCESS
3DC4  6E02     MOVWF [0x2], ACCESS
3DC6  5002     MOVF [0x2], W, ACCESS
3DC8  E942     SUBFSR 1, 0x2
3DCA  CFE5     MOVFF POSTDEC1, FSR2H
3DCC  FFDA     NOP
3DCE  CFE7     MOVFF INDF1, FSR2
3DD0  FFD9     NOP
3DD2  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/pmc_common/USART/u2putrs.c  -----------------------------------
3B1E  CFD9     MOVFF FSR2, POSTINC1
3B20  FFE6     NOP
3B22  CFDA     MOVFF FSR2H, POSTINC1
3B24  FFE6     NOP
3B26  CFE1     MOVFF FSR1, FSR2
3B28  FFD9     NOP
3B2A  CFE2     MOVFF FSR1H, FSR2H
3B2C  FFDA     NOP
3B2E  E985     SUBFSR 2, 0x5
3B30  A26C     BTFSS TXSTA2, 1, ACCESS
3B32  D7FE     BRA 0x3B30
3B34  EB00     MOVSF 0x0, 0xFF6
3B36  FFF6     NOP
3B38  EB01     MOVSF 0x1, 0xFF7
3B3A  FFF7     NOP
3B3C  EB02     MOVSF 0x2, 0xFF8
3B3E  FFF8     NOP
3B40  0008     TBLRD*
3B42  CFF5     MOVFF TABLAT, POSTINC1
3B44  FFE6     NOP
3B46  ECBB     CALL 0x3F76, 0
3B48  F01F     NOP
3B4A  E941     SUBFSR 1, 0x1
3B4C  CFD9     MOVFF FSR2, FSR0
3B4E  FFE9     NOP
3B50  CFDA     MOVFF FSR2H, FSR0H
3B52  FFEA     NOP
3B54  CFEF     MOVFF INDF0, TBLPTR
3B56  FFF6     NOP
3B58  2AEE     INCF POSTINC0, F, ACCESS
3B5A  CFEF     MOVFF INDF0, TBLPTRH
3B5C  FFF7     NOP
3B5E  0E00     MOVLW 0x0
3B60  22EE     ADDWFC POSTINC0, F, ACCESS
3B62  CFEF     MOVFF INDF0, TBLPTRU
3B64  FFF8     NOP
3B66  22EE     ADDWFC POSTINC0, F, ACCESS
3B68  0008     TBLRD*
3B6A  50F5     MOVF TABLAT, W, ACCESS
3B6C  E1E1     BNZ 0x3B30
3B6E  E941     SUBFSR 1, 0x1
3B70  CFE5     MOVFF POSTDEC1, FSR2H
3B72  FFDA     NOP
3B74  CFE7     MOVFF INDF1, FSR2
3B76  FFD9     NOP
3B78  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/pmc_common/USART/u2open.c  ------------------------------------
3824  CFD9     MOVFF FSR2, POSTINC1
3826  FFE6     NOP
3828  CFDA     MOVFF FSR2H, POSTINC1
382A  FFE6     NOP
382C  CFE1     MOVFF FSR1, FSR2
382E  FFD9     NOP
3830  CFE2     MOVFF FSR1H, FSR2H
3832  FFDA     NOP
3834  E985     SUBFSR 2, 0x5
3836  6A6C     CLRF TXSTA2, ACCESS
3838  6A6B     CLRF RCSTA2, ACCESS
383A  B002     BTFSC [0x2], 0, ACCESS
383C  886C     BSF TXSTA2, 4, ACCESS
383E  A202     BTFSS [0x2], 1, ACCESS
3840  D002     BRA 0x3846
3842  8C6C     BSF TXSTA2, 6, ACCESS
3844  8C6B     BSF RCSTA2, 6, ACCESS
3846  B402     BTFSC [0x2], 2, ACCESS
3848  8E6C     BSF TXSTA2, 7, ACCESS
384A  A602     BTFSS [0x2], 3, ACCESS
384C  D002     BRA 0x3852
384E  886B     BSF RCSTA2, 4, ACCESS
3850  D001     BRA 0x3854
3852  8A6B     BSF RCSTA2, 5, ACCESS
3854  A802     BTFSS [0x2], 4, ACCESS
3856  D002     BRA 0x385C
3858  846C     BSF TXSTA2, 2, ACCESS
385A  D001     BRA 0x385E
385C  946C     BCF TXSTA2, 2, ACCESS
385E  BA02     BTFSC [0x2], 5, ACCESS
3860  866B     BSF RCSTA2, 3, ACCESS
3862  AC02     BTFSS [0x2], 6, ACCESS
3864  D002     BRA 0x386A
3866  8AA3     BSF PIE3, 5, ACCESS
3868  D001     BRA 0x386C
386A  9AA3     BCF PIE3, 5, ACCESS
386C  AE02     BTFSS [0x2], 7, ACCESS
386E  D002     BRA 0x3874
3870  88A3     BSF PIE3, 4, ACCESS
3872  D001     BRA 0x3876
3874  98A3     BCF PIE3, 4, ACCESS
3876  EB00     MOVSF 0x0, 0xF6F
3878  FF6F     NOP
387A  0101     MOVLB 0x1
387C  EB01     MOVSF 0x1, 0x1F1
387E  F1F1     NOP
3880  6BF2     CLRF 0xF2, BANKED
3882  C1F1     MOVFF __tmp_0, SPBRGH2
3884  FF7D     NOP
3886  8A6C     BSF TXSTA2, 5, ACCESS
3888  8E6B     BSF RCSTA2, 7, ACCESS
388A  9298     BCF TRISG, 1, ACCESS
388C  8498     BSF TRISG, 2, ACCESS
388E  506C     MOVF TXSTA2, W, ACCESS
3890  0B10     ANDLW 0x10
3892  E004     BZ 0x389C
3894  506C     MOVF TXSTA2, W, ACCESS
3896  0B80     ANDLW 0x80
3898  E101     BNZ 0x389C
389A  8298     BSF TRISG, 1, ACCESS
389C  E941     SUBFSR 1, 0x1
389E  CFE5     MOVFF POSTDEC1, FSR2H
38A0  FFDA     NOP
38A2  CFE7     MOVFF INDF1, FSR2
38A4  FFD9     NOP
38A6  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/pmc_common/USART/_usartpc.asm  --------------------------------
4014  0EFF     MOVLW 0xFF
4016  50E3     MOVF PLUSW1, W, ACCESS
4018  BAAC     BTFSC TXSTA1, 5, ACCESS
401A  D004     BRA loop
401C  6AAF     CLRF SPBRG1, ACCESS
401E  8EAB     BSF RCSTA1, 7, ACCESS
4020  8AAC     BSF TXSTA1, 5, ACCESS
4022  9C94     BCF TRISC, 6, ACCESS
4024  A2AC     BTFSS TXSTA1, 1, ACCESS
4026  D7FE     BRA loop
4028  6EAD     MOVWF TXREG1, ACCESS
402A  6EF3     MOVWF PROD, ACCESS
402C  6AF4     CLRF PRODH, ACCESS
402E  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/pmc_common/Timers/t4open.c  -----------------------------------
3EB2  CFD9     MOVFF FSR2, POSTINC1
3EB4  FFE6     NOP
3EB6  CFDA     MOVFF FSR2H, POSTINC1
3EB8  FFE6     NOP
3EBA  CFE1     MOVFF FSR1, FSR2
3EBC  FFD9     NOP
3EBE  CFE2     MOVFF FSR1H, FSR2H
3EC0  FFDA     NOP
3EC2  E983     SUBFSR 2, 0x3
3EC4  0EFB     MOVLW 0xFB
3EC6  1400     ANDWF [0x0], W, ACCESS
3EC8  6E76     MOVWF T4CON, ACCESS
3ECA  6A78     CLRF TMR4, ACCESS
3ECC  96A4     BCF PIR3, 3, ACCESS
3ECE  AE00     BTFSS [0x0], 7, ACCESS
3ED0  D002     BRA 0x3ED6
3ED2  86A3     BSF PIE3, 3, ACCESS
3ED4  D001     BRA 0x3ED8
3ED6  96A3     BCF PIE3, 3, ACCESS
3ED8  8476     BSF T4CON, 2, ACCESS
3EDA  E941     SUBFSR 1, 0x1
3EDC  CFE5     MOVFF POSTDEC1, FSR2H
3EDE  FFDA     NOP
3EE0  CFE7     MOVFF INDF1, FSR2
3EE2  FFD9     NOP
3EE4  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/pmc_common/Timers/t3write.c  ----------------------------------
3EE6  CFD9     MOVFF FSR2, POSTINC1
3EE8  FFE6     NOP
3EEA  CFDA     MOVFF FSR2H, POSTINC1
3EEC  FFE6     NOP
3EEE  CFE1     MOVFF FSR1, FSR2
3EF0  FFD9     NOP
3EF2  CFE2     MOVFF FSR1H, FSR2H
3EF4  FFDA     NOP
3EF6  E984     SUBFSR 2, 0x4
3EF8  E842     ADDFSR 1, 0x2
3EFA  EB80     MOVSS 0x0, 0x4
3EFC  F004     NOP
3EFE  EB81     MOVSS 0x1, 0x5
3F00  F005     NOP
3F02  EB05     MOVSF 0x5, 0xFB3
3F04  FFB3     NOP
3F06  EB04     MOVSF 0x4, 0xFB2
3F08  FFB2     NOP
3F0A  E943     SUBFSR 1, 0x3
3F0C  CFE5     MOVFF POSTDEC1, FSR2H
3F0E  FFDA     NOP
3F10  CFE7     MOVFF INDF1, FSR2
3F12  FFD9     NOP
3F14  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/pmc_common/Timers/t3open.c  -----------------------------------
3D56  CFD9     MOVFF FSR2, POSTINC1
3D58  FFE6     NOP
3D5A  CFDA     MOVFF FSR2H, POSTINC1
3D5C  FFE6     NOP
3D5E  CFE1     MOVFF FSR1, FSR2
3D60  FFD9     NOP
3D62  CFE2     MOVFF FSR1H, FSR2H
3D64  FFDA     NOP
3D66  E983     SUBFSR 2, 0x3
3D68  0E36     MOVLW 0x36
3D6A  1400     ANDWF [0x0], W, ACCESS
3D6C  6EB1     MOVWF T3CON, ACCESS
3D6E  6AB3     CLRF TMR3H, ACCESS
3D70  6AB2     CLRF TMR3, ACCESS
3D72  92A1     BCF PIR2, 1, ACCESS
3D74  AE00     BTFSS [0x0], 7, ACCESS
3D76  D002     BRA 0x3D7C
3D78  82A0     BSF PIE2, 1, ACCESS
3D7A  D001     BRA 0x3D7E
3D7C  92A0     BCF PIE2, 1, ACCESS
3D7E  A000     BTFSS [0x0], 0, ACCESS
3D80  D002     BRA 0x3D86
3D82  8EB1     BSF T3CON, 7, ACCESS
3D84  D001     BRA 0x3D88
3D86  9EB1     BCF T3CON, 7, ACCESS
3D88  80B1     BSF T3CON, 0, ACCESS
3D8A  E941     SUBFSR 1, 0x1
3D8C  CFE5     MOVFF POSTDEC1, FSR2H
3D8E  FFDA     NOP
3D90  CFE7     MOVFF INDF1, FSR2
3D92  FFD9     NOP
3D94  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/pmc_common/Timers/t0write.c  ----------------------------------
3F16  CFD9     MOVFF FSR2, POSTINC1
3F18  FFE6     NOP
3F1A  CFDA     MOVFF FSR2H, POSTINC1
3F1C  FFE6     NOP
3F1E  CFE1     MOVFF FSR1, FSR2
3F20  FFD9     NOP
3F22  CFE2     MOVFF FSR1H, FSR2H
3F24  FFDA     NOP
3F26  E984     SUBFSR 2, 0x4
3F28  E842     ADDFSR 1, 0x2
3F2A  EB80     MOVSS 0x0, 0x4
3F2C  F004     NOP
3F2E  EB81     MOVSS 0x1, 0x5
3F30  F005     NOP
3F32  EB05     MOVSF 0x5, 0xFD7
3F34  FFD7     NOP
3F36  EB04     MOVSF 0x4, 0xFD6
3F38  FFD6     NOP
3F3A  E943     SUBFSR 1, 0x3
3F3C  CFE5     MOVFF POSTDEC1, FSR2H
3F3E  FFDA     NOP
3F40  CFE7     MOVFF INDF1, FSR2
3F42  FFD9     NOP
3F44  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/pmc_common/Timers/t0open.c  -----------------------------------
3E7C  CFD9     MOVFF FSR2, POSTINC1
3E7E  FFE6     NOP
3E80  CFDA     MOVFF FSR2H, POSTINC1
3E82  FFE6     NOP
3E84  CFE1     MOVFF FSR1, FSR2
3E86  FFD9     NOP
3E88  CFE2     MOVFF FSR1H, FSR2H
3E8A  FFDA     NOP
3E8C  E983     SUBFSR 2, 0x3
3E8E  0E7F     MOVLW 0x7F
3E90  1400     ANDWF [0x0], W, ACCESS
3E92  6ED5     MOVWF T0CON, ACCESS
3E94  6AD7     CLRF TMR0H, ACCESS
3E96  6AD6     CLRF TMR0, ACCESS
3E98  94F2     BCF INTCON, 2, ACCESS
3E9A  AE00     BTFSS [0x0], 7, ACCESS
3E9C  D002     BRA 0x3EA2
3E9E  8AF2     BSF INTCON, 5, ACCESS
3EA0  D001     BRA 0x3EA4
3EA2  9AF2     BCF INTCON, 5, ACCESS
3EA4  8ED5     BSF T0CON, 7, ACCESS
3EA6  E941     SUBFSR 1, 0x1
3EA8  CFE5     MOVFF POSTDEC1, FSR2H
3EAA  FFDA     NOP
3EAC  CFE7     MOVFF INDF1, FSR2
3EAE  FFD9     NOP
3EB0  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/pmc_common/SPI/spi1open.c  ------------------------------------
3AC0  CFD9     MOVFF FSR2, POSTINC1
3AC2  FFE6     NOP
3AC4  CFDA     MOVFF FSR2H, POSTINC1
3AC6  FFE6     NOP
3AC8  CFE1     MOVFF FSR1, FSR2
3ACA  FFD9     NOP
3ACC  CFE2     MOVFF FSR1H, FSR2H
3ACE  FFDA     NOP
3AD0  E985     SUBFSR 2, 0x5
3AD2  0E3F     MOVLW 0x3F
3AD4  16C7     ANDWF SSP1STAT, F, ACCESS
3AD6  6AC6     CLRF SSP1CON1, ACCESS
3AD8  5002     MOVF [0x2], W, ACCESS
3ADA  12C6     IORWF SSP1CON1, F, ACCESS
3ADC  5000     MOVF [0x0], W, ACCESS
3ADE  12C7     IORWF SSP1STAT, F, ACCESS
3AE0  5001     MOVF [0x1], W, ACCESS
3AE2  0A03     XORLW 0x3
3AE4  E009     BZ 0x3AF8
3AE6  0A01     XORLW 0x1
3AE8  E004     BZ 0x3AF2
3AEA  0A02     XORLW 0x2
3AEC  E106     BNZ 0x3AFA
3AEE  8CC7     BSF SSP1STAT, 6, ACCESS
3AF0  D004     BRA 0x3AFA
3AF2  8CC7     BSF SSP1STAT, 6, ACCESS
3AF4  88C6     BSF SSP1CON1, 4, ACCESS
3AF6  D001     BRA 0x3AFA
3AF8  88C6     BSF SSP1CON1, 4, ACCESS
3AFA  5002     MOVF [0x2], W, ACCESS
3AFC  0A05     XORLW 0x5
3AFE  E003     BZ 0x3B06
3B00  0A01     XORLW 0x1
3B02  E103     BNZ 0x3B0A
3B04  8E97     BSF TRISF, 7, ACCESS
3B06  8694     BSF TRISC, 3, ACCESS
3B08  D001     BRA 0x3B0C
3B0A  9694     BCF TRISC, 3, ACCESS
3B0C  8894     BSF TRISC, 4, ACCESS
3B0E  9A94     BCF TRISC, 5, ACCESS
3B10  8AC6     BSF SSP1CON1, 5, ACCESS
3B12  E941     SUBFSR 1, 0x1
3B14  CFE5     MOVFF POSTDEC1, FSR2H
3B16  FFDA     NOP
3B18  CFE7     MOVFF INDF1, FSR2
3B1A  FFD9     NOP
3B1C  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/pmc_common/EEP/write_B.c  -------------------------------------
39F8  CFD9     MOVFF FSR2, POSTINC1
39FA  FFE6     NOP
39FC  CFDA     MOVFF FSR2H, POSTINC1
39FE  FFE6     NOP
3A00  CFE1     MOVFF FSR1, FSR2
3A02  FFD9     NOP
3A04  CFE2     MOVFF FSR1H, FSR2H
3A06  FFDA     NOP
3A08  E985     SUBFSR 2, 0x5
3A0A  E841     ADDFSR 1, 0x1
3A0C  6A05     CLRF [0x5], ACCESS
3A0E  0101     MOVLB 0x1
3A10  EB02     MOVSF 0x2, 0x1F1
3A12  F1F1     NOP
3A14  0E03     MOVLW 0x3
3A16  15F1     ANDWF spi_buf, W, BANKED
3A18  6EAA     MOVWF EEADRH, ACCESS
3A1A  0EFF     MOVLW 0xFF
3A1C  1401     ANDWF [0x1], W, ACCESS
3A1E  6EA9     MOVWF EEADR, ACCESS
3A20  EB00     MOVSF 0x0, 0xFA8
3A22  FFA8     NOP
3A24  9EA6     BCF EECON1, 7, ACCESS
3A26  9CA6     BCF EECON1, 6, ACCESS
3A28  84A6     BSF EECON1, 2, ACCESS
3A2A  50F2     MOVF INTCON, W, ACCESS
3A2C  0B80     ANDLW 0x80
3A2E  E001     BZ 0x3A32
3A30  0E01     MOVLW 0x1
3A32  6E05     MOVWF [0x5], ACCESS
3A34  9EF2     BCF INTCON, 7, ACCESS
3A36  0E55     MOVLW 0x55
3A38  6EA7     MOVWF EECON2, ACCESS
3A3A  0EAA     MOVLW 0xAA
3A3C  6EA7     MOVWF EECON2, ACCESS
3A3E  82A6     BSF EECON1, 1, ACCESS
3A40  B2A6     BTFSC EECON1, 1, ACCESS
3A42  D7FE     BRA 0x3A40
3A44  5005     MOVF [0x5], W, ACCESS
3A46  B0E8     BTFSC WREG, 0, ACCESS
3A48  8EF2     BSF INTCON, 7, ACCESS
3A4A  A0E8     BTFSS WREG, 0, ACCESS
3A4C  9EF2     BCF INTCON, 7, ACCESS
3A4E  94A6     BCF EECON1, 2, ACCESS
3A50  E942     SUBFSR 1, 0x2
3A52  CFE5     MOVFF POSTDEC1, FSR2H
3A54  FFDA     NOP
3A56  CFE7     MOVFF INDF1, FSR2
3A58  FFD9     NOP
3A5A  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/pmc_common/EEP/read_B.c  --------------------------------------
3CD4  CFD9     MOVFF FSR2, POSTINC1
3CD6  FFE6     NOP
3CD8  CFDA     MOVFF FSR2H, POSTINC1
3CDA  FFE6     NOP
3CDC  CFE1     MOVFF FSR1, FSR2
3CDE  FFD9     NOP
3CE0  CFE2     MOVFF FSR1H, FSR2H
3CE2  FFDA     NOP
3CE4  E984     SUBFSR 2, 0x4
3CE6  0101     MOVLB 0x1
3CE8  EB01     MOVSF 0x1, 0x1F1
3CEA  F1F1     NOP
3CEC  6BF2     CLRF 0xF2, BANKED
3CEE  0E03     MOVLW 0x3
3CF0  0101     MOVLB 0x1
3CF2  15F1     ANDWF spi_buf, W, BANKED
3CF4  6EAA     MOVWF EEADRH, ACCESS
3CF6  0EFF     MOVLW 0xFF
3CF8  1400     ANDWF [0x0], W, ACCESS
3CFA  6EA9     MOVWF EEADR, ACCESS
3CFC  9CA6     BCF EECON1, 6, ACCESS
3CFE  9EA6     BCF EECON1, 7, ACCESS
3D00  80A6     BSF EECON1, 0, ACCESS
3D02  0000     NOP
3D04  0000     NOP
3D06  50A8     MOVF EEDATA, W, ACCESS
3D08  D000     BRA 0x3D0A
3D0A  E941     SUBFSR 1, 0x1
3D0C  CFE5     MOVFF POSTDEC1, FSR2H
3D0E  FFDA     NOP
3D10  CFE7     MOVFF INDF1, FSR2
3D12  FFD9     NOP
3D14  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/pmc_common/EEP/busy_eep.c  ------------------------------------
000E  B2A6     BTFSC EECON1, 1, ACCESS
0010  D7FE     BRA Busy_eep
0012  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/pmc_common/ADC/adcsetch.c  ------------------------------------
3F46  CFD9     MOVFF FSR2, POSTINC1
3F48  FFE6     NOP
3F4A  CFDA     MOVFF FSR2H, POSTINC1
3F4C  FFE6     NOP
3F4E  CFE1     MOVFF FSR1, FSR2
3F50  FFD9     NOP
3F52  CFE2     MOVFF FSR1H, FSR2H
3F54  FFDA     NOP
3F56  E983     SUBFSR 2, 0x3
3F60  4000     RRNCF [0x0], W, ACCESS
3F62  0B7F     ANDLW 0x7F
3F64  0B3C     ANDLW 0x3C
3F58  0EC3     MOVLW 0xC3
3F5A  14C2     ANDWF ADCON0, W, ACCESS
3F5C  0101     MOVLB 0x1
3F5E  6FF1     MOVWF spi_buf, BANKED
3F66  11F1     IORWF spi_buf, W, BANKED
3F68  6EC2     MOVWF ADCON0, ACCESS
3F6A  E941     SUBFSR 1, 0x1
3F6C  CFE5     MOVFF POSTDEC1, FSR2H
3F6E  FFDA     NOP
3F70  CFE7     MOVFF INDF1, FSR2
3F72  FFD9     NOP
3F74  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/pmc_common/ADC/adcopen.c  -------------------------------------
3A5C  CFD9     MOVFF FSR2, POSTINC1
3A5E  FFE6     NOP
3A60  CFDA     MOVFF FSR2H, POSTINC1
3A62  FFE6     NOP
3A64  CFE1     MOVFF FSR1, FSR2
3A66  FFD9     NOP
3A68  CFE2     MOVFF FSR1H, FSR2H
3A6A  FFDA     NOP
3A6C  E985     SUBFSR 2, 0x5
3A6E  6AC2     CLRF ADCON0, ACCESS
3A70  6AC0     CLRF ADCON2, ACCESS
3A72  4001     RRNCF [0x1], W, ACCESS
3A74  0B7F     ANDLW 0x7F
3A76  0B3C     ANDLW 0x3C
3A78  6EC2     MOVWF ADCON0, ACCESS
3A84  0E0F     MOVLW 0xF
3A86  1400     ANDWF [0x0], W, ACCESS
3A7A  3801     SWAPF [0x1], W, ACCESS
3A7C  0BF0     ANDLW 0xF0
3A7E  0B30     ANDLW 0x30
3A80  0101     MOVLB 0x1
3A82  6FF1     MOVWF spi_buf, BANKED
3A88  11F1     IORWF spi_buf, W, BANKED
3A8A  6EC1     MOVWF ADCON1, ACCESS
3A9E  0E80     MOVLW 0x80
3AA0  1402     ANDWF [0x2], W, ACCESS
3A96  3802     SWAPF [0x2], W, ACCESS
3A98  0B0F     ANDLW 0xF
3A9A  0B07     ANDLW 0x7
3A9C  6FF1     MOVWF spi_buf, BANKED
3AA2  11F1     IORWF spi_buf, W, BANKED
3A8C  5002     MOVF [0x2], W, ACCESS
3A8E  0D04     MULLW 0x4
3A90  50F3     MOVF PROD, W, ACCESS
3A92  0B38     ANDLW 0x38
3A94  6FF2     MOVWF 0xF2, BANKED
3AA4  11F2     IORWF 0xF2, W, BANKED
3AA6  6EC0     MOVWF ADCON2, ACCESS
3AA8  AE01     BTFSS [0x1], 7, ACCESS
3AAA  D003     BRA 0x3AB2
3AAC  9C9E     BCF PIR1, 6, ACCESS
3AAE  8C9D     BSF PIE1, 6, ACCESS
3AB0  8CF2     BSF INTCON, 6, ACCESS
3AB2  80C2     BSF ADCON0, 0, ACCESS
3AB4  E941     SUBFSR 1, 0x1
3AB6  CFE5     MOVFF POSTDEC1, FSR2H
3AB8  FFDA     NOP
3ABA  CFE7     MOVFF INDF1, FSR2
3ABC  FFD9     NOP
3ABE  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/extended/stdclib/vfprintf.c  ----------------------------------
19D0  DB90     RCALL __pa_6
19D2  E986     SUBFSR 2, 0x6
20F2  CFD9     MOVFF FSR2, POSTINC1
20F4  FFE6     NOP
20F6  CFDA     MOVFF FSR2H, POSTINC1
20F8  FFE6     NOP
20FA  CFE1     MOVFF FSR1, FSR2
20FC  FFD9     NOP
20FE  CFE2     MOVFF FSR1H, FSR2H
2100  FFDA     NOP
2102  0012     RETURN 0
19D4  5001     MOVF [0x1], W, ACCESS
19D6  0601     DECF [0x1], F, ACCESS
19D8  0900     IORLW 0x0
19DA  E00C     BZ 0x19F4
19DC  EB02     MOVSF 0x2, 0xFE6
19DE  FFE6     NOP
19E0  EB03     MOVSF 0x3, 0xFE6
19E2  FFE6     NOP
19E4  EB00     MOVSF 0x0, 0xFE6
19E6  FFE6     NOP
19E8  DB69     RCALL __pa_3
19EA  E1F4     BNZ 0x19D4
19EC  1DF2     COMF 0xF2, W, BANKED
19EE  E1F2     BNZ 0x19D4
19F0  0E01     MOVLW 0x1
19F2  D001     BRA 0x19F6
19F4  0E00     MOVLW 0x0
19F6  E941     SUBFSR 1, 0x1
19F8  CFE5     MOVFF POSTDEC1, FSR2H
19FA  FFDA     NOP
19FC  CFE7     MOVFF INDF1, FSR2
19FE  FFD9     NOP
1A00  0012     RETURN 0
1A02  DB77     RCALL __pa_6
1A04  E989     SUBFSR 2, 0x9
1A06  E87B     ADDFSR 1, 0x3B
1A08  6A0A     CLRF [0xA], ACCESS
1A0A  6A0B     CLRF [0xB], ACCESS
1A0C  EB02     MOVSF 0x2, 0xFF6
1A0E  FFF6     NOP
1A10  EB03     MOVSF 0x3, 0xFF7
1A12  FFF7     NOP
1A14  EB04     MOVSF 0x4, 0xFF8
1A16  FFF8     NOP
1A18  0008     TBLRD*
1A1A  50F5     MOVF TABLAT, W, ACCESS
1A1C  6E09     MOVWF [0x9], ACCESS
1A1E  5009     MOVF [0x9], W, ACCESS
1A20  E101     BNZ 0x1A24
1A22  D32D     BRA 0x207E
2076  50D9     MOVF FSR2, W, ACCESS
2078  0F02     ADDLW 0x2
207A  D870     RCALL __pa_13
207C  D4CD     BRA 0x1A18
1A24  0E25     MOVLW 0x25
1A26  5C09     SUBWF [0x9], W, ACCESS
1A28  E001     BZ 0x1A2C
1A2A  D31B     BRA 0x2062
1A2C  6A0C     CLRF [0xC], ACCESS
1A2E  6A0D     CLRF [0xD], ACCESS
1A30  6A0E     CLRF [0xE], ACCESS
1A32  6A0F     CLRF [0xF], ACCESS
1A34  6A10     CLRF [0x10], ACCESS
1A36  DB2D     RCALL __pa_0
1A38  0E2D     MOVLW 0x2D
1A3A  5C09     SUBWF [0x9], W, ACCESS
1A3C  E00C     BZ 0x1A56
1A3E  0E2B     MOVLW 0x2B
1A40  5C09     SUBWF [0x9], W, ACCESS
1A42  E009     BZ 0x1A56
1A44  0E20     MOVLW 0x20
1A46  5C09     SUBWF [0x9], W, ACCESS
1A48  E006     BZ 0x1A56
1A4A  0E23     MOVLW 0x23
1A7E  D7DB     BRA 0x1A36
1A4C  5C09     SUBWF [0x9], W, ACCESS
1A4E  E003     BZ 0x1A56
1A50  0E30     MOVLW 0x30
1A52  5C09     SUBWF [0x9], W, ACCESS
1A54  E115     BNZ 0x1A80
1A56  5009     MOVF [0x9], W, ACCESS
1A58  0A30     XORLW 0x30
1A5A  E010     BZ 0x1A7C
1A5C  0A13     XORLW 0x13
1A5E  E00C     BZ 0x1A78
1A60  0A03     XORLW 0x3
1A62  E008     BZ 0x1A74
1A64  0A0B     XORLW 0xB
1A66  E004     BZ 0x1A70
1A68  0A06     XORLW 0x6
1A6A  E1E5     BNZ 0x1A36
1A6C  800C     BSF [0xC], 0, ACCESS
1A6E  D7E3     BRA 0x1A36
1A70  820C     BSF [0xC], 1, ACCESS
1A72  D7E1     BRA 0x1A36
1A74  840C     BSF [0xC], 2, ACCESS
1A76  D7DF     BRA 0x1A36
1A78  860C     BSF [0xC], 3, ACCESS
1A7A  D7DD     BRA 0x1A36
1A7C  880C     BSF [0xC], 4, ACCESS
1A80  0E2A     MOVLW 0x2A
1A82  5C09     SUBWF [0x9], W, ACCESS
1A84  E113     BNZ 0x1AAC
1A86  DBA5     RCALL __pa_22
21D2  DFD8     RCALL __pa_15
21D4  50EE     MOVF POSTINC0, W, ACCESS
21D6  6E1C     MOVWF [0x1C], ACCESS
21D8  50ED     MOVF POSTDEC0, W, ACCESS
21DA  6E1D     MOVWF [0x1D], ACCESS
1A88  E30D     BNC 0x1AA4
21DC  341D     RLCF [0x1D], W, ACCESS
21DE  0012     RETURN 0
1A8A  800C     BSF [0xC], 0, ACCESS
1A8C  EB1C     MOVSF 0x1C, 0x1F1
1A8E  F1F1     NOP
1A90  EB1D     MOVSF 0x1D, 0x1F2
1A92  F1F2     NOP
1A94  0101     MOVLB 0x1
1A96  6DF1     NEGF spi_buf, BANKED
1A98  1FF2     COMF 0xF2, F, BANKED
1A9A  0E00     MOVLW 0x0
1A9C  23F2     ADDWFC 0xF2, F, BANKED
1A9E  51F1     MOVF spi_buf, W, BANKED
1AA0  6E0D     MOVWF [0xD], ACCESS
1AA2  D002     BRA 0x1AA8
1AA4  EB9C     MOVSS 0x1C, 0xD
1AA6  F00D     NOP
1AA8  DAF4     RCALL __pa_0
1AAA  D007     BRA 0x1ABA
1AAC  6A12     CLRF [0x12], ACCESS
1AAE  DB3F     RCALL __pa_10
1AB0  E002     BZ 0x1AB6
1AB4  D7FC     BRA 0x1AAE
212E  5009     MOVF [0x9], W, ACCESS
2130  6EE6     MOVWF POSTINC1, ACCESS
2132  6AE6     CLRF POSTINC1, ACCESS
2134  ECE8     CALL 0x3FD0, 0
2136  F01F     NOP
2138  E942     SUBFSR 1, 0x2
213A  50F3     MOVF PROD, W, ACCESS
213C  0012     RETURN 0
1AB2  DB6B     RCALL __pa_16
218A  0E0A     MOVLW 0xA
218C  0212     MULWF [0x12], ACCESS
218E  50F3     MOVF PROD, W, ACCESS
2190  2409     ADDWF [0x9], W, ACCESS
2192  0FD0     ADDLW 0xD0
2194  6E12     MOVWF [0x12], ACCESS
2196  EF49     GOTO 0x2092
2198  F010     NOP
1AB6  EB92     MOVSS 0x12, 0xD
1AB8  F00D     NOP
1ABA  B00C     BTFSC [0xC], 0, ACCESS
1ABC  980C     BCF [0xC], 4, ACCESS
1ABE  0E2E     MOVLW 0x2E
1AC0  5C09     SUBWF [0x9], W, ACCESS
1AC2  E115     BNZ 0x1AEE
1AC4  DAE6     RCALL __pa_0
1AC6  0E2A     MOVLW 0x2A
1AC8  5C09     SUBWF [0x9], W, ACCESS
1ACA  E108     BNZ 0x1ADC
1ACC  DB82     RCALL __pa_22
1ACE  E204     BC 0x1AD8
1AD0  EB9C     MOVSS 0x1C, 0xE
1AD2  F00E     NOP
1AD4  0E01     MOVLW 0x1
1AD6  6E0F     MOVWF [0xF], ACCESS
1AD8  DADC     RCALL __pa_0
1ADA  D009     BRA 0x1AEE
1ADC  6A12     CLRF [0x12], ACCESS
1ADE  DB27     RCALL __pa_10
1AE0  E002     BZ 0x1AE6
1AE4  D7FC     BRA 0x1ADE
1AE2  DB53     RCALL __pa_16
1AE6  EB92     MOVSS 0x12, 0xE
1AE8  F00E     NOP
1AEA  0E01     MOVLW 0x1
1AEC  6E0F     MOVWF [0xF], ACCESS
1AEE  0E68     MOVLW 0x68
1AF0  5C09     SUBWF [0x9], W, ACCESS
1AF2  E107     BNZ 0x1B02
1AF4  DACE     RCALL __pa_0
1AF6  0E68     MOVLW 0x68
1AF8  5C09     SUBWF [0x9], W, ACCESS
1AFA  E11D     BNZ 0x1B36
1AFC  0E03     MOVLW 0x3
1AFE  6E10     MOVWF [0x10], ACCESS
1B00  D019     BRA 0x1B34
1B02  0E74     MOVLW 0x74
1B04  5C09     SUBWF [0x9], W, ACCESS
1B06  E016     BZ 0x1B34
1B08  0E7A     MOVLW 0x7A
1B0A  5C09     SUBWF [0x9], W, ACCESS
1B0C  E013     BZ 0x1B34
1B0E  0E48     MOVLW 0x48
1B10  5C09     SUBWF [0x9], W, ACCESS
1B12  E006     BZ 0x1B20
1B14  0E54     MOVLW 0x54
1B16  5C09     SUBWF [0x9], W, ACCESS
1B18  E003     BZ 0x1B20
1B1A  0E5A     MOVLW 0x5A
1B1C  5C09     SUBWF [0x9], W, ACCESS
1B1E  E102     BNZ 0x1B24
1B20  0E02     MOVLW 0x2
1B22  D007     BRA 0x1B32
1B24  0E6C     MOVLW 0x6C
1B26  5C09     SUBWF [0x9], W, ACCESS
1B28  E003     BZ 0x1B30
1B2A  0E6A     MOVLW 0x6A
1B2C  5C09     SUBWF [0x9], W, ACCESS
1B2E  E103     BNZ 0x1B36
1B30  0E01     MOVLW 0x1
1B32  6E10     MOVWF [0x10], ACCESS
1B34  DAAE     RCALL __pa_0
2092  50D9     MOVF FSR2, W, ACCESS
2094  0F02     ADDLW 0x2
2096  D862     RCALL __pa_13
2098  0008     TBLRD*
209A  50F5     MOVF TABLAT, W, ACCESS
209C  6E09     MOVWF [0x9], ACCESS
209E  0012     RETURN 0
215C  6EE9     MOVWF FSR0, ACCESS
215E  0E00     MOVLW 0x0
2160  20DA     ADDWFC FSR2H, W, ACCESS
2162  6EEA     MOVWF FSR0H, ACCESS
2164  2AEF     INCF INDF0, F, ACCESS
2166  CFEE     MOVFF POSTINC0, TBLPTR
2168  FFF6     NOP
216A  0E00     MOVLW 0x0
216C  22EF     ADDWFC INDF0, F, ACCESS
216E  CFEE     MOVFF POSTINC0, TBLPTRH
2170  FFF7     NOP
2172  22EF     ADDWFC INDF0, F, ACCESS
2174  CFEE     MOVFF POSTINC0, TBLPTRU
2176  FFF8     NOP
2178  0012     RETURN 0
1B36  5009     MOVF [0x9], W, ACCESS
1B38  0A6E     XORLW 0x6E
1B3A  E101     BNZ 0x1B3E
1B3C  D26E     BRA 0x201A
1B3E  0A1E     XORLW 0x1E
1B40  E101     BNZ 0x1B44
1B42  D128     BRA 0x1D94
1B44  0A20     XORLW 0x20
1B46  E101     BNZ 0x1B4A
1B48  D125     BRA 0x1D94
1B4A  0A3F     XORLW 0x3F
1B4C  E101     BNZ 0x1B50
1B4E  D0FD     BRA 0x1D4A
1B50  0A1A     XORLW 0x1A
1B52  E101     BNZ 0x1B56
1B54  D0FA     BRA 0x1D4A
1B56  0A0D     XORLW 0xD
1B58  E101     BNZ 0x1B5C
1B5A  D0F7     BRA 0x1D4A
1B5C  0A20     XORLW 0x20
1B5E  E101     BNZ 0x1B62
1B60  D0F4     BRA 0x1D4A
1B62  0A3A     XORLW 0x3A
1B64  E101     BNZ 0x1B68
1B66  D0F1     BRA 0x1D4A
1B68  0A20     XORLW 0x20
1B6A  E101     BNZ 0x1B6E
1B6C  D0EE     BRA 0x1D4A
1B6E  0A26     XORLW 0x26
1B70  E101     BNZ 0x1B74
1B72  D0EA     BRA 0x1D48
1B74  0A0D     XORLW 0xD
1B76  E101     BNZ 0x1B7A
1B78  D0E7     BRA 0x1D48
1B7A  0A1A     XORLW 0x1A
1B7C  E101     BNZ 0x1B80
1B7E  D09E     BRA 0x1CBC
1B80  0A20     XORLW 0x20
1B82  E03B     BZ 0x1BFA
1B84  0A30     XORLW 0x30
1B86  E01A     BZ 0x1BBC
1B88  0A46     XORLW 0x46
1B8A  E00E     BZ 0x1BA8
1B8C  0A25     XORLW 0x25
1B8E  E001     BZ 0x1B92
1B90  D272     BRA 0x2076
1B92  50D9     MOVF FSR2, W, ACCESS
1B94  0F02     ADDLW 0x2
1B96  6EE9     MOVWF FSR0, ACCESS
1B98  0E00     MOVLW 0x0
1B9A  20DA     ADDWFC FSR2H, W, ACCESS
1B9C  6EEA     MOVWF FSR0H, ACCESS
1B9E  0E01     MOVLW 0x1
1BA0  5EEE     SUBWF POSTINC0, F, ACCESS
1BA2  0E00     MOVLW 0x0
1BA4  5AEE     SUBWFB POSTINC0, F, ACCESS
1BA6  5AEE     SUBWFB POSTINC0, F, ACCESS
1BA8  DB0F     RCALL __pa_21
1BAA  0E25     MOVLW 0x25
1BAC  6EE6     MOVWF POSTINC1, ACCESS
1BAE  DA86     RCALL __pa_3
1BB0  E103     BNZ 0x1BB8
1BB2  1DF2     COMF 0xF2, W, BANKED
1BB4  E101     BNZ 0x1BB8
1BB6  D259     BRA 0x206A
1BB8  2A0A     INCF [0xA], F, ACCESS
1BBA  D25B     BRA 0x2072
1BBC  6A11     CLRF [0x11], ACCESS
1BBE  500D     MOVF [0xD], W, ACCESS
1BC0  0801     SUBLW 0x1
1BC2  E203     BC 0x1BCA
1BC4  040D     DECF [0xD], W, ACCESS
1BC6  6E11     MOVWF [0x11], ACCESS
1BC8  DAF5     RCALL __pa_19
1BCA  5011     MOVF [0x11], W, ACCESS
1BCC  E007     BZ 0x1BDC
1BCE  0E01     MOVLW 0x1
1BD0  140C     ANDWF [0xC], W, ACCESS
1BD2  E104     BNZ 0x1BDC
1BD4  DA6D     RCALL __pa_2
1BD6  E001     BZ 0x1BDA
1BD8  D248     BRA 0x206A
1BDA  6A11     CLRF [0x11], ACCESS
1BDC  DAD3     RCALL __pa_15
1BDE  50EF     MOVF INDF0, W, ACCESS
1BE0  6E09     MOVWF [0x9], ACCESS
1BE2  DACB     RCALL __pa_14
1BE4  E103     BNZ 0x1BEC
1BE6  1DF2     COMF 0xF2, W, BANKED
1BE8  E101     BNZ 0x1BEC
1BEA  D23F     BRA 0x206A
1BEC  2A0A     INCF [0xA], F, ACCESS
1BEE  0E00     MOVLW 0x0
1BF0  220B     ADDWFC [0xB], F, ACCESS
1BF2  DA5E     RCALL __pa_2
1BF4  E101     BNZ 0x1BF8
1BF6  D23F     BRA 0x2076
1BF8  D238     BRA 0x206A
1BFA  0E02     MOVLW 0x2
1BFC  5C10     SUBWF [0x10], W, ACCESS
1BFE  E108     BNZ 0x1C10
1C00  0E03     MOVLW 0x3
1C02  DA4E     RCALL __pa_1
1C04  50EE     MOVF POSTINC0, W, ACCESS
1C06  6E17     MOVWF [0x17], ACCESS
1C08  50EE     MOVF POSTINC0, W, ACCESS
1C0A  6E18     MOVWF [0x18], ACCESS
1C0C  50EF     MOVF INDF0, W, ACCESS
1C0E  D007     BRA 0x1C1E
1C10  DAE7     RCALL __pa_23
1C12  6BF3     CLRF data, BANKED
1C14  51F1     MOVF spi_buf, W, BANKED
1C16  6E17     MOVWF [0x17], ACCESS
1C18  51F2     MOVF 0xF2, W, BANKED
1C1A  6E18     MOVWF [0x18], ACCESS
1C1C  51F3     MOVF data, W, BANKED
1C1E  6E19     MOVWF [0x19], ACCESS
1C20  EB17     MOVSF 0x17, 0xFE6
1C22  FFE6     NOP
1C24  EB18     MOVSF 0x18, 0xFE6
1C26  FFE6     NOP
1C28  EB19     MOVSF 0x19, 0xFE6
1C2A  FFE6     NOP
1C2C  EC04     CALL 0x3608, 0
1C2E  F01B     NOP
1C30  E943     SUBFSR 1, 0x3
1C32  C0FA     MOVFF 0xFA, __tmp_0
1C34  F1F1     NOP
1C36  C0FB     MOVFF 0xFB, 0x1F2
1C38  F1F2     NOP
1C3A  C0FC     MOVFF 0xFC, 0x1F3
1C3C  F1F3     NOP
1C3E  0101     MOVLB 0x1
1C40  51F1     MOVF spi_buf, W, BANKED
1C42  6E1C     MOVWF [0x1C], ACCESS
1C44  51F2     MOVF 0xF2, W, BANKED
1C46  6E1D     MOVWF [0x1D], ACCESS
1C48  500F     MOVF [0xF], W, ACCESS
1C4A  E006     BZ 0x1C58
1C4C  501C     MOVF [0x1C], W, ACCESS
1C4E  5C0E     SUBWF [0xE], W, ACCESS
1C50  E203     BC 0x1C58
1C52  500E     MOVF [0xE], W, ACCESS
1C54  6E1C     MOVWF [0x1C], ACCESS
1C56  6A1D     CLRF [0x1D], ACCESS
1C58  501C     MOVF [0x1C], W, ACCESS
1C5A  5C0D     SUBWF [0xD], W, ACCESS
1C5C  E202     BC 0x1C62
1C5E  EB9C     MOVSS 0x1C, 0xD
1C60  F00D     NOP
1C62  DA50     RCALL __pa_7
2104  501C     MOVF [0x1C], W, ACCESS
2106  5C0D     SUBWF [0xD], W, ACCESS
2108  6E11     MOVWF [0x11], ACCESS
210A  D854     RCALL __pa_19
21B4  5011     MOVF [0x11], W, ACCESS
21B6  260A     ADDWF [0xA], F, ACCESS
21B8  0E00     MOVLW 0x0
21BA  220B     ADDWFC [0xB], F, ACCESS
21BC  0012     RETURN 0
1C64  E005     BZ 0x1C70
1C66  500D     MOVF [0xD], W, ACCESS
1C68  5C0E     SUBWF [0xE], W, ACCESS
1C6A  E202     BC 0x1C70
210C  500F     MOVF [0xF], W, ACCESS
210E  0012     RETURN 0
1C6C  EB8E     MOVSS 0xE, 0xD
1C6E  F00D     NOP
1C70  B00C     BTFSC [0xC], 0, ACCESS
1C72  D004     BRA 0x1C7C
1C74  DA1D     RCALL __pa_2
1C76  E001     BZ 0x1C7A
1C78  D1F8     BRA 0x206A
1C7A  6A11     CLRF [0x11], ACCESS
1C7C  6A12     CLRF [0x12], ACCESS
1C7E  EB17     MOVSF 0x17, 0xFF6
1C80  FFF6     NOP
1C82  EB18     MOVSF 0x18, 0xFF7
1C84  FFF7     NOP
1C86  EB19     MOVSF 0x19, 0xFF8
1C88  FFF8     NOP
1C8A  0008     TBLRD*
1C8C  50F5     MOVF TABLAT, W, ACCESS
1C8E  6E09     MOVWF [0x9], ACCESS
1C90  5009     MOVF [0x9], W, ACCESS
1C92  E010     BZ 0x1CB4
1C94  500D     MOVF [0xD], W, ACCESS
1C96  5C12     SUBWF [0x12], W, ACCESS
1C98  E20D     BC 0x1CB4
1CAC  50D9     MOVF FSR2, W, ACCESS
1CAE  0F17     ADDLW 0x17
1CB0  DA55     RCALL __pa_13
1CB2  D7EB     BRA 0x1C8A
1C9A  DA6F     RCALL __pa_14
1C9C  E103     BNZ 0x1CA4
1C9E  1DF2     COMF 0xF2, W, BANKED
1CA0  E101     BNZ 0x1CA4
1CA2  D1E3     BRA 0x206A
1CA4  2A0A     INCF [0xA], F, ACCESS
1CA6  0E00     MOVLW 0x0
1CA8  220B     ADDWFC [0xB], F, ACCESS
1CAA  2A12     INCF [0x12], F, ACCESS
1CB4  D9FD     RCALL __pa_2
1CB6  E101     BNZ 0x1CBA
1CB8  D1DE     BRA 0x2076
1CBA  D1D7     BRA 0x206A
1CBC  DA63     RCALL __pa_15
1CBE  50EE     MOVF POSTINC0, W, ACCESS
1CC0  6E1A     MOVWF [0x1A], ACCESS
1CC2  50ED     MOVF POSTDEC0, W, ACCESS
1CC4  6E1B     MOVWF [0x1B], ACCESS
1CC6  EB1A     MOVSF 0x1A, 0xFE6
1CC8  FFE6     NOP
1CCA  EB1B     MOVSF 0x1B, 0xFE6
1CCC  FFE6     NOP
1CCE  EC29     CALL 0x3652, 0
1CD0  F01B     NOP
1CD2  E942     SUBFSR 1, 0x2
1CD4  50F3     MOVF PROD, W, ACCESS
1CD6  6E1C     MOVWF [0x1C], ACCESS
1CD8  50F4     MOVF PRODH, W, ACCESS
1CDA  6E1D     MOVWF [0x1D], ACCESS
1CDC  500F     MOVF [0xF], W, ACCESS
1CDE  E006     BZ 0x1CEC
1CE0  501C     MOVF [0x1C], W, ACCESS
1CE2  5C0E     SUBWF [0xE], W, ACCESS
1CE4  E203     BC 0x1CEC
1CE6  500E     MOVF [0xE], W, ACCESS
1CE8  6E1C     MOVWF [0x1C], ACCESS
1CEA  6A1D     CLRF [0x1D], ACCESS
1CEC  501C     MOVF [0x1C], W, ACCESS
1CEE  5C0D     SUBWF [0xD], W, ACCESS
1CF0  E202     BC 0x1CF6
1CF2  EB9C     MOVSS 0x1C, 0xD
1CF4  F00D     NOP
1CF6  DA06     RCALL __pa_7
1CF8  E005     BZ 0x1D04
1CFA  500D     MOVF [0xD], W, ACCESS
1CFC  5C0E     SUBWF [0xE], W, ACCESS
1CFE  E202     BC 0x1D04
1D00  EB8E     MOVSS 0xE, 0xD
1D02  F00D     NOP
1D04  B00C     BTFSC [0xC], 0, ACCESS
1D06  D004     BRA 0x1D10
1D08  D9D3     RCALL __pa_2
1D0A  E001     BZ 0x1D0E
1D0C  D1AE     BRA 0x206A
1D0E  6A11     CLRF [0x11], ACCESS
1D10  6A12     CLRF [0x12], ACCESS
1D12  EB1A     MOVSF 0x1A, 0xFE9
1D14  FFE9     NOP
1D16  EB1B     MOVSF 0x1B, 0xFEA
1D18  FFEA     NOP
1D1A  50EF     MOVF INDF0, W, ACCESS
1D1C  6E09     MOVWF [0x9], ACCESS
1D1E  5009     MOVF [0x9], W, ACCESS
1D20  E00F     BZ 0x1D40
1D22  500D     MOVF [0xD], W, ACCESS
1D24  5C12     SUBWF [0x12], W, ACCESS
1D26  E20C     BC 0x1D40
1D3A  2A1A     INCF [0x1A], F, ACCESS
1D3C  221B     ADDWFC [0x1B], F, ACCESS
1D3E  D7E9     BRA 0x1D12
1D28  DA28     RCALL __pa_14
1D2A  E103     BNZ 0x1D32
1D2C  1DF2     COMF 0xF2, W, BANKED
1D2E  E101     BNZ 0x1D32
1D30  D19C     BRA 0x206A
1D32  2A0A     INCF [0xA], F, ACCESS
1D34  0E00     MOVLW 0x0
1D36  220B     ADDWFC [0xB], F, ACCESS
1D38  2A12     INCF [0x12], F, ACCESS
1D40  D9B7     RCALL __pa_2
1D42  E101     BNZ 0x1D46
1D44  D198     BRA 0x2076
1D46  D191     BRA 0x206A
1D48  8E0C     BSF [0xC], 7, ACCESS
1D4A  0410     DECF [0x10], W, ACCESS
1D4C  E10A     BNZ 0x1D62
1D4E  0E04     MOVLW 0x4
1D50  D9A7     RCALL __pa_1
1D52  50EE     MOVF POSTINC0, W, ACCESS
1D54  6E13     MOVWF [0x13], ACCESS
1D56  50EE     MOVF POSTINC0, W, ACCESS
1D58  6E14     MOVWF [0x14], ACCESS
1D5A  50EE     MOVF POSTINC0, W, ACCESS
1D5C  6E15     MOVWF [0x15], ACCESS
1D5E  50EF     MOVF INDF0, W, ACCESS
1D60  D032     BRA 0x1DC6
1D62  0E03     MOVLW 0x3
1D64  5C10     SUBWF [0x10], W, ACCESS
1D66  E116     BNZ 0x1D94
1D68  AE0C     BTFSS [0xC], 7, ACCESS
1D6A  D00C     BRA 0x1D84
1D6C  DA0B     RCALL __pa_15
1D6E  CFEF     MOVFF INDF0, __tmp_0
1D70  F1F1     NOP
1D72  0101     MOVLB 0x1
1D74  6BF2     CLRF 0xF2, BANKED
1D76  6BF3     CLRF data, BANKED
1D78  6BF4     CLRF spi_buf, BANKED
1D7A  AFF1     BTFSS spi_buf, 7, BANKED
1D7C  D023     BRA 0x1DC4
1D7E  69F2     SETF 0xF2, BANKED
1D80  69F3     SETF data, BANKED
1D82  D01F     BRA 0x1DC2
1D84  D9FF     RCALL __pa_15
1D86  CFEF     MOVFF INDF0, __tmp_0
1D88  F1F1     NOP
1D8A  0101     MOVLB 0x1
1D8C  51F1     MOVF spi_buf, W, BANKED
1D8E  6E13     MOVWF [0x13], ACCESS
1D90  6A14     CLRF [0x14], ACCESS
1D92  D020     BRA 0x1DD4
1D94  0E02     MOVLW 0x2
1D96  5C10     SUBWF [0x10], W, ACCESS
1D98  E10C     BNZ 0x1DB2
1D9A  AE0C     BTFSS [0xC], 7, ACCESS
1D9C  D006     BRA 0x1DAA
1D9E  0E03     MOVLW 0x3
1DA0  D97F     RCALL __pa_1
1DA2  D9B6     RCALL __pa_8
1DA4  AFF3     BTFSS data, 7, BANKED
1DA6  D00E     BRA 0x1DC4
2110  CFEE     MOVFF POSTINC0, __tmp_0
2112  F1F1     NOP
2114  CFEE     MOVFF POSTINC0, 0x1F2
2116  F1F2     NOP
2118  CFEF     MOVFF INDF0, 0x1F3
211A  F1F3     NOP
211C  0101     MOVLB 0x1
211E  6BF4     CLRF spi_buf, BANKED
2120  0012     RETURN 0
1DA8  D00C     BRA 0x1DC2
1DAA  0E03     MOVLW 0x3
1DAC  D979     RCALL __pa_1
1DAE  D9B0     RCALL __pa_8
1DB0  D009     BRA 0x1DC4
1DB2  AE0C     BTFSS [0xC], 7, ACCESS
1DB4  D00A     BRA 0x1DCA
1DB6  DA14     RCALL __pa_23
1DB8  6BF3     CLRF data, BANKED
1DBA  6BF4     CLRF spi_buf, BANKED
1DBC  AFF2     BTFSS 0xF2, 7, BANKED
1DBE  D002     BRA 0x1DC4
1DC0  69F3     SETF data, BANKED
1DC2  69F4     SETF spi_buf, BANKED
1DC4  D9BC     RCALL __pa_11
1DC6  6E16     MOVWF [0x16], ACCESS
2122  CFEE     MOVFF POSTINC0, __tmp_0
2124  F1F1     NOP
2126  CFEF     MOVFF INDF0, 0x1F2
2128  F1F2     NOP
212A  0101     MOVLB 0x1
212C  0012     RETURN 0
213E  51F1     MOVF spi_buf, W, BANKED
2140  6E13     MOVWF [0x13], ACCESS
2142  51F2     MOVF 0xF2, W, BANKED
2144  6E14     MOVWF [0x14], ACCESS
2146  51F3     MOVF data, W, BANKED
2148  6E15     MOVWF [0x15], ACCESS
214A  51F4     MOVF spi_buf, W, BANKED
214C  0012     RETURN 0
21E0  DFD1     RCALL __pa_15
21E2  EF91     GOTO 0x2122
21E4  F010     NOP
1DC8  D007     BRA 0x1DD8
1DCA  DA0A     RCALL __pa_23
1DCC  51F1     MOVF spi_buf, W, BANKED
1DCE  6E13     MOVWF [0x13], ACCESS
1DD0  51F2     MOVF 0xF2, W, BANKED
1DD2  6E14     MOVWF [0x14], ACCESS
1DD4  6A15     CLRF [0x15], ACCESS
1DD6  6A16     CLRF [0x16], ACCESS
1DD8  500F     MOVF [0xF], W, ACCESS
1DDA  E102     BNZ 0x1DE0
1DDC  0E01     MOVLW 0x1
1DDE  6E0E     MOVWF [0xE], ACCESS
1DE0  6A1E     CLRF [0x1E], ACCESS
1DE2  6A1F     CLRF [0x1F], ACCESS
1DE4  50D9     MOVF FSR2, W, ACCESS
1DE6  0F40     ADDLW 0x40
1DE8  6EE6     MOVWF POSTINC1, ACCESS
1DEA  0E00     MOVLW 0x0
1DEC  20DA     ADDWFC FSR2H, W, ACCESS
1DEE  6EE6     MOVWF POSTINC1, ACCESS
1DF0  52E5     MOVF POSTDEC1, F, ACCESS
1DF2  50E5     MOVF POSTDEC1, W, ACCESS
1DF4  6E43     MOVWF [0x43], ACCESS
1DF6  50E7     MOVF INDF1, W, ACCESS
1DF8  6E42     MOVWF [0x42], ACCESS
1DFA  6A41     CLRF [0x41], ACCESS
1DFC  6A11     CLRF [0x11], ACCESS
1DFE  0E0A     MOVLW 0xA
1E00  6E10     MOVWF [0x10], ACCESS
1E02  5009     MOVF [0x9], W, ACCESS
1E04  0A78     XORLW 0x78
1E06  E012     BZ 0x1E2C
1E08  0A20     XORLW 0x20
1E0A  E010     BZ 0x1E2C
1E0C  0A28     XORLW 0x28
1E0E  E00C     BZ 0x1E28
1E10  0A20     XORLW 0x20
1E12  E00A     BZ 0x1E28
1E14  0A3F     XORLW 0x3F
1E16  E006     BZ 0x1E24
1E18  0A0D     XORLW 0xD
1E1A  E002     BZ 0x1E20
1E1C  0A20     XORLW 0x20
1E1E  E108     BNZ 0x1E30
1E20  0E02     MOVLW 0x2
1E22  D005     BRA 0x1E2E
1E24  0E08     MOVLW 0x8
1E26  D003     BRA 0x1E2E
1E28  0E08     MOVLW 0x8
1E2A  2609     ADDWF [0x9], F, ACCESS
1E2C  0E10     MOVLW 0x10
1E2E  6E10     MOVWF [0x10], ACCESS
1E30  BE0C     BTFSC [0xC], 7, ACCESS
1E32  D002     BRA 0x1E38
1E34  920C     BCF [0xC], 1, ACCESS
1E36  940C     BCF [0xC], 2, ACCESS
1E38  0E80     MOVLW 0x80
1E3A  140C     ANDWF [0xC], W, ACCESS
1E3C  E017     BZ 0x1E6C
1E3E  3416     RLCF [0x16], W, ACCESS
1E40  E315     BNC 0x1E6C
1E42  68E6     SETF POSTINC1, ACCESS
1E44  68E6     SETF POSTINC1, ACCESS
1E46  68E6     SETF POSTINC1, ACCESS
1E48  68E6     SETF POSTINC1, ACCESS
1E4A  D942     RCALL __pa_4
1E4C  ECC9     CALL 0x2792, 0
1E4E  F013     NOP
1E50  52E5     MOVF POSTDEC1, F, ACCESS
1E52  CFE5     MOVFF POSTDEC1, 0x1F4
1E54  F1F4     NOP
1E56  CFE5     MOVFF POSTDEC1, 0x1F3
1E58  F1F3     NOP
1E5A  CFE5     MOVFF POSTDEC1, 0x1F2
1E5C  F1F2     NOP
1E5E  CFE7     MOVFF INDF1, __tmp_0
1E60  F1F1     NOP
1E62  0101     MOVLB 0x1
1E64  D96C     RCALL __pa_11
1E66  6E16     MOVWF [0x16], ACCESS
1E68  0E2D     MOVLW 0x2D
1E6A  D007     BRA 0x1E7A
1E6C  A20C     BTFSS [0xC], 1, ACCESS
1E6E  D002     BRA 0x1E74
1E70  0E2B     MOVLW 0x2B
1E72  D003     BRA 0x1E7A
1E74  A40C     BTFSS [0xC], 2, ACCESS
1E76  D004     BRA 0x1E80
1E78  0E20     MOVLW 0x20
1E7A  6E20     MOVWF [0x20], ACCESS
1E7C  2A1E     INCF [0x1E], F, ACCESS
1E7E  D001     BRA 0x1E82
1E80  6A20     CLRF [0x20], ACCESS
1E82  500E     MOVF [0xE], W, ACCESS
1E84  E105     BNZ 0x1E90
1E86  5013     MOVF [0x13], W, ACCESS
1E88  1014     IORWF [0x14], W, ACCESS
1E8A  1015     IORWF [0x15], W, ACCESS
1E8C  1016     IORWF [0x16], W, ACCESS
1E8E  E061     BZ 0x1F52
1E90  0101     MOVLB 0x1
1E92  0E60     MOVLW 0x60
1E94  6FF1     MOVWF spi_buf, BANKED
1E96  0E40     MOVLW 0x40
1E98  6FF2     MOVWF 0xF2, BANKED
1E9A  0E00     MOVLW 0x0
1E9C  6FF3     MOVWF data, BANKED
1E9E  D983     RCALL __pa_18
1EA0  ECC9     CALL 0x2592, 0
1EA2  F012     NOP
1EA4  52E5     MOVF POSTDEC1, F, ACCESS
1EA6  CFE5     MOVFF POSTDEC1, 0x1F7
1EA8  F1F7     NOP
1EAA  CFE5     MOVFF POSTDEC1, 0x1F6
1EAC  F1F6     NOP
1EAE  CFE5     MOVFF POSTDEC1, 0x1F5
1EB0  F1F5     NOP
1EB2  CFE7     MOVFF INDF1, 0x1F4
1EB4  F1F4     NOP
1EB6  0101     MOVLB 0x1
1EB8  51F1     MOVF spi_buf, W, BANKED
1EBA  25F4     ADDWF spi_buf, W, BANKED
1EBC  6EF3     MOVWF PROD, ACCESS
1EBE  51F2     MOVF 0xF2, W, BANKED
1EC0  21F5     ADDWFC 0xF5, W, BANKED
1EC2  6EF4     MOVWF PRODH, ACCESS
1EC4  51F3     MOVF data, W, BANKED
1EC6  21F6     ADDWFC upper_lower, W, BANKED
1EC8  6EF8     MOVWF TBLPTRU, ACCESS
1ECA  CFF4     MOVFF PRODH, TBLPTRH
1ECC  FFF7     NOP
1ECE  CFF3     MOVFF PROD, TBLPTR
1ED0  FFF6     NOP
1ED2  0008     TBLRD*
1ED4  50F5     MOVF TABLAT, W, ACCESS
1ED6  6E12     MOVWF [0x12], ACCESS
21A6  EB10     MOVSF 0x10, 0xFE6
21A8  FFE6     NOP
21AA  6AE6     CLRF POSTINC1, ACCESS
21AC  6AE6     CLRF POSTINC1, ACCESS
21AE  6AE6     CLRF POSTINC1, ACCESS
21B0  EF68     GOTO 0x20D0
21B2  F010     NOP
1ED8  0E58     MOVLW 0x58
1EDA  5C09     SUBWF [0x9], W, ACCESS
1EDC  E105     BNZ 0x1EE8
1EDE  0E61     MOVLW 0x61
1EE0  5C12     SUBWF [0x12], W, ACCESS
1EE2  E302     BNC 0x1EE8
1EE4  0E20     MOVLW 0x20
1EE6  5E12     SUBWF [0x12], F, ACCESS
1EE8  D95E     RCALL __pa_18
1EEA  ECC6     CALL 0x258C, 0
1EEC  F012     NOP
1EEE  52E5     MOVF POSTDEC1, F, ACCESS
1EF0  50E5     MOVF POSTDEC1, W, ACCESS
1EF2  6E16     MOVWF [0x16], ACCESS
1EF4  50E5     MOVF POSTDEC1, W, ACCESS
1EF6  6E15     MOVWF [0x15], ACCESS
1EF8  50E5     MOVF POSTDEC1, W, ACCESS
1EFA  6E14     MOVWF [0x14], ACCESS
1EFC  50E7     MOVF INDF1, W, ACCESS
1EFE  6E13     MOVWF [0x13], ACCESS
20D0  EB13     MOVSF 0x13, 0xFE6
20D2  FFE6     NOP
20D4  EB14     MOVSF 0x14, 0xFE6
20D6  FFE6     NOP
20D8  EB15     MOVSF 0x15, 0xFE6
20DA  FFE6     NOP
20DC  EB16     MOVSF 0x16, 0xFE6
20DE  FFE6     NOP
20E0  0012     RETURN 0
1F00  EB42     MOVSF 0x42, 0xFE9
1F02  FFE9     NOP
1F04  EB43     MOVSF 0x43, 0xFEA
1F06  FFEA     NOP
1F08  0642     DECF [0x42], F, ACCESS
1F0A  0E00     MOVLW 0x0
1F0C  5A43     SUBWFB [0x43], F, ACCESS
1F0E  EB12     MOVSF 0x12, 0xFEF
1F10  FFEF     NOP
1F12  2A1E     INCF [0x1E], F, ACCESS
1F14  5013     MOVF [0x13], W, ACCESS
1F16  1014     IORWF [0x14], W, ACCESS
1F18  1015     IORWF [0x15], W, ACCESS
1F1A  1016     IORWF [0x16], W, ACCESS
1F1C  E1B9     BNZ 0x1E90
1F1E  A60C     BTFSS [0xC], 3, ACCESS
1F20  D019     BRA 0x1F54
1F22  0E6F     MOVLW 0x6F
1F24  5C09     SUBWF [0x9], W, ACCESS
1F26  E106     BNZ 0x1F34
1F28  500E     MOVF [0xE], W, ACCESS
1F2A  5C1E     SUBWF [0x1E], W, ACCESS
1F2C  E313     BNC 0x1F54
1F2E  281E     INCF [0x1E], W, ACCESS
1F30  6E0E     MOVWF [0xE], ACCESS
1F32  D010     BRA 0x1F54
1F34  0E78     MOVLW 0x78
1F36  5C09     SUBWF [0x9], W, ACCESS
1F38  E009     BZ 0x1F4C
1F3A  0E58     MOVLW 0x58
1F3C  5C09     SUBWF [0x9], W, ACCESS
1F3E  E006     BZ 0x1F4C
1F40  0E62     MOVLW 0x62
1F42  5C09     SUBWF [0x9], W, ACCESS
1F44  E003     BZ 0x1F4C
1F46  0E42     MOVLW 0x42
1F48  5C09     SUBWF [0x9], W, ACCESS
1F4A  E104     BNZ 0x1F54
1F4C  0E02     MOVLW 0x2
1F4E  6E1F     MOVWF [0x1F], ACCESS
1F50  D001     BRA 0x1F54
1F52  6A1E     CLRF [0x1E], ACCESS
1F54  0E10     MOVLW 0x10
1F56  140C     ANDWF [0xC], W, ACCESS
1F5A  500D     MOVF [0xD], W, ACCESS
1F5C  5C0E     SUBWF [0xE], W, ACCESS
1F58  E007     BZ 0x1F68
1F5E  E204     BC 0x1F68
1F60  500F     MOVF [0xF], W, ACCESS
1F62  E102     BNZ 0x1F68
1F64  EB8D     MOVSS 0xD, 0xE
1F66  F00E     NOP
1F68  500E     MOVF [0xE], W, ACCESS
1F6A  5C1E     SUBWF [0x1E], W, ACCESS
1F6C  E203     BC 0x1F74
1F6E  501E     MOVF [0x1E], W, ACCESS
1F70  5E0E     SUBWF [0xE], F, ACCESS
1F72  D001     BRA 0x1F76
1F74  6A0E     CLRF [0xE], ACCESS
1F76  500E     MOVF [0xE], W, ACCESS
1F78  241E     ADDWF [0x1E], W, ACCESS
1F7A  241F     ADDWF [0x1F], W, ACCESS
1F7C  80D8     BSF STATUS, 0, ACCESS
1F7E  540D     SUBFWB [0xD], W, ACCESS
1F80  E207     BC 0x1F90
1F82  500E     MOVF [0xE], W, ACCESS
1F84  5C0D     SUBWF [0xD], W, ACCESS
1F86  80D8     BSF STATUS, 0, ACCESS
1F88  541E     SUBFWB [0x1E], W, ACCESS
1F8A  80D8     BSF STATUS, 0, ACCESS
1F8C  541F     SUBFWB [0x1F], W, ACCESS
1F8E  6E11     MOVWF [0x11], ACCESS
1F90  0E01     MOVLW 0x1
1F92  140C     ANDWF [0xC], W, ACCESS
1F94  E106     BNZ 0x1FA2
1F96  5011     MOVF [0x11], W, ACCESS
1F98  E004     BZ 0x1FA2
1F9A  D88A     RCALL __pa_2
1F9C  E166     BNZ 0x206A
1F9E  D90A     RCALL __pa_19
1FA0  6A11     CLRF [0x11], ACCESS
1FA2  5020     MOVF [0x20], W, ACCESS
1FA4  E007     BZ 0x1FB4
1FA6  D910     RCALL __pa_21
1FA8  EB20     MOVSF 0x20, 0xFE6
1FAA  FFE6     NOP
1FAC  D887     RCALL __pa_3
1FAE  E102     BNZ 0x1FB4
1FB0  1DF2     COMF 0xF2, W, BANKED
1FB2  E05B     BZ 0x206A
1FB4  501F     MOVF [0x1F], W, ACCESS
1FB6  E00B     BZ 0x1FCE
1FB8  D907     RCALL __pa_21
1FBA  0E30     MOVLW 0x30
1FBC  6EE6     MOVWF POSTINC1, ACCESS
1FBE  D87E     RCALL __pa_3
1FC0  E102     BNZ 0x1FC6
1FC2  1DF2     COMF 0xF2, W, BANKED
1FC4  E052     BZ 0x206A
1FC6  D8D9     RCALL __pa_14
1FC8  E102     BNZ 0x1FCE
1FCA  1DF2     COMF 0xF2, W, BANKED
1FCC  E04E     BZ 0x206A
1FCE  500E     MOVF [0xE], W, ACCESS
1FD0  5C1F     SUBWF [0x1F], W, ACCESS
1FD2  E202     BC 0x1FD8
1FD4  501F     MOVF [0x1F], W, ACCESS
1FD6  5E0E     SUBWF [0xE], F, ACCESS
1FD8  0E30     MOVLW 0x30
1FDA  6EE6     MOVWF POSTINC1, ACCESS
1FDC  EB0E     MOVSF 0xE, 0xFE6
1FDE  FFE6     NOP
1FE0  D8DC     RCALL __pa_17
1FE2  E143     BNZ 0x206A
219A  D816     RCALL __pa_21
219C  ECE8     CALL 0x19D0, 0
219E  F00C     NOP
21A0  E944     SUBFSR 1, 0x4
21A2  0900     IORLW 0x0
21A4  0012     RETURN 0
21C8  EB05     MOVSF 0x5, 0xFE6
21CA  FFE6     NOP
21CC  EB06     MOVSF 0x6, 0xFE6
21CE  FFE6     NOP
21D0  0012     RETURN 0
1FE4  2A42     INCF [0x42], F, ACCESS
1FE6  0E00     MOVLW 0x0
1FE8  2243     ADDWFC [0x43], F, ACCESS
1FEA  EB42     MOVSF 0x42, 0xFE9
1FEC  FFE9     NOP
1FEE  EB43     MOVSF 0x43, 0xFEA
1FF0  FFEA     NOP
1FF2  50EF     MOVF INDF0, W, ACCESS
1FF4  6E12     MOVWF [0x12], ACCESS
1FF6  5012     MOVF [0x12], W, ACCESS
1FF8  E008     BZ 0x200A
1FFA  D8E6     RCALL __pa_21
1FFC  EB12     MOVSF 0x12, 0xFE6
1FFE  FFE6     NOP
2000  D85D     RCALL __pa_3
2002  E1F0     BNZ 0x1FE4
2004  1DF2     COMF 0xF2, W, BANKED
2006  E1EE     BNZ 0x1FE4
2008  D030     BRA 0x206A
200A  D852     RCALL __pa_2
200C  E12E     BNZ 0x206A
20B0  0E20     MOVLW 0x20
20B2  6EE6     MOVWF POSTINC1, ACCESS
20B4  EB11     MOVSF 0x11, 0xFE6
20B6  FFE6     NOP
20B8  EFCD     GOTO 0x219A
20BA  F010     NOP
200E  500E     MOVF [0xE], W, ACCESS
2010  241E     ADDWF [0x1E], W, ACCESS
2012  2411     ADDWF [0x11], W, ACCESS
2014  241F     ADDWF [0x1F], W, ACCESS
2016  260A     ADDWF [0xA], F, ACCESS
2018  D02C     BRA 0x2072
201A  5010     MOVF [0x10], W, ACCESS
201C  0A03     XORLW 0x3
201E  E01C     BZ 0x2058
2020  0A01     XORLW 0x1
2022  E014     BZ 0x204C
2024  0A03     XORLW 0x3
2026  E007     BZ 0x2036
2036  D88B     RCALL __pa_12
2038  6BF4     CLRF spi_buf, BANKED
203A  AFF2     BTFSS 0xF2, 7, BANKED
203C  D002     BRA 0x2042
203E  69F3     SETF data, BANKED
2040  69F4     SETF spi_buf, BANKED
2042  D8A0     RCALL __pa_15
2044  D84E     RCALL __pa_5
2046  C1F4     MOVFF 0x1F4, POSTINC0
2048  FFEE     NOP
20E2  D86D     RCALL __pa_20
20E4  C1F1     MOVFF __tmp_0, POSTINC0
20E6  FFEE     NOP
20E8  C1F2     MOVFF 0x1F2, POSTINC0
20EA  FFEE     NOP
20EC  C1F3     MOVFF 0x1F3, POSTINC0
20EE  FFEE     NOP
20F0  0012     RETURN 0
214E  EB0A     MOVSF 0xA, 0x1F1
2150  F1F1     NOP
2152  EB0B     MOVSF 0xB, 0x1F2
2154  F1F2     NOP
2156  0101     MOVLB 0x1
2158  6BF3     CLRF data, BANKED
215A  0012     RETURN 0
21BE  50EE     MOVF POSTINC0, W, ACCESS
21C0  CFEF     MOVFF INDF0, FSR0H
21C2  FFEA     NOP
21C4  6EE9     MOVWF FSR0, ACCESS
21C6  0012     RETURN 0
204A  D015     BRA 0x2076
204C  D880     RCALL __pa_12
204E  BFF2     BTFSC 0xF2, 7, BANKED
2050  69F3     SETF data, BANKED
2052  D898     RCALL __pa_15
2054  D846     RCALL __pa_5
2056  D00F     BRA 0x2076
2058  D895     RCALL __pa_15
205A  D8B1     RCALL __pa_20
205C  EB0A     MOVSF 0xA, 0xFEF
205E  FFEF     NOP
20A0  5E00     SUBWF [0x0], F, ACCESS
20A2  0E00     MOVLW 0x0
20A4  5A01     SUBWFB [0x1], F, ACCESS
20A6  EB00     MOVSF 0x0, 0xFE9
20A8  FFE9     NOP
20AA  EB01     MOVSF 0x1, 0xFEA
20AC  FFEA     NOP
20AE  0012     RETURN 0
2184  0E02     MOVLW 0x2
2186  EF50     GOTO 0x20A0
2188  F010     NOP
2060  D00A     BRA 0x2076
2028  D8AD     RCALL __pa_15
202A  D8C9     RCALL __pa_20
202C  EB0A     MOVSF 0xA, 0xFEE
202E  FFEE     NOP
2030  EB0B     MOVSF 0xB, 0xFED
2032  FFED     NOP
2034  D020     BRA 0x2076
2062  D88B     RCALL __pa_14
2064  E105     BNZ 0x2070
2066  1DF2     COMF 0xF2, W, BANKED
2068  E103     BNZ 0x2070
20BC  ECC9     CALL 0x3992, 0
20BE  F01C     NOP
20C0  E943     SUBFSR 1, 0x3
20C2  CFF3     MOVFF PROD, __tmp_0
20C4  F1F1     NOP
20C6  CFF4     MOVFF PRODH, 0x1F2
20C8  F1F2     NOP
20CA  0101     MOVLB 0x1
20CC  1CF3     COMF PROD, W, ACCESS
20CE  0012     RETURN 0
217A  D826     RCALL __pa_21
217C  EB09     MOVSF 0x9, 0xFE6
217E  FFE6     NOP
2180  EF5E     GOTO 0x20BC
2182  F010     NOP
206A  68F3     SETF PROD, ACCESS
206C  68F4     SETF PRODH, ACCESS
206E  D00B     BRA 0x2086
2070  2A0A     INCF [0xA], F, ACCESS
2072  0E00     MOVLW 0x0
2074  220B     ADDWFC [0xB], F, ACCESS
207E  EB0A     MOVSF 0xA, 0xFF3
2080  FFF3     NOP
2082  EB0B     MOVSF 0xB, 0xFF4
2084  FFF4     NOP
2086  E97C     SUBFSR 1, 0x3C
2088  CFE5     MOVFF POSTDEC1, FSR2H
208A  FFDA     NOP
208C  CFE7     MOVFF INDF1, FSR2
208E  FFD9     NOP
2090  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/extended/stdclib/strlen.asm  ----------------------------------
3652  0EFE     MOVLW 0xFE
3654  CFE3     MOVFF PLUSW1, FSR0
3656  FFE9     NOP
3658  0EFF     MOVLW 0xFF
365A  CFE3     MOVFF PLUSW1, FSR0H
365C  FFEA     NOP
365E  6AF3     CLRF PROD, ACCESS
3660  6AF4     CLRF PRODH, ACCESS
3662  52EE     MOVF POSTINC0, F, ACCESS
3664  E003     BZ jEnd
3666  4AF3     INFSNZ PROD, F, ACCESS
3668  2AF4     INCF PRODH, F, ACCESS
366A  D7FB     BRA jLoop
366C  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/extended/stdclib/sprintf.c  -----------------------------------
3920  CFD9     MOVFF FSR2, POSTINC1
3922  FFE6     NOP
3924  CFDA     MOVFF FSR2H, POSTINC1
3926  FFE6     NOP
3928  CFE1     MOVFF FSR1, FSR2
392A  FFD9     NOP
392C  CFE2     MOVFF FSR1H, FSR2H
392E  FFDA     NOP
3930  E987     SUBFSR 2, 0x7
3932  E844     ADDFSR 1, 0x4
3934  CFD9     MOVFF FSR2, POSTINC1
3936  FFE6     NOP
3938  CFDA     MOVFF FSR2H, POSTINC1
393A  FFE6     NOP
393C  52E5     MOVF POSTDEC1, F, ACCESS
393E  50E5     MOVF POSTDEC1, W, ACCESS
3940  6E0A     MOVWF [0xA], ACCESS
3942  50E7     MOVF INDF1, W, ACCESS
3944  6E09     MOVWF [0x9], ACCESS
3946  EB09     MOVSF 0x9, 0xFE6
3948  FFE6     NOP
394A  EB0A     MOVSF 0xA, 0xFE6
394C  FFE6     NOP
394E  EB00     MOVSF 0x0, 0xFE6
3950  FFE6     NOP
3952  EB01     MOVSF 0x1, 0xFE6
3954  FFE6     NOP
3956  EB02     MOVSF 0x2, 0xFE6
3958  FFE6     NOP
395A  50D9     MOVF FSR2, W, ACCESS
395C  0F03     ADDLW 0x3
395E  6EE6     MOVWF POSTINC1, ACCESS
3960  0E00     MOVLW 0x0
3962  20DA     ADDWFC FSR2H, W, ACCESS
3964  6EE6     MOVWF POSTINC1, ACCESS
3966  EC01     CALL 0x1A02, 0
3968  F00D     NOP
396A  E947     SUBFSR 1, 0x7
396C  50F3     MOVF PROD, W, ACCESS
396E  6E07     MOVWF [0x7], ACCESS
3970  50F4     MOVF PRODH, W, ACCESS
3972  6E08     MOVWF [0x8], ACCESS
3974  EB03     MOVSF 0x3, 0xFE9
3976  FFE9     NOP
3978  EB04     MOVSF 0x4, 0xFEA
397A  FFEA     NOP
397C  6AEF     CLRF INDF0, ACCESS
397E  EB07     MOVSF 0x7, 0xFF3
3980  FFF3     NOP
3982  EB08     MOVSF 0x8, 0xFF4
3984  FFF4     NOP
3986  E945     SUBFSR 1, 0x5
3988  CFE5     MOVFF POSTDEC1, FSR2H
398A  FFDA     NOP
398C  CFE7     MOVFF INDF1, FSR2
398E  FFD9     NOP
3990  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/extended/stdclib/slenpgm.asm  ---------------------------------
3608  0EFF     MOVLW 0xFF
360A  CFE3     MOVFF PLUSW1, TBLPTRU
360C  FFF8     NOP
360E  52E5     MOVF POSTDEC1, F, ACCESS
3610  0EFF     MOVLW 0xFF
3612  CFE3     MOVFF PLUSW1, TBLPTRH
3614  FFF7     NOP
3616  52E5     MOVF POSTDEC1, F, ACCESS
3618  0EFF     MOVLW 0xFF
361A  CFE3     MOVFF PLUSW1, TBLPTR
361C  FFF6     NOP
361E  52E5     MOVF POSTDEC1, F, ACCESS
3620  6AE6     CLRF POSTINC1, ACCESS
3622  6AE6     CLRF POSTINC1, ACCESS
3624  6AE6     CLRF POSTINC1, ACCESS
3626  0009     TBLRD*+
3628  52F5     MOVF TABLAT, F, ACCESS
362A  E009     BZ jEnd
362C  0EFD     MOVLW 0xFD
362E  2AE3     INCF PLUSW1, F, ACCESS
3630  E105     BNZ _2jEnd
3632  0EFE     MOVLW 0xFE
3634  2AE3     INCF PLUSW1, F, ACCESS
3636  E102     BNZ _2jEnd
3638  0EFF     MOVLW 0xFF
363A  2AE3     INCF PLUSW1, F, ACCESS
363C  D7F4     BRA jLoop
363E  0EFD     MOVLW 0xFD
3640  CFE3     MOVFF PLUSW1, 0xFA
3642  F0FA     NOP
3644  0EFE     MOVLW 0xFE
3646  CFE3     MOVFF PLUSW1, 0xFB
3648  F0FB     NOP
364A  0EFF     MOVLW 0xFF
364C  CFE3     MOVFF PLUSW1, 0xFC
364E  F0FC     NOP
3650  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/extended/stdclib/rand.asm  ------------------------------------
3D16  0EFE     MOVLW 0xFE
3D18  CFE3     MOVFF PLUSW1, Seed
3D1A  F0FE     NOP
3D1C  0EFF     MOVLW 0xFF
3D1E  CFE3     MOVFF PLUSW1, 0xFF
3D20  F0FF     NOP
3D22  0012     RETURN 0
3D24  0E35     MOVLW 0x35
3D26  6EE6     MOVWF POSTINC1, ACCESS
3D28  0E45     MOVLW 0x45
3D2A  6EE6     MOVWF POSTINC1, ACCESS
3D2C  C0FE     MOVFF Seed, POSTINC1
3D2E  FFE6     NOP
3D30  C0FF     MOVFF 0xFF, POSTINC1
3D32  FFE6     NOP
3D34  EC91     CALL 0x2922, 0
3D36  F014     NOP
3D38  52E5     MOVF POSTDEC1, F, ACCESS
3D3A  CFE5     MOVFF POSTDEC1, 0xFF
3D3C  F0FF     NOP
3D3E  CFE7     MOVFF INDF1, Seed
3D40  F0FE     NOP
3D42  0100     MOVLB 0x0
3D44  2BFE     INCF Seed, F, BANKED
3D46  6AE8     CLRF WREG, ACCESS
3D48  23FF     ADDWFC 0xFF, F, BANKED
3D4A  9FFF     BCF 0xFF, 7, BANKED
3D4C  C0FE     MOVFF Seed, PROD
3D4E  FFF3     NOP
3D50  C0FF     MOVFF 0xFF, PRODH
3D52  FFF4     NOP
3D54  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/extended/stdclib/putc.c  --------------------------------------
3992  CFD9     MOVFF FSR2, POSTINC1
3994  FFE6     NOP
3996  CFDA     MOVFF FSR2H, POSTINC1
3998  FFE6     NOP
399A  CFE1     MOVFF FSR1, FSR2
399C  FFD9     NOP
399E  CFE2     MOVFF FSR1H, FSR2H
39A0  FFDA     NOP
39A2  E985     SUBFSR 2, 0x5
39A4  3401     RLCF [0x1], W, ACCESS
39A6  E215     BC 0x39D2
39A8  EB00     MOVSF 0x0, 0xFE9
39AA  FFE9     NOP
39AC  EB01     MOVSF 0x1, 0xFEA
39AE  FFEA     NOP
39B0  CFEE     MOVFF POSTINC0, PROD
39B2  FFF3     NOP
39B4  CFED     MOVFF POSTDEC0, PRODH
39B6  FFF4     NOP
39B8  2AEE     INCF POSTINC0, F, ACCESS
39BA  0E00     MOVLW 0x0
39BC  22EF     ADDWFC INDF0, F, ACCESS
39BE  CFF3     MOVFF PROD, FSR0
39C0  FFE9     NOP
39C2  CFF4     MOVFF PRODH, FSR0H
39C4  FFEA     NOP
39C6  EB02     MOVSF 0x2, 0xFEF
39C8  FFEF     NOP
39CA  50EF     MOVF INDF0, W, ACCESS
39CC  6EF3     MOVWF PROD, ACCESS
39CE  6AF4     CLRF PRODH, ACCESS
39D0  D00D     BRA 0x39EC
39D2  0EFE     MOVLW 0xFE
39D4  5C00     SUBWF [0x0], W, ACCESS
39D6  E105     BNZ 0x39E2
39D8  EB02     MOVSF 0x2, 0xFE6
39DA  FFE6     NOP
39DC  EC0A     CALL 0x4014, 0
39DE  F020     NOP
39E0  D004     BRA 0x39EA
39E2  EB02     MOVSF 0x2, 0xFE6
39E4  FFE6     NOP
39E6  EC03     CALL 0x6, 0
39E8  F000     NOP
39EA  E941     SUBFSR 1, 0x1
39EC  E941     SUBFSR 1, 0x1
39EE  CFE5     MOVFF POSTDEC1, FSR2H
39F0  FFDA     NOP
39F2  CFE7     MOVFF INDF1, FSR2
39F4  FFD9     NOP
39F6  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/extended/stdclib/memset.asm  ----------------------------------
35D4  0EFE     MOVLW 0xFE
35D6  CFE3     MOVFF PLUSW1, FSR0
35D8  FFE9     NOP
35DA  0EFF     MOVLW 0xFF
35DC  CFE3     MOVFF PLUSW1, FSR0H
35DE  FFEA     NOP
35E0  CFE9     MOVFF FSR0, PROD
35E2  FFF3     NOP
35E4  CFEA     MOVFF FSR0H, PRODH
35E6  FFF4     NOP
35E8  0EFB     MOVLW 0xFB
35EA  50E3     MOVF PLUSW1, W, ACCESS
35EC  E103     BNZ _2jContinue
35EE  0EFC     MOVLW 0xFC
35F0  50E3     MOVF PLUSW1, W, ACCESS
35F2  E009     BZ jEnd
35F4  0EFB     MOVLW 0xFB
35F6  06E3     DECF PLUSW1, F, ACCESS
35F8  E202     BC _3jEnd
35FA  0EFC     MOVLW 0xFC
35FC  06E3     DECF PLUSW1, F, ACCESS
35FE  0EFD     MOVLW 0xFD
3600  50E3     MOVF PLUSW1, W, ACCESS
3602  6EEE     MOVWF POSTINC0, ACCESS
3604  D7F1     BRA jLoop
3606  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/extended/stdclib/isdigit.asm  ---------------------------------
3FD0  6AF3     CLRF PROD, ACCESS
3FD2  6AF4     CLRF PRODH, ACCESS
3FD4  0EFF     MOVLW 0xFF
3FD6  24E1     ADDWF FSR1, W, ACCESS
3FD8  6EE9     MOVWF FSR0, ACCESS
3FDA  0EFF     MOVLW 0xFF
3FDC  20E2     ADDWFC FSR1H, W, ACCESS
3FDE  6EEA     MOVWF FSR0H, ACCESS
3FE0  66ED     TSTFSZ POSTDEC0, ACCESS
3FE2  D007     BRA jNoMatch
3FE4  0E2F     MOVLW 0x2F
3FE6  64EF     CPFSGT INDF0, ACCESS
3FE8  D004     BRA jNoMatch
3FEA  0E3A     MOVLW 0x3A
3FEC  60EF     CPFSLT INDF0, ACCESS
3FEE  D001     BRA jNoMatch
3FF0  2AF3     INCF PROD, F, ACCESS
3FF2  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/extended/stdclib/_user_putc.c  --------------------------------
0006  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/extended/stdclib/__init.c  ------------------------------------
0014  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/extended/startup/c018i_e.c  -----------------------------------
0000  EF18     GOTO 0x4030
0002  F020     NOP
0004  0012     RETURN 0
4030  EE1E     LFSR 1, 0xE00
4032  F000     NOP
4034  EE2E     LFSR 2, 0xE00
4036  F000     NOP
4038  6AF8     CLRF TBLPTRU, ACCESS
403A  EC9B     CALL 0x3536, 0
403C  F01A     NOP
403E  EC0A     CALL 0x14, 0
4040  F000     NOP
4042  EC19     CALL 0x832, 0
4044  F004     NOP
4046  D7FB     BRA 0x403E
4048  0012     RETURN 0
3536  0E1E     MOVLW 0x1E
3538  6EF6     MOVWF TBLPTR, ACCESS
353A  0E00     MOVLW 0x0
353C  6EF7     MOVWF TBLPTRH, ACCESS
353E  0E00     MOVLW 0x0
3540  6EF8     MOVWF TBLPTRU, ACCESS
3542  0100     MOVLB 0x0
3544  0009     TBLRD*+
3546  50F5     MOVF TABLAT, W, ACCESS
3548  6FE8     MOVWF curr_entry, BANKED
354A  0009     TBLRD*+
354C  50F5     MOVF TABLAT, W, ACCESS
354E  6FE9     MOVWF 0xE9, BANKED
3550  E103     BNZ 0x3558
3552  67E8     TSTFSZ curr_entry, BANKED
3554  D001     BRA 0x3558
3556  D03D     BRA 0x35D2
3558  0009     TBLRD*+
355A  50F5     MOVF TABLAT, W, ACCESS
355C  6FE3     MOVWF prom, BANKED
355E  0009     TBLRD*+
3560  50F5     MOVF TABLAT, W, ACCESS
3562  6FE4     MOVWF 0xE4, BANKED
3564  0009     TBLRD*+
3566  50F5     MOVF TABLAT, W, ACCESS
3568  6FE5     MOVWF 0xE5, BANKED
356A  0009     TBLRD*+
356C  0009     TBLRD*+
356E  50F5     MOVF TABLAT, W, ACCESS
3570  6EE9     MOVWF FSR0, ACCESS
3572  0009     TBLRD*+
3574  50F5     MOVF TABLAT, W, ACCESS
3576  6EEA     MOVWF FSR0H, ACCESS
3578  0009     TBLRD*+
357A  0009     TBLRD*+
357C  0009     TBLRD*+
357E  50F5     MOVF TABLAT, W, ACCESS
3580  6FE6     MOVWF curr_byte, BANKED
3582  0009     TBLRD*+
3584  50F5     MOVF TABLAT, W, ACCESS
3586  6FE7     MOVWF 0xE7, BANKED
3588  0009     TBLRD*+
358A  0009     TBLRD*+
358C  CFF6     MOVFF TBLPTR, data_ptr
358E  F0EA     NOP
3590  CFF7     MOVFF TBLPTRH, 0xEB
3592  F0EB     NOP
3594  CFF8     MOVFF TBLPTRU, 0xEC
3596  F0EC     NOP
3598  C0E3     MOVFF prom, TBLPTR
359A  FFF6     NOP
359C  C0E4     MOVFF 0xE4, TBLPTRH
359E  FFF7     NOP
35A0  C0E5     MOVFF 0xE5, TBLPTRU
35A2  FFF8     NOP
35A4  0100     MOVLB 0x0
35A6  53E6     MOVF curr_byte, F, BANKED
35A8  E102     BNZ 0x35AE
35AA  53E7     MOVF 0xE7, F, BANKED
35AC  E007     BZ 0x35BC
35AE  0009     TBLRD*+
35B0  50F5     MOVF TABLAT, W, ACCESS
35B2  6EEE     MOVWF POSTINC0, ACCESS
35B4  07E6     DECF curr_byte, F, BANKED
35B6  E2F8     BC 0x35A8
35B8  07E7     DECF 0xE7, F, BANKED
35BA  D7F9     BRA 0x35AE
35BC  C0EA     MOVFF data_ptr, TBLPTR
35BE  FFF6     NOP
35C0  C0EB     MOVFF 0xEB, TBLPTRH
35C2  FFF7     NOP
35C4  C0EC     MOVFF 0xEC, TBLPTRU
35C6  FFF8     NOP
35C8  0100     MOVLB 0x0
35CA  07E8     DECF curr_entry, F, BANKED
35CC  0E00     MOVLW 0x0
35CE  5BE9     SUBWFB 0xE9, F, BANKED
35D0  D7BF     BRA 0x3550
35D2  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/extended/proc/p18f8722.asm  -----------------------------------
3FF4  0E60     MOVLW 0x60
3FF6  6EF3     MOVWF PROD, ACCESS
3FF8  EE00     LFSR 0, 0x0
3FFA  F000     NOP
3FFC  0E0F     MOVLW 0xF
3FFE  D801     RCALL zero_block
4000  0012     RETURN 0
4002  60EA     CPFSLT FSR0H, ACCESS
4004  D002     BRA compare_l
4006  6AEE     CLRF POSTINC0, ACCESS
4008  D7FC     BRA zero_block
400A  50F3     MOVF PROD, W, ACCESS
400C  60E9     CPFSLT FSR0, ACCESS
400E  0012     RETURN 0
4010  6AEE     CLRF POSTINC0, ACCESS
4012  D7FC     BRA loop_l
---  /c18v3.46/pic18-lt/cxx-framework/src/extended/math/unpackFP.asm  -----------------------------------
23EA  3606     RLCF [0x6], F, ACCESS
23EC  3607     RLCF [0x7], F, ACCESS
23EE  E302     BNC jUnpkA1
23F0  8408     BSF [0x8], 2, ACCESS
23F2  7E08     BTG [0x8], 7, ACCESS
23F4  E106     BNZ jUnpkANZ
23F6  8008     BSF [0x8], 0, ACCESS
23F8  6A07     CLRF [0x7], ACCESS
23FA  6A06     CLRF [0x6], ACCESS
23FC  6A05     CLRF [0x5], ACCESS
23FE  6A04     CLRF [0x4], ACCESS
2400  0012     RETURN 0
2402  2807     INCF [0x7], W, ACCESS
2404  E003     BZ jUnpkA2
2406  80D8     BSF STATUS, 0, ACCESS
2408  3206     RRCF [0x6], F, ACCESS
240A  0012     RETURN 0
240C  90D8     BCF STATUS, 0, ACCESS
240E  3206     RRCF [0x6], F, ACCESS
2410  E102     BNZ jUnpkNaN
2412  8208     BSF [0x8], 1, ACCESS
2414  0012     RETURN 0
2416  8608     BSF [0x8], 3, ACCESS
2418  0012     RETURN 0
241A  3602     RLCF [0x2], F, ACCESS
241C  3603     RLCF [0x3], F, ACCESS
241E  E302     BNC jUnpkB1
2420  8C08     BSF [0x8], 6, ACCESS
2422  7E08     BTG [0x8], 7, ACCESS
2424  E106     BNZ jUnpkBNZ
2426  8808     BSF [0x8], 4, ACCESS
2428  6A03     CLRF [0x3], ACCESS
242A  6A02     CLRF [0x2], ACCESS
242C  6A01     CLRF [0x1], ACCESS
242E  6A00     CLRF [0x0], ACCESS
2430  0012     RETURN 0
2432  2803     INCF [0x3], W, ACCESS
2434  E003     BZ jUnpkB2
2436  80D8     BSF STATUS, 0, ACCESS
2438  3202     RRCF [0x2], F, ACCESS
243A  0012     RETURN 0
243C  90D8     BCF STATUS, 0, ACCESS
243E  3202     RRCF [0x2], F, ACCESS
2440  E1EA     BNZ jUnpkNaN
2442  8A08     BSF [0x8], 5, ACCESS
2444  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/extended/math/packFP.asm  -------------------------------------
2330  500C     MOVF [0xC], W, ACCESS
2332  100B     IORWF [0xB], W, ACCESS
2334  100A     IORWF [0xA], W, ACCESS
2336  1009     IORWF [0x9], W, ACCESS
2338  E055     BZ __FpReturnPosZero
233A  BE0E     BTFSC [0xE], 7, ACCESS
233C  D04D     BRA __FpReturnSignZero
233E  BE0C     BTFSC [0xC], 7, ACCESS
2340  D00C     BRA jPkShiftDone
2342  500D     MOVF [0xD], W, ACCESS
2344  100E     IORWF [0xE], W, ACCESS
2346  E048     BZ __FpReturnSignZero
2348  90D8     BCF STATUS, 0, ACCESS
234A  3609     RLCF [0x9], F, ACCESS
234C  360A     RLCF [0xA], F, ACCESS
234E  360B     RLCF [0xB], F, ACCESS
2350  360C     RLCF [0xC], F, ACCESS
2352  060D     DECF [0xD], F, ACCESS
2354  A0D8     BTFSS STATUS, 0, ACCESS
2356  060E     DECF [0xE], F, ACCESS
2358  D7F2     BRA jPkLoop
235A  500E     MOVF [0xE], W, ACCESS
235C  E131     BNZ __FpReturnSignInf
235E  280D     INCF [0xD], W, ACCESS
2360  E02F     BZ __FpReturnSignInf
2362  AE09     BTFSS [0x9], 7, ACCESS
2364  D011     BRA jPkRoundDone
2366  0E7F     MOVLW 0x7F
2368  1409     ANDWF [0x9], W, ACCESS
236A  E102     BNZ jPkRoundIt
236C  A00A     BTFSS [0xA], 0, ACCESS
236E  D00C     BRA jPkRoundDone
2370  2A0A     INCF [0xA], F, ACCESS
2372  6AE8     CLRF WREG, ACCESS
2374  220B     ADDWFC [0xB], F, ACCESS
2376  220C     ADDWFC [0xC], F, ACCESS
2378  E307     BNC jPkRoundDone
237A  80D8     BSF STATUS, 0, ACCESS
237C  320C     RRCF [0xC], F, ACCESS
237E  320B     RRCF [0xB], F, ACCESS
2380  320A     RRCF [0xA], F, ACCESS
2382  2A0D     INCF [0xD], F, ACCESS
2384  280D     INCF [0xD], W, ACCESS
2386  E01C     BZ __FpReturnSignInf
2388  500D     MOVF [0xD], W, ACCESS
238A  E026     BZ __FpReturnSignZero
238C  EB8A     MOVSS 0xA, 0x0
238E  F000     NOP
2390  EB8B     MOVSS 0xB, 0x1
2392  F001     NOP
2394  340C     RLCF [0xC], W, ACCESS
2396  6E02     MOVWF [0x2], ACCESS
2398  300D     RRCF [0xD], W, ACCESS
239A  6E03     MOVWF [0x3], ACCESS
239C  3202     RRCF [0x2], F, ACCESS
239E  9E03     BCF [0x3], 7, ACCESS
23A0  BE08     BTFSC [0x8], 7, ACCESS
23A2  8E03     BSF [0x3], 7, ACCESS
23A4  52E5     MOVF POSTDEC1, F, ACCESS
23A6  CFE5     MOVFF POSTDEC1, FSR2H
23A8  FFDA     NOP
23AA  CFE7     MOVFF INDF1, FSR2
23AC  FFD9     NOP
23AE  E94E     SUBFSR 1, 0xE
23B0  0012     RETURN 0
23B2  0E7F     MOVLW 0x7F
23B4  6E03     MOVWF [0x3], ACCESS
23B6  0EFF     MOVLW 0xFF
23B8  6E02     MOVWF [0x2], ACCESS
23BA  6E01     MOVWF [0x1], ACCESS
23BC  6E00     MOVWF [0x0], ACCESS
23BE  D7F2     BRA jExit
23C0  0E7F     MOVLW 0x7F
23C2  BE08     BTFSC [0x8], 7, ACCESS
23C4  0EFF     MOVLW 0xFF
23C6  6E03     MOVWF [0x3], ACCESS
23C8  D002     BRA jReturnPosInf0
23CA  0E7F     MOVLW 0x7F
23CC  6E03     MOVWF [0x3], ACCESS
23CE  0E80     MOVLW 0x80
23D0  6E02     MOVWF [0x2], ACCESS
23D2  6A01     CLRF [0x1], ACCESS
23D4  6A00     CLRF [0x0], ACCESS
23D6  D7E6     BRA jExit
23D8  AE08     BTFSS [0x8], 7, ACCESS
23DA  D004     BRA __FpReturnPosZero
23DC  0E80     MOVLW 0x80
23DE  6E03     MOVWF [0x3], ACCESS
23E0  6A02     CLRF [0x2], ACCESS
23E2  D7F7     BRA jZero1and2
23E4  6A03     CLRF [0x3], ACCESS
23E6  6A02     CLRF [0x2], ACCESS
23E8  D7F4     BRA jZero1and2
---  /c18v3.46/pic18-lt/cxx-framework/src/extended/math/mulFP.asm  --------------------------------------
2834  E84A     ADDFSR 1, 0xA
2836  CFD9     MOVFF FSR2, POSTINC1
2838  FFE6     NOP
283A  CFDA     MOVFF FSR2H, POSTINC1
283C  FFE6     NOP
283E  CFE1     MOVFF FSR1, FSR2
2840  FFD9     NOP
2842  CFE2     MOVFF FSR1H, FSR2H
2844  FFDA     NOP
2846  E994     SUBFSR 2, 0x14
2848  6A08     CLRF [0x8], ACCESS
284A  ECF5     CALL 0x23EA, 0
284C  F011     NOP
284E  EC0D     CALL 0x241A, 0
2850  F012     NOP
2852  B608     BTFSC [0x8], 3, ACCESS
2854  EFD9     GOTO 0x23B2
2856  F011     NOP
2858  A208     BTFSS [0x8], 1, ACCESS
285A  D005     BRA jANotInf
285C  B808     BTFSC [0x8], 4, ACCESS
285E  EFD9     GOTO 0x23B2
2860  F011     NOP
2862  EFE0     GOTO 0x23C0
2864  F011     NOP
2866  AA08     BTFSS [0x8], 5, ACCESS
2868  D005     BRA jBothFinite
286A  B008     BTFSC [0x8], 0, ACCESS
286C  EFD9     GOTO 0x23B2
286E  F011     NOP
2870  EFE0     GOTO 0x23C0
2872  F011     NOP
2874  B008     BTFSC [0x8], 0, ACCESS
2876  D002     BRA jHaveZero
2878  A808     BTFSS [0x8], 4, ACCESS
287A  D002     BRA jBothNotZero
287C  EFEC     GOTO 0x23D8
287E  F011     NOP
2880  6A0E     CLRF [0xE], ACCESS
2882  5003     MOVF [0x3], W, ACCESS
2884  2407     ADDWF [0x7], W, ACCESS
2886  6E0D     MOVWF [0xD], ACCESS
2888  6AE8     CLRF WREG, ACCESS
288A  220E     ADDWFC [0xE], F, ACCESS
288C  0E7E     MOVLW 0x7E
288E  5E0D     SUBWF [0xD], F, ACCESS
2890  6AE8     CLRF WREG, ACCESS
2892  5A0E     SUBWFB [0xE], F, ACCESS
2894  6A09     CLRF [0x9], ACCESS
2896  6A0A     CLRF [0xA], ACCESS
2898  6A0B     CLRF [0xB], ACCESS
289A  6A0C     CLRF [0xC], ACCESS
289C  5002     MOVF [0x2], W, ACCESS
289E  0206     MULWF [0x6], ACCESS
28A0  50F4     MOVF PRODH, W, ACCESS
28A2  6E0C     MOVWF [0xC], ACCESS
28A4  50F3     MOVF PROD, W, ACCESS
28A6  6E0B     MOVWF [0xB], ACCESS
28A8  5001     MOVF [0x1], W, ACCESS
28AA  0206     MULWF [0x6], ACCESS
28AC  50F3     MOVF PROD, W, ACCESS
28AE  260A     ADDWF [0xA], F, ACCESS
28B0  50F4     MOVF PRODH, W, ACCESS
28B2  220B     ADDWFC [0xB], F, ACCESS
28B4  0E00     MOVLW 0x0
28B6  220C     ADDWFC [0xC], F, ACCESS
28B8  5002     MOVF [0x2], W, ACCESS
28BA  0205     MULWF [0x5], ACCESS
28BC  50F3     MOVF PROD, W, ACCESS
28BE  260A     ADDWF [0xA], F, ACCESS
28C0  50F4     MOVF PRODH, W, ACCESS
28C2  220B     ADDWFC [0xB], F, ACCESS
28C4  0E00     MOVLW 0x0
28C6  220C     ADDWFC [0xC], F, ACCESS
28C8  5000     MOVF [0x0], W, ACCESS
28CA  0206     MULWF [0x6], ACCESS
28CC  50F3     MOVF PROD, W, ACCESS
28CE  2609     ADDWF [0x9], F, ACCESS
28D0  50F4     MOVF PRODH, W, ACCESS
28D2  220A     ADDWFC [0xA], F, ACCESS
28D4  0E00     MOVLW 0x0
28D6  220B     ADDWFC [0xB], F, ACCESS
28D8  220C     ADDWFC [0xC], F, ACCESS
28DA  5001     MOVF [0x1], W, ACCESS
28DC  0205     MULWF [0x5], ACCESS
28DE  50F3     MOVF PROD, W, ACCESS
28E0  2609     ADDWF [0x9], F, ACCESS
28E2  50F4     MOVF PRODH, W, ACCESS
28E4  220A     ADDWFC [0xA], F, ACCESS
28E6  0E00     MOVLW 0x0
28E8  220B     ADDWFC [0xB], F, ACCESS
28EA  220C     ADDWFC [0xC], F, ACCESS
28EC  5002     MOVF [0x2], W, ACCESS
28EE  0204     MULWF [0x4], ACCESS
28F0  50F3     MOVF PROD, W, ACCESS
28F2  2609     ADDWF [0x9], F, ACCESS
28F4  50F4     MOVF PRODH, W, ACCESS
28F6  220A     ADDWFC [0xA], F, ACCESS
28F8  0E00     MOVLW 0x0
28FA  220B     ADDWFC [0xB], F, ACCESS
28FC  220C     ADDWFC [0xC], F, ACCESS
28FE  5000     MOVF [0x0], W, ACCESS
2900  0205     MULWF [0x5], ACCESS
2902  50F4     MOVF PRODH, W, ACCESS
2904  2609     ADDWF [0x9], F, ACCESS
2906  0E00     MOVLW 0x0
2908  220A     ADDWFC [0xA], F, ACCESS
290A  220B     ADDWFC [0xB], F, ACCESS
290C  220C     ADDWFC [0xC], F, ACCESS
290E  5001     MOVF [0x1], W, ACCESS
2910  0204     MULWF [0x4], ACCESS
2912  50F4     MOVF PRODH, W, ACCESS
2914  2609     ADDWF [0x9], F, ACCESS
2916  0E00     MOVLW 0x0
2918  220A     ADDWFC [0xA], F, ACCESS
291A  220B     ADDWFC [0xB], F, ACCESS
291C  220C     ADDWFC [0xC], F, ACCESS
291E  EF98     GOTO 0x2330
2920  F011     NOP
---  /c18v3.46/pic18-lt/cxx-framework/src/extended/math/mul32.asm  --------------------------------------
2792  E844     ADDFSR 1, 0x4
2794  CFD9     MOVFF FSR2, POSTINC1
2796  FFE6     NOP
2798  CFDA     MOVFF FSR2H, POSTINC1
279A  FFE6     NOP
279C  CFE1     MOVFF FSR1, FSR2
279E  FFD9     NOP
27A0  CFE2     MOVFF FSR1H, FSR2H
27A2  FFDA     NOP
27A4  E98E     SUBFSR 2, 0xE
27A6  EB80     MOVSS 0x0, 0x8
27A8  F008     NOP
27AA  EB81     MOVSS 0x1, 0x9
27AC  F009     NOP
27AE  EB82     MOVSS 0x2, 0xA
27B0  F00A     NOP
27B2  EB83     MOVSS 0x3, 0xB
27B4  F00B     NOP
27B6  5004     MOVF [0x4], W, ACCESS
27B8  0208     MULWF [0x8], ACCESS
27BA  50F3     MOVF PROD, W, ACCESS
27BC  6E00     MOVWF [0x0], ACCESS
27BE  50F4     MOVF PRODH, W, ACCESS
27C0  6E01     MOVWF [0x1], ACCESS
27C2  5004     MOVF [0x4], W, ACCESS
27C4  0209     MULWF [0x9], ACCESS
27C6  50F3     MOVF PROD, W, ACCESS
27C8  2601     ADDWF [0x1], F, ACCESS
27CA  0E00     MOVLW 0x0
27CC  20F4     ADDWFC PRODH, W, ACCESS
27CE  6E02     MOVWF [0x2], ACCESS
27D0  5004     MOVF [0x4], W, ACCESS
27D2  020A     MULWF [0xA], ACCESS
27D4  50F3     MOVF PROD, W, ACCESS
27D6  2602     ADDWF [0x2], F, ACCESS
27D8  0E00     MOVLW 0x0
27DA  20F4     ADDWFC PRODH, W, ACCESS
27DC  6E03     MOVWF [0x3], ACCESS
27DE  5004     MOVF [0x4], W, ACCESS
27E0  020B     MULWF [0xB], ACCESS
27E2  50F3     MOVF PROD, W, ACCESS
27E4  2603     ADDWF [0x3], F, ACCESS
27E6  5005     MOVF [0x5], W, ACCESS
27E8  0208     MULWF [0x8], ACCESS
27EA  50F3     MOVF PROD, W, ACCESS
27EC  2601     ADDWF [0x1], F, ACCESS
27EE  50F4     MOVF PRODH, W, ACCESS
27F0  2202     ADDWFC [0x2], F, ACCESS
27F2  0E00     MOVLW 0x0
27F4  2203     ADDWFC [0x3], F, ACCESS
27F6  5005     MOVF [0x5], W, ACCESS
27F8  0209     MULWF [0x9], ACCESS
27FA  50F3     MOVF PROD, W, ACCESS
27FC  2602     ADDWF [0x2], F, ACCESS
27FE  50F4     MOVF PRODH, W, ACCESS
2800  2203     ADDWFC [0x3], F, ACCESS
2802  5005     MOVF [0x5], W, ACCESS
2804  020A     MULWF [0xA], ACCESS
2806  50F3     MOVF PROD, W, ACCESS
2808  2603     ADDWF [0x3], F, ACCESS
280A  5006     MOVF [0x6], W, ACCESS
280C  0208     MULWF [0x8], ACCESS
280E  50F3     MOVF PROD, W, ACCESS
2810  2602     ADDWF [0x2], F, ACCESS
2812  50F4     MOVF PRODH, W, ACCESS
2814  2203     ADDWFC [0x3], F, ACCESS
2816  5006     MOVF [0x6], W, ACCESS
2818  0209     MULWF [0x9], ACCESS
281A  50F3     MOVF PROD, W, ACCESS
281C  2603     ADDWF [0x3], F, ACCESS
281E  5007     MOVF [0x7], W, ACCESS
2820  0208     MULWF [0x8], ACCESS
2822  50F3     MOVF PROD, W, ACCESS
2824  2603     ADDWF [0x3], F, ACCESS
2826  52E5     MOVF POSTDEC1, F, ACCESS
2828  CFE5     MOVFF POSTDEC1, FSR2H
282A  FFDA     NOP
282C  CFE7     MOVFF INDF1, FSR2
282E  FFD9     NOP
2830  E948     SUBFSR 1, 0x8
2832  0C00     RETLW 0x0
---  /c18v3.46/pic18-lt/cxx-framework/src/extended/math/mul24.asm  --------------------------------------
26D2  E846     ADDFSR 1, 0x6
26D4  CFD9     MOVFF FSR2, POSTINC1
26D6  FFE6     NOP
26D8  CFDA     MOVFF FSR2H, POSTINC1
26DA  FFE6     NOP
26DC  CFE1     MOVFF FSR1, FSR2
26DE  FFD9     NOP
26E0  CFE2     MOVFF FSR1H, FSR2H
26E2  FFDA     NOP
26E4  E98E     SUBFSR 2, 0xE
26E6  EB80     MOVSS 0x0, 0x6
26E8  F006     NOP
26EA  EB81     MOVSS 0x1, 0x7
26EC  F007     NOP
26EE  EB82     MOVSS 0x2, 0x8
26F0  F008     NOP
26F2  EB85     MOVSS 0x5, 0xB
26F4  F00B     NOP
26F6  EB84     MOVSS 0x4, 0xA
26F8  F00A     NOP
26FA  EB83     MOVSS 0x3, 0x9
26FC  F009     NOP
26FE  5003     MOVF [0x3], W, ACCESS
2700  0206     MULWF [0x6], ACCESS
2702  50F4     MOVF PRODH, W, ACCESS
2704  6E01     MOVWF [0x1], ACCESS
2706  50F3     MOVF PROD, W, ACCESS
2708  6E00     MOVWF [0x0], ACCESS
270A  5004     MOVF [0x4], W, ACCESS
270C  0207     MULWF [0x7], ACCESS
270E  50F4     MOVF PRODH, W, ACCESS
2710  6E03     MOVWF [0x3], ACCESS
2712  50F3     MOVF PROD, W, ACCESS
2714  6E02     MOVWF [0x2], ACCESS
2716  5004     MOVF [0x4], W, ACCESS
2718  0206     MULWF [0x6], ACCESS
271A  50F3     MOVF PROD, W, ACCESS
271C  2601     ADDWF [0x1], F, ACCESS
271E  50F4     MOVF PRODH, W, ACCESS
2720  2202     ADDWFC [0x2], F, ACCESS
2722  6AE8     CLRF WREG, ACCESS
2724  2203     ADDWFC [0x3], F, ACCESS
2726  5009     MOVF [0x9], W, ACCESS
2728  0207     MULWF [0x7], ACCESS
272A  50F3     MOVF PROD, W, ACCESS
272C  2601     ADDWF [0x1], F, ACCESS
272E  50F4     MOVF PRODH, W, ACCESS
2730  2202     ADDWFC [0x2], F, ACCESS
2732  6AE8     CLRF WREG, ACCESS
2734  2203     ADDWFC [0x3], F, ACCESS
2736  5005     MOVF [0x5], W, ACCESS
2738  0206     MULWF [0x6], ACCESS
273A  50F3     MOVF PROD, W, ACCESS
273C  2602     ADDWF [0x2], F, ACCESS
273E  50F4     MOVF PRODH, W, ACCESS
2740  2203     ADDWFC [0x3], F, ACCESS
2742  5005     MOVF [0x5], W, ACCESS
2744  0207     MULWF [0x7], ACCESS
2746  6A04     CLRF [0x4], ACCESS
2748  6AE8     CLRF WREG, ACCESS
274A  2204     ADDWFC [0x4], F, ACCESS
274C  50F3     MOVF PROD, W, ACCESS
274E  2603     ADDWF [0x3], F, ACCESS
2750  50F4     MOVF PRODH, W, ACCESS
2752  2204     ADDWFC [0x4], F, ACCESS
2754  5009     MOVF [0x9], W, ACCESS
2756  0208     MULWF [0x8], ACCESS
2758  50F3     MOVF PROD, W, ACCESS
275A  2602     ADDWF [0x2], F, ACCESS
275C  50F4     MOVF PRODH, W, ACCESS
275E  2203     ADDWFC [0x3], F, ACCESS
2760  6A05     CLRF [0x5], ACCESS
2762  6AE8     CLRF WREG, ACCESS
2764  2204     ADDWFC [0x4], F, ACCESS
2766  2205     ADDWFC [0x5], F, ACCESS
2768  500A     MOVF [0xA], W, ACCESS
276A  0208     MULWF [0x8], ACCESS
276C  50F3     MOVF PROD, W, ACCESS
276E  2603     ADDWF [0x3], F, ACCESS
2770  50F4     MOVF PRODH, W, ACCESS
2772  2204     ADDWFC [0x4], F, ACCESS
2774  6AE8     CLRF WREG, ACCESS
2776  2205     ADDWFC [0x5], F, ACCESS
2778  500B     MOVF [0xB], W, ACCESS
277A  0208     MULWF [0x8], ACCESS
277C  50F3     MOVF PROD, W, ACCESS
277E  2604     ADDWF [0x4], F, ACCESS
2780  50F4     MOVF PRODH, W, ACCESS
2782  2205     ADDWFC [0x5], F, ACCESS
2784  52E5     MOVF POSTDEC1, F, ACCESS
2786  CFE5     MOVFF POSTDEC1, FSR2H
2788  FFDA     NOP
278A  CFE7     MOVFF INDF1, FSR2
278C  FFD9     NOP
278E  E949     SUBFSR 1, 0x9
2790  0C00     RETLW 0x0
---  /c18v3.46/pic18-lt/cxx-framework/src/extended/math/mul16.asm  --------------------------------------
2922  E844     ADDFSR 1, 0x4
2924  CFD9     MOVFF FSR2, POSTINC1
2926  FFE6     NOP
2928  CFDA     MOVFF FSR2H, POSTINC1
292A  FFE6     NOP
292C  CFE1     MOVFF FSR1, FSR2
292E  FFD9     NOP
2930  CFE2     MOVFF FSR1H, FSR2H
2932  FFDA     NOP
2934  E98A     SUBFSR 2, 0xA
2936  EB80     MOVSS 0x0, 0x4
2938  F004     NOP
293A  EB81     MOVSS 0x1, 0x5
293C  F005     NOP
293E  EB82     MOVSS 0x2, 0x6
2940  F006     NOP
2942  5002     MOVF [0x2], W, ACCESS
2944  0204     MULWF [0x4], ACCESS
2946  50F4     MOVF PRODH, W, ACCESS
2948  6E01     MOVWF [0x1], ACCESS
294A  50F3     MOVF PROD, W, ACCESS
294C  6E00     MOVWF [0x0], ACCESS
294E  5003     MOVF [0x3], W, ACCESS
2950  6E07     MOVWF [0x7], ACCESS
2952  0205     MULWF [0x5], ACCESS
2954  50F4     MOVF PRODH, W, ACCESS
2956  6E03     MOVWF [0x3], ACCESS
2958  50F3     MOVF PROD, W, ACCESS
295A  6E02     MOVWF [0x2], ACCESS
295C  5007     MOVF [0x7], W, ACCESS
295E  0204     MULWF [0x4], ACCESS
2960  50F3     MOVF PROD, W, ACCESS
2962  2601     ADDWF [0x1], F, ACCESS
2964  50F4     MOVF PRODH, W, ACCESS
2966  2202     ADDWFC [0x2], F, ACCESS
2968  6AE8     CLRF WREG, ACCESS
296A  2203     ADDWFC [0x3], F, ACCESS
296C  5006     MOVF [0x6], W, ACCESS
296E  0205     MULWF [0x5], ACCESS
2970  50F3     MOVF PROD, W, ACCESS
2972  2601     ADDWF [0x1], F, ACCESS
2974  50F4     MOVF PRODH, W, ACCESS
2976  2202     ADDWFC [0x2], F, ACCESS
2978  6AE8     CLRF WREG, ACCESS
297A  2203     ADDWFC [0x3], F, ACCESS
297C  52E5     MOVF POSTDEC1, F, ACCESS
297E  CFE5     MOVFF POSTDEC1, FSR2H
2980  FFDA     NOP
2982  CFE7     MOVFF INDF1, FSR2
2984  FFD9     NOP
2986  E946     SUBFSR 1, 0x6
2988  0C00     RETLW 0x0
---  /c18v3.46/pic18-lt/cxx-framework/src/extended/math/divFP.asm  --------------------------------------
2618  E84A     ADDFSR 1, 0xA
261A  CFD9     MOVFF FSR2, POSTINC1
261C  FFE6     NOP
261E  CFDA     MOVFF FSR2H, POSTINC1
2620  FFE6     NOP
2622  CFE1     MOVFF FSR1, FSR2
2624  FFD9     NOP
2626  CFE2     MOVFF FSR1H, FSR2H
2628  FFDA     NOP
262A  E994     SUBFSR 2, 0x14
262C  6A08     CLRF [0x8], ACCESS
262E  ECF5     CALL 0x23EA, 0
2630  F011     NOP
2632  EC0D     CALL 0x241A, 0
2634  F012     NOP
2636  B608     BTFSC [0x8], 3, ACCESS
2638  EFD9     GOTO 0x23B2
263A  F011     NOP
263C  A208     BTFSS [0x8], 1, ACCESS
263E  D005     BRA jDivANotInf
2640  BA08     BTFSC [0x8], 5, ACCESS
2642  EFD9     GOTO 0x23B2
2644  F011     NOP
2646  EFE0     GOTO 0x23C0
2648  F011     NOP
264A  BA08     BTFSC [0x8], 5, ACCESS
264C  EFEC     GOTO 0x23D8
264E  F011     NOP
2650  A008     BTFSS [0x8], 0, ACCESS
2652  D005     BRA jDivANotZero
2654  B808     BTFSC [0x8], 4, ACCESS
2656  EFD9     GOTO 0x23B2
2658  F011     NOP
265A  EFEC     GOTO 0x23D8
265C  F011     NOP
265E  B808     BTFSC [0x8], 4, ACCESS
2660  EFE0     GOTO 0x23C0
2662  F011     NOP
2664  6A0E     CLRF [0xE], ACCESS
2666  0E7F     MOVLW 0x7F
2668  2407     ADDWF [0x7], W, ACCESS
266A  6E0D     MOVWF [0xD], ACCESS
266C  6AE8     CLRF WREG, ACCESS
266E  220E     ADDWFC [0xE], F, ACCESS
2670  5003     MOVF [0x3], W, ACCESS
2672  5E0D     SUBWF [0xD], F, ACCESS
2674  6AE8     CLRF WREG, ACCESS
2676  5A0E     SUBWFB [0xE], F, ACCESS
2678  0E1A     MOVLW 0x1A
267A  6E0F     MOVWF [0xF], ACCESS
267C  6A07     CLRF [0x7], ACCESS
267E  6A09     CLRF [0x9], ACCESS
2680  6A0A     CLRF [0xA], ACCESS
2682  6A0B     CLRF [0xB], ACCESS
2684  6A0C     CLRF [0xC], ACCESS
2686  5000     MOVF [0x0], W, ACCESS
2688  5E04     SUBWF [0x4], F, ACCESS
268A  5001     MOVF [0x1], W, ACCESS
268C  5A05     SUBWFB [0x5], F, ACCESS
268E  5002     MOVF [0x2], W, ACCESS
2690  5A06     SUBWFB [0x6], F, ACCESS
2692  0E00     MOVLW 0x0
2694  5A07     SUBWFB [0x7], F, ACCESS
2696  E709     BNN jNoAdjust
2698  5000     MOVF [0x0], W, ACCESS
269A  2604     ADDWF [0x4], F, ACCESS
269C  5001     MOVF [0x1], W, ACCESS
269E  2205     ADDWFC [0x5], F, ACCESS
26A0  5002     MOVF [0x2], W, ACCESS
26A2  2206     ADDWFC [0x6], F, ACCESS
26A4  0E00     MOVLW 0x0
26A6  2207     ADDWFC [0x7], F, ACCESS
26A8  D001     BRA jDivNext
26AA  8A09     BSF [0x9], 5, ACCESS
26AC  90D8     BCF STATUS, 0, ACCESS
26AE  3604     RLCF [0x4], F, ACCESS
26B0  3605     RLCF [0x5], F, ACCESS
26B2  3606     RLCF [0x6], F, ACCESS
26B4  3607     RLCF [0x7], F, ACCESS
26B6  90D8     BCF STATUS, 0, ACCESS
26B8  3609     RLCF [0x9], F, ACCESS
26BA  360A     RLCF [0xA], F, ACCESS
26BC  360B     RLCF [0xB], F, ACCESS
26BE  360C     RLCF [0xC], F, ACCESS
26C0  2E0F     DECFSZ [0xF], F, ACCESS
26C2  D7E1     BRA jDivLoop
26C4  5006     MOVF [0x6], W, ACCESS
26C6  1005     IORWF [0x5], W, ACCESS
26C8  1004     IORWF [0x4], W, ACCESS
26CA  A4D8     BTFSS STATUS, 2, ACCESS
26CC  8A09     BSF [0x9], 5, ACCESS
26CE  EF98     GOTO 0x2330
26D0  F011     NOP
---  /c18v3.46/pic18-lt/cxx-framework/src/extended/math/div32u.asm  -------------------------------------
2574  E845     ADDFSR 1, 0x5
2576  CFD9     MOVFF FSR2, POSTINC1
2578  FFE6     NOP
257A  CFDA     MOVFF FSR2H, POSTINC1
257C  FFE6     NOP
257E  CFE1     MOVFF FSR1, FSR2
2580  FFD9     NOP
2582  CFE2     MOVFF FSR1H, FSR2H
2584  FFDA     NOP
2586  E98F     SUBFSR 2, 0xF
2588  6A0C     CLRF [0xC], ACCESS
258A  0012     RETURN 0
258C  DFF3     RCALL SETUPSTK
258E  800C     BSF [0xC], 0, ACCESS
2590  D003     BRA divmod32u
2592  DFF0     RCALL SETUPSTK
2594  D001     BRA divmod32u
2596  820C     BSF [0xC], 1, ACCESS
2598  6A0B     CLRF [0xB], ACCESS
259A  6A0A     CLRF [0xA], ACCESS
259C  6A09     CLRF [0x9], ACCESS
259E  6A08     CLRF [0x8], ACCESS
25A0  0E20     MOVLW 0x20
25A2  6EE7     MOVWF INDF1, ACCESS
25A4  90D8     BCF STATUS, 0, ACCESS
25A6  3604     RLCF [0x4], F, ACCESS
25A8  3605     RLCF [0x5], F, ACCESS
25AA  3606     RLCF [0x6], F, ACCESS
25AC  3607     RLCF [0x7], F, ACCESS
25AE  3608     RLCF [0x8], F, ACCESS
25B0  3609     RLCF [0x9], F, ACCESS
25B2  360A     RLCF [0xA], F, ACCESS
25B4  360B     RLCF [0xB], F, ACCESS
25B6  5000     MOVF [0x0], W, ACCESS
25B8  5C08     SUBWF [0x8], W, ACCESS
25BA  5001     MOVF [0x1], W, ACCESS
25BC  5809     SUBWFB [0x9], W, ACCESS
25BE  5002     MOVF [0x2], W, ACCESS
25C0  580A     SUBWFB [0xA], W, ACCESS
25C2  5003     MOVF [0x3], W, ACCESS
25C4  580B     SUBWFB [0xB], W, ACCESS
25C6  E309     BNC _false
25C8  5000     MOVF [0x0], W, ACCESS
25CA  5E08     SUBWF [0x8], F, ACCESS
25CC  5001     MOVF [0x1], W, ACCESS
25CE  5A09     SUBWFB [0x9], F, ACCESS
25D0  5002     MOVF [0x2], W, ACCESS
25D2  5A0A     SUBWFB [0xA], F, ACCESS
25D4  5003     MOVF [0x3], W, ACCESS
25D6  5A0B     SUBWFB [0xB], F, ACCESS
25D8  2A04     INCF [0x4], F, ACCESS
25DA  2EE7     DECFSZ INDF1, F, ACCESS
25DC  D7E4     BRA loop
25DE  B20C     BTFSC [0xC], 1, ACCESS
25E0  0012     RETURN 0
25E2  B00C     BTFSC [0xC], 0, ACCESS
25E4  D00A     BRA RETQUOTIENT
25E6  EB88     MOVSS 0x8, 0x0
25E8  F000     NOP
25EA  EB89     MOVSS 0x9, 0x1
25EC  F001     NOP
25EE  EB8A     MOVSS 0xA, 0x2
25F0  F002     NOP
25F2  EB8B     MOVSS 0xB, 0x3
25F4  F003     NOP
25F6  A00C     BTFSS [0xC], 0, ACCESS
25F8  D008     BRA RESTORE
25FA  EB84     MOVSS 0x4, 0x0
25FC  F000     NOP
25FE  EB85     MOVSS 0x5, 0x1
2600  F001     NOP
2602  EB86     MOVSS 0x6, 0x2
2604  F002     NOP
2606  EB87     MOVSS 0x7, 0x3
2608  F003     NOP
260A  52E5     MOVF POSTDEC1, F, ACCESS
260C  CFE5     MOVFF POSTDEC1, FSR2H
260E  FFDA     NOP
2610  CFE7     MOVFF INDF1, FSR2
2612  FFD9     NOP
2614  E949     SUBFSR 1, 0x9
2616  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/extended/math/castFP32.asm  -----------------------------------
24D6  E845     ADDFSR 1, 0x5
24D8  CFD9     MOVFF FSR2, POSTINC1
24DA  FFE6     NOP
24DC  CFDA     MOVFF FSR2H, POSTINC1
24DE  FFE6     NOP
24E0  CFE1     MOVFF FSR1, FSR2
24E2  FFD9     NOP
24E4  CFE2     MOVFF FSR1H, FSR2H
24E6  FFDA     NOP
24E8  E98B     SUBFSR 2, 0xB
24EA  6A08     CLRF [0x8], ACCESS
24EC  EC0D     CALL 0x241A, 0
24EE  F012     NOP
24F0  B608     BTFSC [0x8], 3, ACCESS
24F2  EF7F     GOTO 0x24FE
24F4  F012     NOP
24F6  AA08     BTFSS [0x8], 5, ACCESS
24F8  D00F     BRA jNotInf
24FA  BC08     BTFSC [0x8], 6, ACCESS
24FC  D007     BRA jMaxNeg
24FE  0E7F     MOVLW 0x7F
2500  6E03     MOVWF [0x3], ACCESS
2502  0EFF     MOVLW 0xFF
2504  6E02     MOVWF [0x2], ACCESS
2506  6E01     MOVWF [0x1], ACCESS
2508  6E00     MOVWF [0x0], ACCESS
250A  D02D     BRA jExit
250C  0E80     MOVLW 0x80
250E  6E03     MOVWF [0x3], ACCESS
2510  D001     BRA jWrZ123
2512  6A03     CLRF [0x3], ACCESS
2514  0E00     MOVLW 0x0
2516  D7F6     BRA jWr123
2518  B808     BTFSC [0x8], 4, ACCESS
251A  D7FB     BRA jZero
251C  6A07     CLRF [0x7], ACCESS
251E  0E9F     MOVLW 0x9F
2520  6003     CPFSLT [0x3], ACCESS
2522  D7EB     BRA jMax
2524  0E7E     MOVLW 0x7E
2526  6403     CPFSGT [0x3], ACCESS
2528  D7F4     BRA jZero
252A  0E9E     MOVLW 0x9E
252C  5C03     SUBWF [0x3], W, ACCESS
252E  E007     BZ jLoopExit
2530  90D8     BCF STATUS, 0, ACCESS
2532  3202     RRCF [0x2], F, ACCESS
2534  3201     RRCF [0x1], F, ACCESS
2536  3200     RRCF [0x0], F, ACCESS
2538  3207     RRCF [0x7], F, ACCESS
253A  2A03     INCF [0x3], F, ACCESS
253C  D7F6     BRA jLoop
253E  AC08     BTFSS [0x8], 6, ACCESS
2540  D00A     BRA jDone
2542  6C07     NEGF [0x7], ACCESS
2544  1E00     COMF [0x0], F, ACCESS
2546  1E01     COMF [0x1], F, ACCESS
2548  1E02     COMF [0x2], F, ACCESS
254A  6AE8     CLRF WREG, ACCESS
254C  2200     ADDWFC [0x0], F, ACCESS
254E  2201     ADDWFC [0x1], F, ACCESS
2550  2202     ADDWFC [0x2], F, ACCESS
2552  AE02     BTFSS [0x2], 7, ACCESS
2554  D7DE     BRA jZero
2556  EB82     MOVSS 0x2, 0x3
2558  F003     NOP
255A  EB81     MOVSS 0x1, 0x2
255C  F002     NOP
255E  EB80     MOVSS 0x0, 0x1
2560  F001     NOP
2562  EB87     MOVSS 0x7, 0x0
2564  F000     NOP
2566  52E5     MOVF POSTDEC1, F, ACCESS
2568  CFE5     MOVFF POSTDEC1, FSR2H
256A  FFDA     NOP
256C  CFE7     MOVFF INDF1, FSR2
256E  FFD9     NOP
2570  E945     SUBFSR 1, 0x5
2572  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/extended/math/cast32FP.asm  -----------------------------------
2488  98D8     BCF STATUS, 4, ACCESS
248A  D001     BRA jBeg
248C  88D8     BSF STATUS, 4, ACCESS
248E  E84E     ADDFSR 1, 0xE
2490  CFD9     MOVFF FSR2, POSTINC1
2492  FFE6     NOP
2494  CFDA     MOVFF FSR2H, POSTINC1
2496  FFE6     NOP
2498  CFE1     MOVFF FSR1, FSR2
249A  FFD9     NOP
249C  CFE2     MOVFF FSR1H, FSR2H
249E  FFDA     NOP
24A0  E994     SUBFSR 2, 0x14
24A2  9E08     BCF [0x8], 7, ACCESS
24A4  E70B     BNN jNotNeg
24A6  AE03     BTFSS [0x3], 7, ACCESS
24A8  D009     BRA jNotNeg
24AA  6C00     NEGF [0x0], ACCESS
24AC  1E01     COMF [0x1], F, ACCESS
24AE  1E02     COMF [0x2], F, ACCESS
24B0  1E03     COMF [0x3], F, ACCESS
24B2  6AE8     CLRF WREG, ACCESS
24B4  2201     ADDWFC [0x1], F, ACCESS
24B6  2202     ADDWFC [0x2], F, ACCESS
24B8  2203     ADDWFC [0x3], F, ACCESS
24BA  8E08     BSF [0x8], 7, ACCESS
24BC  EB83     MOVSS 0x3, 0xC
24BE  F00C     NOP
24C0  EB82     MOVSS 0x2, 0xB
24C2  F00B     NOP
24C4  EB81     MOVSS 0x1, 0xA
24C6  F00A     NOP
24C8  EB80     MOVSS 0x0, 0x9
24CA  F009     NOP
24CC  0E9E     MOVLW 0x9E
24CE  6E0D     MOVWF [0xD], ACCESS
24D0  6A0E     CLRF [0xE], ACCESS
24D2  EF98     GOTO 0x2330
24D4  F011     NOP
---  /c18v3.46/pic18-lt/cxx-framework/src/extended/math/cast16FP.asm  -----------------------------------
2446  98D8     BCF STATUS, 4, ACCESS
2448  D001     BRA jBeg
244A  88D8     BSF STATUS, 4, ACCESS
244C  E850     ADDFSR 1, 0x10
244E  CFD9     MOVFF FSR2, POSTINC1
2450  FFE6     NOP
2452  CFDA     MOVFF FSR2H, POSTINC1
2454  FFE6     NOP
2456  CFE1     MOVFF FSR1, FSR2
2458  FFD9     NOP
245A  CFE2     MOVFF FSR1H, FSR2H
245C  FFDA     NOP
245E  E994     SUBFSR 2, 0x14
2460  9E08     BCF [0x8], 7, ACCESS
2462  E707     BNN jNotNeg
2464  AE01     BTFSS [0x1], 7, ACCESS
2466  D005     BRA jNotNeg
2468  6C00     NEGF [0x0], ACCESS
246A  1E01     COMF [0x1], F, ACCESS
246C  6AE8     CLRF WREG, ACCESS
246E  2201     ADDWFC [0x1], F, ACCESS
2470  8E08     BSF [0x8], 7, ACCESS
2472  EB81     MOVSS 0x1, 0xC
2474  F00C     NOP
2476  EB80     MOVSS 0x0, 0xB
2478  F00B     NOP
247A  6A0A     CLRF [0xA], ACCESS
247C  6A09     CLRF [0x9], ACCESS
247E  0E8E     MOVLW 0x8E
2480  6E0D     MOVWF [0xD], ACCESS
2482  6A0E     CLRF [0xE], ACCESS
2484  EF98     GOTO 0x2330
2486  F011     NOP
---  /c18v3.46/pic18-lt/cxx-framework/src/extended/math/addFP.asm  --------------------------------------
21E6  88D8     BSF STATUS, 4, ACCESS
21E8  D001     BRA jBeg
21EA  98D8     BCF STATUS, 4, ACCESS
21EC  E84A     ADDFSR 1, 0xA
21EE  CFD9     MOVFF FSR2, POSTINC1
21F0  FFE6     NOP
21F2  CFDA     MOVFF FSR2H, POSTINC1
21F4  FFE6     NOP
21F6  CFE1     MOVFF FSR1, FSR2
21F8  FFD9     NOP
21FA  CFE2     MOVFF FSR1H, FSR2H
21FC  FFDA     NOP
21FE  E994     SUBFSR 2, 0x14
2200  B8D8     BTFSC STATUS, 4, ACCESS
2202  7E03     BTG [0x3], 7, ACCESS
2204  6A08     CLRF [0x8], ACCESS
2206  ECF5     CALL 0x23EA, 0
2208  F011     NOP
220A  EC0D     CALL 0x241A, 0
220C  F012     NOP
220E  B608     BTFSC [0x8], 3, ACCESS
2210  EFD9     GOTO 0x23B2
2212  F011     NOP
2214  A208     BTFSS [0x8], 1, ACCESS
2216  D00A     BRA jANotInf
2218  AA08     BTFSS [0x8], 5, ACCESS
221A  D003     BRA jBANotInf
221C  BE08     BTFSC [0x8], 7, ACCESS
221E  EFD9     GOTO 0x23B2
2220  F011     NOP
2222  A408     BTFSS [0x8], 2, ACCESS
2224  EFE5     GOTO 0x23CA
2226  F011     NOP
2228  EFE2     GOTO 0x23C4
222A  F011     NOP
222C  AA08     BTFSS [0x8], 5, ACCESS
222E  D005     BRA jBNotInf
2230  AC08     BTFSS [0x8], 6, ACCESS
2232  EFE5     GOTO 0x23CA
2234  F011     NOP
2236  EFE2     GOTO 0x23C4
2238  F011     NOP
223A  A008     BTFSS [0x8], 0, ACCESS
223C  D00A     BRA jNotBothZero
223E  A808     BTFSS [0x8], 4, ACCESS
2240  D008     BRA jNotBothZero
2242  BE08     BTFSC [0x8], 7, ACCESS
2244  D004     BRA jDifOrPosSign
2246  A408     BTFSS [0x8], 2, ACCESS
2248  D002     BRA jDifOrPosSign
224A  EFEE     GOTO 0x23DC
224C  F011     NOP
224E  EFF2     GOTO 0x23E4
2250  F011     NOP
2252  6A09     CLRF [0x9], ACCESS
2254  6A0E     CLRF [0xE], ACCESS
2256  5003     MOVF [0x3], W, ACCESS
2258  5C07     SUBWF [0x7], W, ACCESS
225A  6E10     MOVWF [0x10], ACCESS
225C  E310     BNC jAltBexp
225E  EB84     MOVSS 0x4, 0xA
2260  F00A     NOP
2262  EB85     MOVSS 0x5, 0xB
2264  F00B     NOP
2266  EB86     MOVSS 0x6, 0xC
2268  F00C     NOP
226A  EB87     MOVSS 0x7, 0xF
226C  F00F     NOP
226E  EB80     MOVSS 0x0, 0x4
2270  F004     NOP
2272  EB81     MOVSS 0x1, 0x5
2274  F005     NOP
2276  EB82     MOVSS 0x2, 0x6
2278  F006     NOP
227A  3A08     SWAPF [0x8], F, ACCESS
227C  D009     BRA jAandWsetup
227E  EB80     MOVSS 0x0, 0xA
2280  F00A     NOP
2282  EB81     MOVSS 0x1, 0xB
2284  F00B     NOP
2286  EB82     MOVSS 0x2, 0xC
2288  F00C     NOP
228A  EB83     MOVSS 0x3, 0xF
228C  F00F     NOP
228E  6C10     NEGF [0x10], ACCESS
2290  9E08     BCF [0x8], 7, ACCESS
2292  BC08     BTFSC [0x8], 6, ACCESS
2294  8E08     BSF [0x8], 7, ACCESS
2296  EB8F     MOVSS 0xF, 0xD
2298  F00D     NOP
229A  B008     BTFSC [0x8], 0, ACCESS
229C  EFC4     GOTO 0x2388
229E  F011     NOP
22A0  0E1A     MOVLW 0x1A
22A2  6010     CPFSLT [0x10], ACCESS
22A4  EFC4     GOTO 0x2388
22A6  F011     NOP
22A8  6A0D     CLRF [0xD], ACCESS
22AA  6A07     CLRF [0x7], ACCESS
22AC  A408     BTFSS [0x8], 2, ACCESS
22AE  D008     BRA jANotNeg
22B0  6C04     NEGF [0x4], ACCESS
22B2  1E05     COMF [0x5], F, ACCESS
22B4  1E06     COMF [0x6], F, ACCESS
22B6  1E07     COMF [0x7], F, ACCESS
22B8  6AE8     CLRF WREG, ACCESS
22BA  2205     ADDWFC [0x5], F, ACCESS
22BC  2206     ADDWFC [0x6], F, ACCESS
22BE  2207     ADDWFC [0x7], F, ACCESS
22C0  AC08     BTFSS [0x8], 6, ACCESS
22C2  D008     BRA jWNotNeg
22C4  6C0A     NEGF [0xA], ACCESS
22C6  1E0B     COMF [0xB], F, ACCESS
22C8  1E0C     COMF [0xC], F, ACCESS
22CA  1E0D     COMF [0xD], F, ACCESS
22CC  6AE8     CLRF WREG, ACCESS
22CE  220B     ADDWFC [0xB], F, ACCESS
22D0  220C     ADDWFC [0xC], F, ACCESS
22D2  220D     ADDWFC [0xD], F, ACCESS
22D4  6A11     CLRF [0x11], ACCESS
22D6  5210     MOVF [0x10], F, ACCESS
22D8  E007     BZ jShiftDone
22DA  3407     RLCF [0x7], W, ACCESS
22DC  3206     RRCF [0x6], F, ACCESS
22DE  3205     RRCF [0x5], F, ACCESS
22E0  3204     RRCF [0x4], F, ACCESS
22E2  3211     RRCF [0x11], F, ACCESS
22E4  2E10     DECFSZ [0x10], F, ACCESS
22E6  D7F9     BRA jShiftLoop
22E8  5004     MOVF [0x4], W, ACCESS
22EA  260A     ADDWF [0xA], F, ACCESS
22EC  5005     MOVF [0x5], W, ACCESS
22EE  220B     ADDWFC [0xB], F, ACCESS
22F0  5006     MOVF [0x6], W, ACCESS
22F2  220C     ADDWFC [0xC], F, ACCESS
22F4  5007     MOVF [0x7], W, ACCESS
22F6  220D     ADDWFC [0xD], F, ACCESS
22F8  EB91     MOVSS 0x11, 0x9
22FA  F009     NOP
22FC  9E08     BCF [0x8], 7, ACCESS
22FE  AE0D     BTFSS [0xD], 7, ACCESS
2300  D00B     BRA jSignDone
2302  6C09     NEGF [0x9], ACCESS
2304  1E0A     COMF [0xA], F, ACCESS
2306  1E0B     COMF [0xB], F, ACCESS
2308  1E0C     COMF [0xC], F, ACCESS
230A  1E0D     COMF [0xD], F, ACCESS
230C  6AE8     CLRF WREG, ACCESS
230E  220A     ADDWFC [0xA], F, ACCESS
2310  220B     ADDWFC [0xB], F, ACCESS
2312  220C     ADDWFC [0xC], F, ACCESS
2314  220D     ADDWFC [0xD], F, ACCESS
2316  8E08     BSF [0x8], 7, ACCESS
2318  A00D     BTFSS [0xD], 0, ACCESS
231A  D006     BRA jFinalSign
231C  80D8     BSF STATUS, 0, ACCESS
231E  320C     RRCF [0xC], F, ACCESS
2320  320B     RRCF [0xB], F, ACCESS
2322  320A     RRCF [0xA], F, ACCESS
2324  3209     RRCF [0x9], F, ACCESS
2326  2A0F     INCF [0xF], F, ACCESS
2328  EB8F     MOVSS 0xF, 0xD
232A  F00D     NOP
232C  EF98     GOTO 0x2330
232E  F011     NOP
---  /c18v3.46/pic18-lt/cxx-framework/src/extended/delays/d10tcyx.asm  ----------------------------------
404A  0EFF     MOVLW 0xFF
404C  50E3     MOVF PLUSW1, W, ACCESS
404E  4EE8     DCFSNZ WREG, F, ACCESS
4050  0012     RETURN 0
4052  0000     NOP
4054  D000     BRA _D10TCYXCODE_000C
4056  D000     BRA _D10TCYXCODE_000E
4058  D000     BRA D10_1
405A  2EE8     DECFSZ WREG, F, ACCESS
405C  D7FA     BRA D10x
405E  0012     RETURN 0
---  /c18v3.46/pic18-lt/cxx-framework/src/extended/delays/d10ktcyx.asm  ---------------------------------
3E46  0EFF     MOVLW 0xFF
3E48  50E3     MOVF PLUSW1, W, ACCESS
3E4A  0102     MOVLB 0x2
3E4C  6FF0     MOVWF 0xF0, BANKED
3E4E  0EEE     MOVLW 0xEE
3E50  D002     BRA D10K_1
3E52  0EF2     MOVLW 0xF2
3E54  0000     NOP
3E56  6EE7     MOVWF INDF1, ACCESS
3E58  2EE7     DECFSZ INDF1, F, ACCESS
3E5A  EF2C     GOTO 0x3E58
3E5C  F01F     NOP
3E5E  0E0C     MOVLW 0xC
3E60  0102     MOVLB 0x2
3E62  6FEF     MOVWF lcd_buf, BANKED
3E64  6AE7     CLRF INDF1, ACCESS
3E66  2EE7     DECFSZ INDF1, F, ACCESS
3E68  EF33     GOTO 0x3E66
3E6A  F01F     NOP
3E6C  2FEF     DECFSZ lcd_buf, F, BANKED
3E6E  EF32     GOTO 0x3E64
3E70  F01F     NOP
3E72  0102     MOVLB 0x2
3E74  2FF0     DECFSZ 0xF0, F, BANKED
3E76  EF29     GOTO 0x3E52
3E78  F01F     NOP
3E7A  0012     RETURN 0
